<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
  <meta name="generator" content="Jekyll">

  <title>Немного о прерываниях, их обработке и есесна ядре [ru]</title>

  <link rel="stylesheet" href="/css/main.css">
  <!-- <link href="assets/favicon.ico" rel="icon" type="image/x-icon" /> -->
  <link rel="shortcut icon" type="image/png" href="assets//favicon.png">
  <link href="/atom.xml" type="application/atom+xml" rel="alternate" title="ATOM Feed" /> <!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Немного о прерываниях, их обработке и есесна ядре [ru] | Windows Internals Blog</title>
<meta name="generator" content="Jekyll v4.3.3" />
<meta property="og:title" content="Немного о прерываниях, их обработке и есесна ядре [ru]" />
<meta name="author" content="truebad0ur" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Тут будет перевод одной статейки для погружения в теорию: статейка Interrupt Dispatching Internals Microsoft изменили способ обработки прерываний в последних версиях Windows. Были опубликованы некоторые публичные ресёрчи по обработке прерываний на старых версиях Windows и на 32-битных системах, однако не так много информации можно найти о том, как это работает в современном мире. В этой статье я попытаюсь привести описание обработки исключений на 64-битной Windows 10, в особенности Windows 10 RS1 Anniversary Update Build 10.0.10586 Прерывания используются операционными системами, чтобы получать сообщения об ивентах, происходящих на оборудовании. Обработка исключений - это механизм, в котором процессор передаёт контроль исполнения программному обеспечению, чтобы обработать событие на оборудовании. Прерывания обрабатываются ядром Windows, которое сначала выполняет некоторые служебные действия перед передачей контроля исполнения драйверам железа, которые в свою очередь регистрируют ISR (функции обработчика прерывания). IDT (Interrupt Descriptor Table) - это основная структура, задействованная в обработке исключений и её формат устанавливает разработчик процессора. IDT должна быть заполнена на этапе загрузки и соответственно должна использоваться процессором для обработки прерываний, приходящих с устройств IDTR Register У процессоров есть встроенный регистр, называемый IDTR, который Windows заполняет виртуальным адресом IDT в ядре, который он устанавливает для каждого процессора на этапе загрузки. Значение регистра IDTR для каждого процессора. На мульти процессорной системе каждый процессор имеет свой IDTR регистр, который указывает на локальную приватную копию IDT 0: kd&gt; ~0 0: kd&gt; r @idtr idtr=fffff8051ae62000 0: kd&gt; ~1 1: kd&gt; r @idtr idtr=ffffb70107dad000 1: kd&gt; ~2 2: kd&gt; r @idtr idtr=ffffb701077ea000 Interrupt Descriptor Table IDT содержит всего 256 значений, некоторые из которых используются для исключений, некоторые для программных прерываний, а остальные для прерываний железа. Индекс в IDT, по которому выбирают конкретный элемент, называется вектором прерывания. Формат каждого элемента IDT описывается разработчиком процессора. Ядро Windows определяет структуру KIDTENTRY64, которая представляет собой один элемент IDT на 64-битном процессоре. Используя вывод предыдущей команды “r @idtr”, мы можем вывести нулевой элемент IDT, на который указывает IDTR 0: kd&gt; ~0 0: kd&gt; r @idtr idtr=fffff8051ae62000 0: kd&gt; dt nt!_KIDTENTRY64 fffff8051ae62000 +0x000 OffsetLow : 0x1c00 +0x002 Selector : 0x10 +0x004 IstIndex : 0y000 +0x004 Reserved0 : 0y00000 (0) +0x004 Type : 0y01110 (0xe) +0x004 Dpl : 0y00 +0x004 Present : 0y1 +0x006 OffsetMiddle : 0x1800 +0x008 OffsetHigh : 0xfffff805 +0x00c Reserved1 : 0 +0x000 Alignment : 0x18008e00`00101c00 Комбинация OffsetHigh, OffsetMiddle и OffsetLow даёт нам виртуальный адрес, куда процессор передаст поток выполнения, когда произойдёт прерывание. В выводе выше виртуальный адрес - 0xfffff80518001c00. Это совпадает с выводом “!idt 0” и указывает на фукнцию KiDivideErrorFault(). Значение поля Type в выводе выше (0xe) показывает, что поле в IDT представляет собой Interrupt Gate 0: kd&gt; !idt 0 Dumping IDT: fffff8051ae62000 00: fffff80518001c00 nt!KiDivideErrorFault Первые N элементов в IDT нужны для обработки исключений и определены разработчиком процессора. Остальные элементы или используются для программных прерываний, или для хардварных, или не используются вовсе. В выводе “!idt” хардварные прерывания очень просто определить: у них есть указатель на структуру KINTERRUPT. “!idt -a” показывает значения всей IDT 0: kd&gt; !idt -a Dumping IDT: fffff8051ae62000 00: fffff80518001c00 nt!KiDivideErrorFault 01: fffff80518001f40 nt!KiDebugTrapOrFault Stack = 0xFFFFF8051AEA0000 02: fffff80518002440 nt!KiNmiInterrupt Stack = 0xFFFFF8051AE92000 03: fffff80518002900 nt!KiBreakpointTrap 04: fffff80518002c40 nt!KiOverflowTrap 05: fffff80518002f80 nt!KiBoundFault 06: fffff805180034c0 nt!KiInvalidOpcodeFault 07: fffff805180039c0 nt!KiNpxNotAvailableFault 08: fffff80518003cc0 nt!KiDoubleFaultAbort Stack = 0xFFFFF8051AE8B000 09: fffff80518003fc0 nt!KiNpxSegmentOverrunAbort 0a: fffff805180042c0 nt!KiInvalidTssFault 0b: fffff805180045c0 nt!KiSegmentNotPresentFault 0c: fffff80518004980 nt!KiStackFault 0d: fffff80518004cc0 nt!KiGeneralProtectionFault 0e: fffff80518005000 nt!KiPageFault 0f: fffff80517ff99e8 nt!KiIsrThunk+0x78 10: fffff80518005640 nt!KiFloatingErrorFault 11: fffff80518005a00 nt!KiAlignmentFault 12: fffff80518005d40 nt!KiMcheckAbort Stack = 0xFFFFF8051AE99000 13: fffff80518006840 nt!KiXmmException 14: fffff80518006c00 nt!KiVirtualizationException 15: fffff80518007100 nt!KiControlProtectionFault 16: fffff80517ff9a20 nt!KiIsrThunk+0xB0 17: fffff80517ff9a28 nt!KiIsrThunk+0xB8 18: fffff80517ff9a30 nt!KiIsrThunk+0xC0 19: fffff80517ff9a38 nt!KiIsrThunk+0xC8 1a: fffff80517ff9a40 nt!KiIsrThunk+0xD0 1b: fffff80517ff9a48 nt!KiIsrThunk+0xD8 1c: fffff80517ff9a50 nt!KiIsrThunk+0xE0 1d: fffff80517ff9a58 nt!KiIsrThunk+0xE8 1e: fffff80517ff9a60 nt!KiIsrThunk+0xF0 1f: fffff80517ffb220 nt!KiApcInterrupt 20: fffff80517ffce00 nt!KiSwInterrupt В этой статье мы сфокусируемся на хардварных прерываниях, соответственно последние элементы IDT. hex значение в первой колонке - это вектор или индекс прерывания, по которому и находится конкретное прерывание в IDT. Как было сказано ранее, каждый элемент IDT указывает на набор инструкций, которые будут выполнены, как один из этапов обработки исключения. Давайте возьмём второй элемент в хардварной части IDR, вектор 0x50 0: kd&gt; !idt 50 Dumping IDT: fffff8051ae62000 50: fffff80517ff9bf0 dxgkrnl!DpiFdoLineInterruptRoutine (KINTERRUPT ffffb70107b9c500) Выведем IDT 0x50, используя IDTR 0: kd&gt; dt nt!_KIDTENTRY64 @idtr+0x50*0x10 +0x000 OffsetLow : 0x9bf0 +0x002 Selector : 0x10 +0x004 IstIndex : 0y000 +0x004 Reserved0 : 0y00000 (0) +0x004 Type : 0y01110 (0xe) +0x004 Dpl : 0y00 +0x004 Present : 0y1 +0x006 OffsetMiddle : 0x17ff +0x008 OffsetHigh : 0xfffff805 +0x00c Reserved1 : 0 +0x000 Alignment : 0x17ff8e00`00109bf0 0: kd&gt; dt @idtr + @@c++(0x50 * sizeof(nt!_KIDTENTRY64)) nt!_KIDTENTRY64 +0x000 OffsetLow : 0x9bf0 +0x002 Selector : 0x10 +0x004 IstIndex : 0y000 +0x004 Reserved0 : 0y00000 (0) +0x004 Type : 0y01110 (0xe) +0x004 Dpl : 0y00 +0x004 Present : 0y1 +0x006 OffsetMiddle : 0x17ff +0x008 OffsetHigh : 0xfffff805 +0x00c Reserved1 : 0 +0x000 Alignment : 0x17ff8e00`00109bf0 Когда появляется прерывание, исполнение кода передаётся в 0xfffff80517ff9bf0 Этот адрес указывает на исполняемую страницу памяти в NTOSKRNL и содержит следующие инструкции: 0: kd&gt; u 0xfffff80517ff9bf0 L3 nt!KiIsrThunk+0x280: fffff805`17ff9bf0 6a50 push 50h fffff805`17ff9bf2 55 push rbp fffff805`17ff9bf3 e989050000 jmp nt!KiIsrLinkage (fffff805`17ffa181) Переменная KiIsrThunk из NTOSKRNL указывает на ядреную страницу кода, которая содержит 256 темплейтов, похожих на инструкции выше. После push interrupt vector (0x50) в этом случае и содержимого RBP регистра на стек, KiIsrThunk заглушка передаёт управление KiIsrLinkage(). Это 2 элемента на стеке используются функцией KiIsrLinkage() через структуру KTRAP_FRAME. KiIsrLinkage() KiIsrLinkage() выполняет множество служебных задач: Сохраняет контекст изменяемого регистра в части KTRAP_FRAME, созданном в стеке Проверяет, выполнял ли во время прерывания процессор инструкции внтури конкретного региона функции ExpInterlockedPopEntrySList() и, если выполнял, он сбрасывает регистр RIP на допустимую инструкцию возобновления цикла в функции Проверяет, выключены ли прерывания и, если это так, багчекает систему на с кодом остановки TRAP_CAUSE_UNKNOWN Получает указатель на структуру прерывания, ассоциированную с прерыванием и обрабатывает прерывание Восстанавливает котекст изменяемого регистра из KTRAP_FRAME Возвращается из прерывания Интересно, что большинство частей функции KiIsrLinkage() созданы из макросов, многие из которых доступны в заголовочном файле WDK kxamd64.inc, например GENERATE_INTERRUPT_FRAME, ENTER_INTERRUPT, EXIT_INTERRUPT и RESTORE_TRAP_STATE KINTERRUPT Структура KINTERRUPT - основной ключ к обработке прерываний, она содержит всю информацию, необходимую для вызова ISR(interrupt service routine), зарегистрированной драйвером. KiIsrLinkage() определяет, где находится структура KINTERRUPT, связанная с вектором прерывания, используя его, как индекс в массиве указателей структур KINTERRUPT, находищихся в KPCR.CurrentPrcb.InterruptObject[]. Функция KiGetInterruptObjectAddress() из NTOSKRNL получает указатель на объект KINTERRUPT, показано ниже: 0: kd&gt; uf nt!KiGetInterruptObjectAddress nt!KiGetInterruptObjectAddress: fffff805`17f771d0 65488b142520000000 mov rdx,qword ptr gs:[20h] fffff805`17f771d9 4881c240310000 add rdx,3140h fffff805`17f771e0 8bc1 mov eax,ecx fffff805`17f771e2 488d04c2 lea rax,[rdx+rax*8] fffff805`17f771e6 c3 ret 0: kd&gt; !idt 50 Dumping IDT: fffff8051ae62000 50: fffff80517ff9bf0 dxgkrnl!DpiFdoLineInterruptRoutine (KINTERRUPT ffffb70107b9c500) 0: kd&gt; dt @$pcr nt!_KPCR -a Prcb.InterruptObject[50] +0x180 Prcb : +0x3140 InterruptObject : [80] 0xffffb701`07b9c500 Void 0: kd&gt; dt nt!_KINTERRUPT 0xffffb70107b9c500 +0x000 Type : 0n22 +0x002 Size : 0n288 +0x008 InterruptListEntry : _LIST_ENTRY [ 0x00000000`00000000 - 0x00000000`00000000 ] +0x018 ServiceRoutine : 0xfffff805`1b051e60 unsigned char dxgkrnl!DpiFdoLineInterruptRoutine+0 +0x020 MessageServiceRoutine : (null) +0x028 MessageIndex : 0 +0x030 ServiceContext : 0xffff990e`5377a030 Void +0x038 SpinLock : 0 +0x040 TickCount : 0 +0x048 ActualLock : 0xffff990e`530eea10 -&gt; 0 +0x050 DispatchAddress : 0xfffff805`17ff8c70 void nt!KiInterruptDispatch+0 +0x058 Vector : 0x50 +0x05c Irql : 0x5 &#39;&#39; +0x05d SynchronizeIrql : 0x5 &#39;&#39; +0x05e FloatingSave : 0 &#39;&#39; +0x05f Connected : 0x1 &#39;&#39; +0x060 Number : 0 +0x064 ShareVector : 0x1 &#39;&#39; +0x065 EmulateActiveBoth : 0 &#39;&#39; +0x066 ActiveCount : 0 +0x068 InternalState : 0n0 +0x06c Mode : 0 ( LevelSensitive ) +0x070 Polarity : 0 ( InterruptPolarityUnknown ) +0x074 ServiceCount : 0 +0x078 DispatchCount : 0 +0x080 PassiveEvent : (null) +0x088 TrapFrame : 0xfffff805`1ae6e520 _KTRAP_FRAME +0x090 DisconnectData : (null) +0x098 ServiceThread : (null) +0x0a0 ConnectionData : 0xffff990e`53931cc0 _INTERRUPT_CONNECTION_DATA +0x0a8 IntTrackEntry : 0xffff990e`532cc500 Void +0x0b0 IsrDpcStats : _ISRDPCSTATS +0x110 RedirectObject : (null) +0x118 PhysicalDeviceObject : 0xffff990e`50fc2360 Void Поля структуры KINTERRUPT, которые относятся к обработке прерываний: Название Описание DispatchAddress Указатель на начальный программный обработчик прерываний в NTOSKRNL (KiChainedDispatch() ) для общих прерываний и KiInterruptDispatch() для других ServiceRoutine Указатель на программный обработчик прерываний, зарегистрированный драйвером с помощью API ядра IoConnectInterrupt() или IoConnectInterruptEx() MessageServiceRoutine Используется только для MSI (message signaled interrupts - прерывания, инициируемые сообщениями), т.е. прерывания, которые доставляются путём записи в зарезервированные участи памяти вместо переключения аппаратных линий. Эти прерывания показываются, как отрицательные числа в device manager’e. Для таких прерываний ServiceRoutine указывает на ядерную функцию KiInterruptMessageDispatch(), которая вызывает ISR, связанную с драйвером в MessageServiceRoutine MessageIndex Индекс MSI, передаваемый, как параметр в ISR у MessageServiceRoutine В старых версиях Windows KINTERRUPT аллоцировалась из исполняемого невыгружаемого пула памяти, так как содержала начальный код обработки, который был зарегистрирован прямо в IDT. Из-за перехода к механизму из KiIsrThunk() и KiIsrLinkage(), описанному выше, начальная заглушка для прерывания теперь находится в исполняемой памяти в NTOSKRNL и, соответственно, структуре KINTERRUPT больше не нужно быть аллоцированной из исполняемой памяти. Структуры KINTERRUPT теперь пре-аллоцируются и хранятся в списке в KPCR.Prcb.InterruptObjectPool. Функция KeAllocateInterrupt() забирает пре-аллоцированную структуру KINTERRUPT из списка, когда вызывается для аллокации новой структуры KINTERRUPT. Когда этот список заканчивается, алооцируется ещё одна страница со структурами с помощью MmAllocateIndependentPages(), и добалвяет их в список. Interrupt Dispatching Одним из важных шагов, предпринятых KiIsrLinkage, является вызов функции в KINTERRUPT.DispatchAddress, что приводит к вызову либо KiInterruptDispatch(), либо KiChainedDispatch(). Обе эти функции вызываются с указателем на структуру KINTERRUPT, как будто у них есть доступ ко всей информации, относящейся к обработке прерывания. Новые системы используют APIC (Advanced Programmable Interrupt Controller) для обработки прерываний с устройств. Устройства отправляют свои прерывания на процессор с помощью IRQ линий. Однако, устройств больше, чем IRQ линий. Общие прерывания убирают проблему позволяя использовать одни и те же IRQ линии множеству устройств. Когда IRQ шарится, множество драйверов регистрирует свои ISR’ы для одного и того же IRQ и вектора прерывания. Из этого вытекает множественная структура KINTERRUPT, соответствующая устройствам, которые делят прерывание, и на них ссылаются вместе с помощью их полей KINTERRUPT.InterruptListEntry. Увидеть это можно с помощью “!idt -a”, когда одному вектору прерывания соответствует множество структур KINTERRUPT, связанных с ним. KiChainedDispatch() обрабатывает прерывания, которые шарятся с множеством устройств, а KiInterruptDispatch() обрабатывает остальные прерывания. Функции KiInterruptDispatch() и KiChainedDispatch меняются в зависимости от стека прерывания процессора, указатель на который хранится в KPCR.Prb.IsrStack. Этот стек аллоцируется функцией MmAllocateIsrStack(). Размер ISR стека 0x7000 байт, как определено переменными ISR_STACK_SIZE и PAGE_SIZE в заголовочном файле ksamd64.inc WDK. Непосредственный переход на стек ISR происходит с помощью макроса SWITCH_TO_ISR_STACK и также доступен в ksamd64.inc. Как только выполнение перешло на стек ISR, функции KiInterruptDispatch() и KiChainedDispatch() передают выполнение следующей стадии, вызывая KiInterruptSubDispatch() или KiScanInterruptObjectList() соответственно. KiInterruptSubDispatch() вызывает KiCallInterruptServiceRoutine() для одиночной структуры KINTERRUPT. KiScanInterruptObjectList() итерируется по всем объектам KINTERRUPT, зарегистрированным для одного вектора прерывания, используя список KINTERRUPT.InterruptListEntry и вызывает KiCallInterruptServiceRoutine() для каждого KINTERRUPT в цепочке. KiCallInterruptServiceRoutine() выполняет следующие задачи: Помечает прерывание, как активное в KINTERRUPT.IsrDpcStats.IsrActive Записывает время начала ISR в KINTERRUPT.IsrDpcStats.IsrTimeStart Получает спин-блокировку прерывания в KINTERRUPT.ActualLock Вызывает драйвер, зарегистрированный ISR в KINTERRUPT.ServiceRoutine Записывает длительность ISR в KINTERRUPT.IsrDpcStats.IsrTime Если ISR была прервана другой ISR с большим уровнем IRQL, он подстраивает IsrTime для точного учёта времени Помечает прерывание как неактивное в KINTERRUPT.IsrDpcStats.IsrActive Инкрементирует счётчик экземпляров прерываний в IsrCount Драйвер, который регистрировал ISR, может сообщить вызывающей функции KiCallInterruptServiceRoutine(), забрал ли он на обработку прерывание, вернув TRUE. Это становится важным в случае пошареных прерываний, где решение вызвать ISR в следующем KINTERRUPT в цепочке или нет зависит от того, забрал ли текущий ISR прерывание на обработку. Следующая диаграмма показывает все структуры, описанные выше и отношения между ними. Как и в предыдущих версиях Windows 64, и IDTR, и содержимое IDT защищено PatchGuard (kernel patch protection). Делая структуру KINTERRUPT неисполняемой и удаляю код обработки из структуры, мы закрываем ещё один вектор subversion. Однако, даже с этими новыми изменениями в обработке исключений всё равно возможно для драйвера ядра хукнуть ISR в системе для реализации своего функционала, например для кейлоггера. ISR драйвера в поле KINTERRUPT.ServiceRoutine может быть заменено указателем на хук-функцию и PatchGuard этого не заметит. Так же не заметит, если KINTERRUPT, хранящийся в KPCR.Prcb.InterruptObject[] будет заменён клонированной структурой KINTERRUPT, который будет вести к выполнению кода. IDT - Interrupt Descriptor Table (таблица дескрипторов прерываний) Там хранятся элементы _KIDENTRY или _KIDENTRY64 соответственно В каждой из них есть ссылка на ISR (Interrupt Service Routine) - непостредственно функция, которая вызывается Вторая статья и практика-практика-практика Механизм прерываний - ещё один важный элемент уровня железа Прерывания можно рассматривать, как события уровня железа, использующиеся для сигнализирования процессору, что что-то требует немедленного внимания Прерывания устройств Устройства (сетевая карта, клавиатура и тд) вызовут прерывание, чтобы сигнализировать процессору, что у них есть новая информация для обработки (входящий сетевой пакет, нажатие на клавишу и тд) Ловушки / исключения Эти вещи обычно происходят, когда процессор сталкивается с ошибкой, такой как деление на ноль или ошибка страницы Программные прерывания Это такие прерывания, которые генерируются программами, например INT 2E (syscall) используется для перехода из user mode в kernel mode. INT 3 используется для генерации программного брейкпоинта и тд Значение, которое идёт за инструкцией INT называется вектором прерывания, это просто индекс в IDT (Interrupt Descriptor Table). IDT ассоциирует вектор прерывания с конкретной функцией, которая будет обрабатывать вызванное прерывание. В WDK (Windows Driver Kit) такая функция называется ISR (Interrupt Service Routine) С точки зрения железа прерывания обрабатываются конкретным куском железа, называемым PIC (Programmable Interrupt Controller - контроллер прерываний). Сейчас у нас обычно стоит новая версия PIC - APIC (Advanced Programmable Interrupt Controller), встроенная прямо в процессов Плюсы APIC: Поддержка многопроцессорности Больше линий прерываний (256 vs 15 для PIC) Для каждого CPU свой APIC, и каждый APIC может коммуницировать с другими APIC’ами через IPI (Inter-processor interrupt message) Одна большая задача в обработке прерываний, которую выполняет APIC - это управление приоритетами прерываний. Каждой линии прерываний выдан свой приоритет и APIC проверяет, что ни один входящий запрос на прерывание с приоритетом ниже или равным текущему обрабатываемому прерыванию не достигнет процессор, обычно это называют Interrupt Masking Заметьте, что некоторые особые прерывания не могут был замаскированы и всегда будут достигать процессор, они называются NMI (Non-maskable interrupt). Они обычно предназначены для неустранимого сбоя оборудования, что означает, что у вас серьёзные проблемы с железом. Прерывания, приходящие от устройств, сначала обрабатываются I/O APIC, специальным чипом, встроенным в чипсет, его роль - распределять прерывания по локальным APIC’ам всех CPU, таким образом включая SMP (Symmetric multiprocessing - Симметричная многопроцессорность) Когда прерывание достигает CPU, процессор и процедура прерывания ОС сохранят стостояние значения регистров в стеке ядра, чтобы можно было восстановить предыдущий поток выполнения и продолжить исполнение кода. Этот набор сохраняемых регистров и некотороая дополнителья информация (например код ошибки) обычно называются Trap Frame (.trap в windbg) Углубимся немного в механизм обработки прерываний. Откуда процессор знает, где расположения IDT? Ответ - в регистре IDTR. 48-битный регистр делится на две части: 16-бит - IDT limit и 32-бита - base address Максимальное количество записей в IDT - 256. Каждая запись - 8 бит, содержит флаги, сегментные селекторы, gate type и оффсет или адрес ISR. Оффсет тоже разделён на две части: биты 0..15 - для младших битив и 48..63 - для старших битов В винде IDT entry - это _KIDTENTRY kd&gt; dt nt!_KIDTENTRY +0x000 Offset : Uint2B +0x002 Selector : Uint2B +0x004 Access : Uint2B +0x006 ExtendedOffset : Uint2B Чтобы отобразить IDT в windbg есть !idt kd&gt; !idt Dumping IDT: 8003f400 30: 806f5d50 hal!HalpClockInterrupt 31: 89ec9044 i8042prt!I8042KeyboardInterruptService (KINTERRUPT 89ec9008) 38: 806efef0 hal!HalpProfileInterrupt 39: 89fed174 ACPI!ACPIInterruptServiceRoutine (KINTERRUPT 89fed138) NDIS!ndisMIsr (KINTERRUPT 89f228d8) 3a: 89f24044 VIDEOPRT!pVideoPortInterrupt (KINTERRUPT 89f24008) USBPORT!USBPORT_InterruptService (KINTERRUPT 89eae008) 3b: 8a01d6c4 VBoxGuest+0x27c0 (KINTERRUPT 8a01d688) portcls!CKsShellRequestor::`scalar deleting destructor&#39;+0x26 (KINTERRUPT 89f179c0) 3c: 89ead564 i8042prt!I8042MouseInterruptService (KINTERRUPT 89ead528) 3e: 89fea9d4 atapi!IdePortInterrupt (KINTERRUPT 89fea998) 3f: 8a03d044 atapi!IdePortInterrupt (KINTERRUPT 8a03d008) Например разберём поближе i8042prt!I8042KeyboardInterruptService Для проверки, что это такое вообще (ну вдруг мы по названию не догадались) поставим бряку на него kd&gt; u i8042prt!I8042KeyboardInterruptService i8042prt!I8042KeyboardInterruptService: f76a7495 6a18 push 18h f76a7497 68a8a76af7 push offset i8042prt!`string&#39;+0x154 (f76aa7a8) f76a749c e8fa000000 call i8042prt!_SEH_prolog (f76a759b) f76a74a1 8b7d0c mov edi,dword ptr [ebp+0Ch] f76a74a4 8b7728 mov esi,dword ptr [edi+28h] f76a74a7 837e3001 cmp dword ptr [esi+30h],1 f76a74ab 0f8582130000 jne i8042prt!I8042KeyboardInterruptService+0xa2 (f76a8833) f76a74b1 a100a96af7 mov eax,dword ptr [i8042prt!Globals (f76aa900)] kd&gt; bu i8042prt!I8042KeyboardInterruptService kd&gt; bl 0 e Disable Clear f76a7495 0001 (0001) i8042prt!I8042KeyboardInterruptService kd&gt; g Breakpoint 0 hit i8042prt!I8042KeyboardInterruptService: f76a7495 6a18 push 18h Мы нажали на любую кнопку –&gt; наш брейкпоинт сработал Но давайте доберёмся до кода в статике, ведь то, что написано в выводе команды !idt (31: 89ec9044 i8042prt! …) не совпадает с фактическим адресом ISR Каждый элемент IDT занимает 8 байт, мы решили, что нам нужен индекс 31 (такой индекс у нужной нам функции), что нам нужно сделать? idtr + 0x31 * 8 –&gt; kd&gt; r idtr idtr=8003f400 kd&gt; dd @idtr+8*0x31 8003f588 - 00089044 89ec8e00 0008dd14 804d8e00 --&gt; 0x89ec9044 8003f598 - 0008dd1e 804d8e00 0008dd28 804d8e00 8003f5a8 - 0008dd32 804d8e00 0008dd3c 804d8e00 8003f5b8 - 0008dd46 804d8e00 0008fef0 806e8e00 8003f5c8 - 0008d174 89fe8e00 00084044 89f28e00 8003f5d8 - 0008d6c4 8a018e00 0008d564 89ea8e00 8003f5e8 - 0008dd82 804d8e00 0008a9d4 89fe8e00 8003f5f8 - 0008d044 8a038e00 0008dda0 804d8e00 И так наш ISR адрес 0x89ec9044, но мы же вроде бы только что дампили I8042KeyboardInterruptService и его адрес был 0xf76a7495, непонятно Чтож, перед тем, как вызывать ISR’ры драйверов системе нужно выполнить некоторые задачи: маскирование прерываний с более низким приоритетом в APIC, поднятие уровня IRQL и тд Так что вместо того, чтобы заполнить IDT ISR’ами, система заполняет их glue кодом или же иначе функциями-темплейтами Каждая темплейт-функция взята (скопирована) из KiInterruptTemplate функции и динамически модифицирована, чтобы подходить соответствующему ISR’у Давайте посмотрим на темплейт нашей KeyboardInterruptService: Мы можем заметить, что почти весь код скопирован с оригинального KiInterruptTemplate. Однако есть одна интересная особенность: темплейт функции клавиатуры вызывает KiInterruptDispatch и кладёт в EDI адрес 0x89EC9008 Этот адрес указывает на interrupt object с типом _KINTERRUPT: kd&gt; dt nt!_KINTERRUPT 0x89EC9008 +0x000 Type : 0n22 +0x002 Size : 0n484 +0x004 InterruptListEntry : _LIST_ENTRY [ 0x89ec900c - 0x89ec900c ] +0x00c ServiceRoutine : 0xf76a7495 unsigned char i8042prt!I8042KeyboardInterruptService+0 +0x010 ServiceContext : 0x89f259d0 Void +0x014 SpinLock : 0 +0x018 TickCount : 0xffffffff +0x01c ActualLock : 0x89f25a90 -&gt; 0 +0x020 DispatchAddress : 0x804da8e8 void nt!KiInterruptDispatch+0 +0x024 Vector : 0x31 +0x028 Irql : 0x1a &#39;&#39; +0x029 SynchronizeIrql : 0x1a &#39;&#39; +0x02a FloatingSave : 0 &#39;&#39; +0x02b Connected : 0x1 &#39;&#39; +0x02c Number : 0 &#39;&#39; +0x02d ShareVector : 0 &#39;&#39; +0x030 Mode : 1 ( Latched ) +0x034 ServiceCount : 0 +0x038 DispatchCount : 0xffffffff +0x03c DispatchCode : [106] 0x56535554 Как видно выше, как раз в ServiceRoutine хранится адрес ISR Если мы теперь посмотрим на KiInterruptDispatch мы увидим, что он вызывает interrupt object ServiceRoutine kd&gt; u nt!KiInterruptDispatch L30 nt!KiInterruptDispatch: 804da8e8 ff05c4f5dfff inc dword ptr ds:[0FFDFF5C4h] 804da8ee 8bec mov ebp,esp 804da8f0 8b4724 mov eax,dword ptr [edi+24h] 804da8f3 8b4f29 mov ecx,dword ptr [edi+29h] 804da8f6 50 push eax 804da8f7 83ec04 sub esp,4 804da8fa 54 push esp 804da8fb 50 push eax 804da8fc 51 push ecx 804da8fd ff1504764d80 call dword ptr [nt!_imp__HalBeginSystemInterrupt (804d7604)] 804da903 0bc0 or eax,eax 804da905 7436 je nt!KiInterruptDispatch+0x55 (804da93d) 804da907 83ec0c sub esp,0Ch 804da90a 833d0c23568000 cmp dword ptr [nt!PPerfGlobalGroupMask (8056230c)],0 804da911 c745f400000000 mov dword ptr [ebp-0Ch],0 804da918 752b jne nt!KiInterruptDispatch+0x5d (804da945) 804da91a 8b771c mov esi,dword ptr [edi+1Ch] 804da91d 8b4710 mov eax,dword ptr [edi+10h] 804da920 50 push eax 804da921 57 push edi 804da922 ff570c call dword ptr [edi+0Ch] kd&gt; dt nt!_KINTERRUPT 0x89EC9008 ... +0x00c ServiceRoutine : 0xf76a7495 unsigned char i8042prt!I8042KeyboardInterruptService+0 ... Вся структура вызовов: И как создаётся interrupt object? Это роль драйвера заполнить структуру, вызвав IoConnectInterrupt Добавим ещё немного экспериментов: Давайте посмотрим на прерывание и исключение деления на ноль Оно у нас самое первое в таблице IDT kd&gt; !idt -a Dumping IDT: 8003f400 00: 804df370 nt!KiTrap00 01: 804df4eb nt!KiTrap01 02: Task Selector = 0x0000 03: 804df8bd nt!KiTrap03 04: 804dfa40 nt!KiTrap04 05: 804dfba1 nt!KiTrap05 06: 804dfd22 nt!KiTrap06 07: 804e038a nt!KiTrap07 Поставим бряку bu nt!KiTrap00 И на машине скомпилим какой-нибудь такой код: #include &lt;stdio.h&gt; #include &lt;Windows.h&gt; int main() { sleep(5); printf(&quot;Go!\n&quot;); int x = 10; int y; scanf(&quot;%f&quot;, &amp;y); printf(&quot;%f&quot;, x / y); return 0; } Вводим ноль и Viola! брякаемся kd&gt; !process 0 0 Failed to get VadRoot PROCESS 897cf578 SessionId: 0 Cid: 06ac Peb: 7ffdc000 ParentCid: 0e48 DirBase: 825e9000 ObjectTable: e2c24c78 HandleCount: 7. Image: Untitled1.exe kd&gt; .process /i 897cf578 You need to continue execution (press &#39;g&#39; &lt;enter&gt;) for the context to be switched. When the debugger breaks in again, you will be in the new process context. ReadVirtual: 8a01c688 not properly sign extended kd&gt; g Break instruction exception - code 80000003 (first chance) nt!RtlpBreakWithStatusInstruction: 804e351a cc int 3 ReadVirtual: 8a01c688 not properly sign extended 00401500 55 push ebp 00401501 89e5 mov ebp,esp 00401503 83e4f0 and esp,0FFFFFFF0h 00401506 83ec20 sub esp,20h 00401509 e8b2090000 call 00401ec0 0040150e c7042405000000 mov dword ptr [esp],5 00401515 e8b6100000 call 004025d0 0040151a c7042400404000 mov dword ptr [esp],404000h 00401521 e832110000 call 00402658 &lt;-- printf(&quot;Go!\n&quot;) 00401526 c744241c0a000000 mov dword ptr [esp+1Ch],0Ah 0040152e 8d442418 lea eax,[esp+18h] 00401532 89442404 mov dword ptr [esp+4],eax 00401536 c7042404404000 mov dword ptr [esp],404004h 0040153d e81e110000 call 00402660 &lt;-- scanf 00401542 8bd9 mov ebx,ecx 00401544 2418 and al,18h 00401546 8b44241c mov eax,dword ptr [esp+1Ch] 0040154a 99 cdq 0040154b f7f9 idiv eax,ecx 0040154d 89442404 mov dword ptr [esp+4],eax 00401551 c7042404404000 mov dword ptr [esp],404004h 00401558 e80b110000 call 00402668 0040155d b800000000 mov eax,0 00401562 c9 leave Падаем в обработку ... 804df3ea 55 push ebp 804df3eb e8b6431400 call nt!Ki386CheckDivideByZeroTrap (806237a6) ... Посмотрим на 64-битную 10-ку Тут всё выглядит поинтереснее, мб из-за отсутствия дебаг символом на XP’хе, а мб и нет kd&gt; !idt Dumping IDT: fffff80335462000 00: fffff80330a01c00 nt!KiDivideErrorFault 01: fffff80330a01f40 nt!KiDebugTrapOrFault Stack = 0xFFFFF803354A0000 02: fffff80330a02440 nt!KiNmiInterrupt Stack = 0xFFFFF80335492000 03: fffff80330a02900 nt!KiBreakpointTrap 04: fffff80330a02c40 nt!KiOverflowTrap 05: fffff80330a02f80 nt!KiBoundFault 06: fffff80330a034c0 nt!KiInvalidOpcodeFault 07: fffff80330a039c0 nt!KiNpxNotAvailableFault 08: fffff80330a03cc0 nt!KiDoubleFaultAbort Stack = 0xFFFFF8033548B000 09: fffff80330a03fc0 nt!KiNpxSegmentOverrunAbort 0a: fffff80330a042c0 nt!KiInvalidTssFault 0b: fffff80330a045c0 nt!KiSegmentNotPresentFault 0c: fffff80330a04980 nt!KiStackFault 0d: fffff80330a04cc0 nt!KiGeneralProtectionFault 0e: fffff80330a05000 nt!KiPageFault 10: fffff80330a05640 nt!KiFloatingErrorFault 11: fffff80330a05a00 nt!KiAlignmentFault 12: fffff80330a05d40 nt!KiMcheckAbort Stack = 0xFFFFF80335499000 13: fffff80330a06840 nt!KiXmmException 14: fffff80330a06c00 nt!KiVirtualizationException 15: fffff80330a07100 nt!KiControlProtectionFault 1f: fffff803309fb220 nt!KiApcInterrupt 20: fffff803309fce00 nt!KiSwInterrupt 29: fffff80330a07600 nt!KiRaiseSecurityCheckFailure 2c: fffff80330a07940 nt!KiRaiseAssertion 2d: fffff80330a07c80 nt!KiDebugServiceTrap 2f: fffff803309fd3c0 nt!KiDpcInterrupt 30: fffff803309fb7c0 nt!KiHvInterrupt 31: fffff803309fbaa0 nt!KiVmbusInterrupt0 32: fffff803309fbd80 nt!KiVmbusInterrupt1 33: fffff803309fc060 nt!KiVmbusInterrupt2 34: fffff803309fc340 nt!KiVmbusInterrupt3 35: fffff803309f9b18 nt!HalpInterruptCmciService (KINTERRUPT fffff803312f2f40) 36: fffff803309f9b20 nt!HalpInterruptCmciService (KINTERRUPT fffff803312f3180) 50: fffff803309f9bf0 dxgkrnl!DpiFdoLineInterruptRoutine (KINTERRUPT ffffa600bf1fb500) 60: fffff803309f9c70 USBPORT!USBPORT_InterruptService (KINTERRUPT ffffa600bf1fb780) 70: fffff803309f9cf0 VBoxGuest+0x22e0 (KINTERRUPT ffffa600bf1fbb40) 80: fffff803309f9d70 storport!RaidpAdapterInterruptRoutine (KINTERRUPT ffffa600bf1fbc80) HDAudBus!HdaController::Isr (KINTERRUPT ffffa600bf1fb640) 90: fffff803309f9df0 i8042prt!I8042MouseInterruptService (KINTERRUPT ffffa600bf1fb8c0) a0: fffff803309f9e70 i8042prt!I8042KeyboardInterruptService (KINTERRUPT ffffa600bf1fba00) b0: fffff803309f9ef0 ACPI!ACPIInterruptServiceRoutine (KINTERRUPT ffffa600bf1fbdc0) ce: fffff803309f9fe0 nt!HalpIommuInterruptRoutine (KINTERRUPT fffff803312f3ba0) d1: fffff803309f9ff8 nt!HalpTimerClockInterrupt (KINTERRUPT fffff803312f3960) d2: fffff803309fa000 nt!HalpTimerClockIpiRoutine (KINTERRUPT fffff803312f3840) d7: fffff803309fa028 nt!HalpInterruptRebootService (KINTERRUPT fffff803312f3600) d8: fffff803309fa030 nt!HalpInterruptStubService (KINTERRUPT fffff803312f33c0) df: fffff803309fa068 nt!HalpInterruptSpuriousService (KINTERRUPT fffff803312f32a0) e1: fffff803309fd8b0 nt!KiIpiInterrupt e2: fffff803309fa080 nt!HalpInterruptLocalErrorService (KINTERRUPT fffff803312f34e0) e3: fffff803309fa088 nt!HalpInterruptDeferredRecoveryService (KINTERRUPT fffff803312f3060) fd: fffff803309fa158 nt!HalpTimerProfileInterrupt (KINTERRUPT fffff803312f3a80) fe: fffff803309fa160 nt!HalpPerfInterrupt (KINTERRUPT fffff803312f3720) Возьмём снова наш обработчик клавиатуры по оффсету a0 kd&gt; dt _kidtentry64 (idtr + (0xa0*0x10)) ntdll!_KIDTENTRY64 +0x000 OffsetLow : 0x9e70 +0x002 Selector : 0x10 +0x004 IstIndex : 0y000 +0x004 Reserved0 : 0y00000 (0) +0x004 Type : 0y01110 (0xe) +0x004 Dpl : 0y00 +0x004 Present : 0y1 +0x006 OffsetMiddle : 0x309f +0x008 OffsetHigh : 0xfffff803 +0x00c Reserved1 : 0 +0x000 Alignment : 0x309f8e00`00109e70 Найдём ISR entry point для него, теперь для 64 бит схема немного другая: OffsetHigh + OffsetMiddle + OffsetLow 0xfffff803309f9e70 Offset: 0xfffff803309f9e70 fffff803`309f9e70 6aa0 push 0FFFFFFFFFFFFFFA0h fffff803`309f9e72 55 push rbp fffff803`309f9e73 e909030000 jmp nt!KiIsrLinkage (fffff803`309fa181) Если в табличке !idt искать KINTERRUPT не хочется, можно сделать так: kd&gt; dt @$pcr nt!_KPCR -a Prcb.InterruptObject[0xa0] +0x180 Prcb : +0x3140 InterruptObject : [160] 0xffffa600`bf1fba00 Void kd&gt; dt nt!_KINTERRUPT ffffa600bf1fba00 +0x000 Type : 0n22 +0x002 Size : 0n288 +0x008 InterruptListEntry : _LIST_ENTRY [ 0x00000000`00000000 - 0x00000000`00000000 ] +0x018 ServiceRoutine : 0xfffff803`36096790 unsigned char i8042prt!I8042KeyboardInterruptService+0 +0x020 MessageServiceRoutine : (null) +0x028 MessageIndex : 0 +0x030 ServiceContext : 0xffffcf8b`4e304040 Void +0x038 SpinLock : 0 +0x040 TickCount : 0 +0x048 ActualLock : 0xffffcf8b`4e3041a0 -&gt; 0 +0x050 DispatchAddress : 0xfffff803`309f8c70 void nt!KiInterruptDispatch+0 +0x058 Vector : 0xa0 +0x05c Irql : 0xa &#39;&#39; +0x05d SynchronizeIrql : 0xa &#39;&#39; +0x05e FloatingSave : 0 &#39;&#39; +0x05f Connected : 0x1 &#39;&#39; +0x060 Number : 0 +0x064 ShareVector : 0 &#39;&#39; +0x065 EmulateActiveBoth : 0 &#39;&#39; +0x066 ActiveCount : 0 +0x068 InternalState : 0n0 +0x06c Mode : 1 ( Latched ) +0x070 Polarity : 0 ( InterruptPolarityUnknown ) +0x074 ServiceCount : 0 +0x078 DispatchCount : 0 +0x080 PassiveEvent : (null) +0x088 TrapFrame : 0xfffffb82`3ab14a20 _KTRAP_FRAME +0x090 DisconnectData : (null) +0x098 ServiceThread : (null) +0x0a0 ConnectionData : 0xffffcf8b`4e467d00 _INTERRUPT_CONNECTION_DATA +0x0a8 IntTrackEntry : 0xffffcf8b`4ccac690 Void +0x0b0 IsrDpcStats : _ISRDPCSTATS +0x110 RedirectObject : (null) +0x118 PhysicalDeviceObject : (null) напочитать: Ориг статья с экспериментами https://www.ired.team/miscellaneous-reversing-forensics/windows-kernel-internals/interrupt-descriptor-table-idt https://vivek-arora.com/?p=801 https://www.ired.team/miscellaneous-reversing-forensics/windows-kernel-internals/glimpse-into-ssdt-in-windows-x64-kernel https://codemachine.com/articles/interrupt_dispatching.html" />
<meta property="og:description" content="Тут будет перевод одной статейки для погружения в теорию: статейка Interrupt Dispatching Internals Microsoft изменили способ обработки прерываний в последних версиях Windows. Были опубликованы некоторые публичные ресёрчи по обработке прерываний на старых версиях Windows и на 32-битных системах, однако не так много информации можно найти о том, как это работает в современном мире. В этой статье я попытаюсь привести описание обработки исключений на 64-битной Windows 10, в особенности Windows 10 RS1 Anniversary Update Build 10.0.10586 Прерывания используются операционными системами, чтобы получать сообщения об ивентах, происходящих на оборудовании. Обработка исключений - это механизм, в котором процессор передаёт контроль исполнения программному обеспечению, чтобы обработать событие на оборудовании. Прерывания обрабатываются ядром Windows, которое сначала выполняет некоторые служебные действия перед передачей контроля исполнения драйверам железа, которые в свою очередь регистрируют ISR (функции обработчика прерывания). IDT (Interrupt Descriptor Table) - это основная структура, задействованная в обработке исключений и её формат устанавливает разработчик процессора. IDT должна быть заполнена на этапе загрузки и соответственно должна использоваться процессором для обработки прерываний, приходящих с устройств IDTR Register У процессоров есть встроенный регистр, называемый IDTR, который Windows заполняет виртуальным адресом IDT в ядре, который он устанавливает для каждого процессора на этапе загрузки. Значение регистра IDTR для каждого процессора. На мульти процессорной системе каждый процессор имеет свой IDTR регистр, который указывает на локальную приватную копию IDT 0: kd&gt; ~0 0: kd&gt; r @idtr idtr=fffff8051ae62000 0: kd&gt; ~1 1: kd&gt; r @idtr idtr=ffffb70107dad000 1: kd&gt; ~2 2: kd&gt; r @idtr idtr=ffffb701077ea000 Interrupt Descriptor Table IDT содержит всего 256 значений, некоторые из которых используются для исключений, некоторые для программных прерываний, а остальные для прерываний железа. Индекс в IDT, по которому выбирают конкретный элемент, называется вектором прерывания. Формат каждого элемента IDT описывается разработчиком процессора. Ядро Windows определяет структуру KIDTENTRY64, которая представляет собой один элемент IDT на 64-битном процессоре. Используя вывод предыдущей команды “r @idtr”, мы можем вывести нулевой элемент IDT, на который указывает IDTR 0: kd&gt; ~0 0: kd&gt; r @idtr idtr=fffff8051ae62000 0: kd&gt; dt nt!_KIDTENTRY64 fffff8051ae62000 +0x000 OffsetLow : 0x1c00 +0x002 Selector : 0x10 +0x004 IstIndex : 0y000 +0x004 Reserved0 : 0y00000 (0) +0x004 Type : 0y01110 (0xe) +0x004 Dpl : 0y00 +0x004 Present : 0y1 +0x006 OffsetMiddle : 0x1800 +0x008 OffsetHigh : 0xfffff805 +0x00c Reserved1 : 0 +0x000 Alignment : 0x18008e00`00101c00 Комбинация OffsetHigh, OffsetMiddle и OffsetLow даёт нам виртуальный адрес, куда процессор передаст поток выполнения, когда произойдёт прерывание. В выводе выше виртуальный адрес - 0xfffff80518001c00. Это совпадает с выводом “!idt 0” и указывает на фукнцию KiDivideErrorFault(). Значение поля Type в выводе выше (0xe) показывает, что поле в IDT представляет собой Interrupt Gate 0: kd&gt; !idt 0 Dumping IDT: fffff8051ae62000 00: fffff80518001c00 nt!KiDivideErrorFault Первые N элементов в IDT нужны для обработки исключений и определены разработчиком процессора. Остальные элементы или используются для программных прерываний, или для хардварных, или не используются вовсе. В выводе “!idt” хардварные прерывания очень просто определить: у них есть указатель на структуру KINTERRUPT. “!idt -a” показывает значения всей IDT 0: kd&gt; !idt -a Dumping IDT: fffff8051ae62000 00: fffff80518001c00 nt!KiDivideErrorFault 01: fffff80518001f40 nt!KiDebugTrapOrFault Stack = 0xFFFFF8051AEA0000 02: fffff80518002440 nt!KiNmiInterrupt Stack = 0xFFFFF8051AE92000 03: fffff80518002900 nt!KiBreakpointTrap 04: fffff80518002c40 nt!KiOverflowTrap 05: fffff80518002f80 nt!KiBoundFault 06: fffff805180034c0 nt!KiInvalidOpcodeFault 07: fffff805180039c0 nt!KiNpxNotAvailableFault 08: fffff80518003cc0 nt!KiDoubleFaultAbort Stack = 0xFFFFF8051AE8B000 09: fffff80518003fc0 nt!KiNpxSegmentOverrunAbort 0a: fffff805180042c0 nt!KiInvalidTssFault 0b: fffff805180045c0 nt!KiSegmentNotPresentFault 0c: fffff80518004980 nt!KiStackFault 0d: fffff80518004cc0 nt!KiGeneralProtectionFault 0e: fffff80518005000 nt!KiPageFault 0f: fffff80517ff99e8 nt!KiIsrThunk+0x78 10: fffff80518005640 nt!KiFloatingErrorFault 11: fffff80518005a00 nt!KiAlignmentFault 12: fffff80518005d40 nt!KiMcheckAbort Stack = 0xFFFFF8051AE99000 13: fffff80518006840 nt!KiXmmException 14: fffff80518006c00 nt!KiVirtualizationException 15: fffff80518007100 nt!KiControlProtectionFault 16: fffff80517ff9a20 nt!KiIsrThunk+0xB0 17: fffff80517ff9a28 nt!KiIsrThunk+0xB8 18: fffff80517ff9a30 nt!KiIsrThunk+0xC0 19: fffff80517ff9a38 nt!KiIsrThunk+0xC8 1a: fffff80517ff9a40 nt!KiIsrThunk+0xD0 1b: fffff80517ff9a48 nt!KiIsrThunk+0xD8 1c: fffff80517ff9a50 nt!KiIsrThunk+0xE0 1d: fffff80517ff9a58 nt!KiIsrThunk+0xE8 1e: fffff80517ff9a60 nt!KiIsrThunk+0xF0 1f: fffff80517ffb220 nt!KiApcInterrupt 20: fffff80517ffce00 nt!KiSwInterrupt В этой статье мы сфокусируемся на хардварных прерываниях, соответственно последние элементы IDT. hex значение в первой колонке - это вектор или индекс прерывания, по которому и находится конкретное прерывание в IDT. Как было сказано ранее, каждый элемент IDT указывает на набор инструкций, которые будут выполнены, как один из этапов обработки исключения. Давайте возьмём второй элемент в хардварной части IDR, вектор 0x50 0: kd&gt; !idt 50 Dumping IDT: fffff8051ae62000 50: fffff80517ff9bf0 dxgkrnl!DpiFdoLineInterruptRoutine (KINTERRUPT ffffb70107b9c500) Выведем IDT 0x50, используя IDTR 0: kd&gt; dt nt!_KIDTENTRY64 @idtr+0x50*0x10 +0x000 OffsetLow : 0x9bf0 +0x002 Selector : 0x10 +0x004 IstIndex : 0y000 +0x004 Reserved0 : 0y00000 (0) +0x004 Type : 0y01110 (0xe) +0x004 Dpl : 0y00 +0x004 Present : 0y1 +0x006 OffsetMiddle : 0x17ff +0x008 OffsetHigh : 0xfffff805 +0x00c Reserved1 : 0 +0x000 Alignment : 0x17ff8e00`00109bf0 0: kd&gt; dt @idtr + @@c++(0x50 * sizeof(nt!_KIDTENTRY64)) nt!_KIDTENTRY64 +0x000 OffsetLow : 0x9bf0 +0x002 Selector : 0x10 +0x004 IstIndex : 0y000 +0x004 Reserved0 : 0y00000 (0) +0x004 Type : 0y01110 (0xe) +0x004 Dpl : 0y00 +0x004 Present : 0y1 +0x006 OffsetMiddle : 0x17ff +0x008 OffsetHigh : 0xfffff805 +0x00c Reserved1 : 0 +0x000 Alignment : 0x17ff8e00`00109bf0 Когда появляется прерывание, исполнение кода передаётся в 0xfffff80517ff9bf0 Этот адрес указывает на исполняемую страницу памяти в NTOSKRNL и содержит следующие инструкции: 0: kd&gt; u 0xfffff80517ff9bf0 L3 nt!KiIsrThunk+0x280: fffff805`17ff9bf0 6a50 push 50h fffff805`17ff9bf2 55 push rbp fffff805`17ff9bf3 e989050000 jmp nt!KiIsrLinkage (fffff805`17ffa181) Переменная KiIsrThunk из NTOSKRNL указывает на ядреную страницу кода, которая содержит 256 темплейтов, похожих на инструкции выше. После push interrupt vector (0x50) в этом случае и содержимого RBP регистра на стек, KiIsrThunk заглушка передаёт управление KiIsrLinkage(). Это 2 элемента на стеке используются функцией KiIsrLinkage() через структуру KTRAP_FRAME. KiIsrLinkage() KiIsrLinkage() выполняет множество служебных задач: Сохраняет контекст изменяемого регистра в части KTRAP_FRAME, созданном в стеке Проверяет, выполнял ли во время прерывания процессор инструкции внтури конкретного региона функции ExpInterlockedPopEntrySList() и, если выполнял, он сбрасывает регистр RIP на допустимую инструкцию возобновления цикла в функции Проверяет, выключены ли прерывания и, если это так, багчекает систему на с кодом остановки TRAP_CAUSE_UNKNOWN Получает указатель на структуру прерывания, ассоциированную с прерыванием и обрабатывает прерывание Восстанавливает котекст изменяемого регистра из KTRAP_FRAME Возвращается из прерывания Интересно, что большинство частей функции KiIsrLinkage() созданы из макросов, многие из которых доступны в заголовочном файле WDK kxamd64.inc, например GENERATE_INTERRUPT_FRAME, ENTER_INTERRUPT, EXIT_INTERRUPT и RESTORE_TRAP_STATE KINTERRUPT Структура KINTERRUPT - основной ключ к обработке прерываний, она содержит всю информацию, необходимую для вызова ISR(interrupt service routine), зарегистрированной драйвером. KiIsrLinkage() определяет, где находится структура KINTERRUPT, связанная с вектором прерывания, используя его, как индекс в массиве указателей структур KINTERRUPT, находищихся в KPCR.CurrentPrcb.InterruptObject[]. Функция KiGetInterruptObjectAddress() из NTOSKRNL получает указатель на объект KINTERRUPT, показано ниже: 0: kd&gt; uf nt!KiGetInterruptObjectAddress nt!KiGetInterruptObjectAddress: fffff805`17f771d0 65488b142520000000 mov rdx,qword ptr gs:[20h] fffff805`17f771d9 4881c240310000 add rdx,3140h fffff805`17f771e0 8bc1 mov eax,ecx fffff805`17f771e2 488d04c2 lea rax,[rdx+rax*8] fffff805`17f771e6 c3 ret 0: kd&gt; !idt 50 Dumping IDT: fffff8051ae62000 50: fffff80517ff9bf0 dxgkrnl!DpiFdoLineInterruptRoutine (KINTERRUPT ffffb70107b9c500) 0: kd&gt; dt @$pcr nt!_KPCR -a Prcb.InterruptObject[50] +0x180 Prcb : +0x3140 InterruptObject : [80] 0xffffb701`07b9c500 Void 0: kd&gt; dt nt!_KINTERRUPT 0xffffb70107b9c500 +0x000 Type : 0n22 +0x002 Size : 0n288 +0x008 InterruptListEntry : _LIST_ENTRY [ 0x00000000`00000000 - 0x00000000`00000000 ] +0x018 ServiceRoutine : 0xfffff805`1b051e60 unsigned char dxgkrnl!DpiFdoLineInterruptRoutine+0 +0x020 MessageServiceRoutine : (null) +0x028 MessageIndex : 0 +0x030 ServiceContext : 0xffff990e`5377a030 Void +0x038 SpinLock : 0 +0x040 TickCount : 0 +0x048 ActualLock : 0xffff990e`530eea10 -&gt; 0 +0x050 DispatchAddress : 0xfffff805`17ff8c70 void nt!KiInterruptDispatch+0 +0x058 Vector : 0x50 +0x05c Irql : 0x5 &#39;&#39; +0x05d SynchronizeIrql : 0x5 &#39;&#39; +0x05e FloatingSave : 0 &#39;&#39; +0x05f Connected : 0x1 &#39;&#39; +0x060 Number : 0 +0x064 ShareVector : 0x1 &#39;&#39; +0x065 EmulateActiveBoth : 0 &#39;&#39; +0x066 ActiveCount : 0 +0x068 InternalState : 0n0 +0x06c Mode : 0 ( LevelSensitive ) +0x070 Polarity : 0 ( InterruptPolarityUnknown ) +0x074 ServiceCount : 0 +0x078 DispatchCount : 0 +0x080 PassiveEvent : (null) +0x088 TrapFrame : 0xfffff805`1ae6e520 _KTRAP_FRAME +0x090 DisconnectData : (null) +0x098 ServiceThread : (null) +0x0a0 ConnectionData : 0xffff990e`53931cc0 _INTERRUPT_CONNECTION_DATA +0x0a8 IntTrackEntry : 0xffff990e`532cc500 Void +0x0b0 IsrDpcStats : _ISRDPCSTATS +0x110 RedirectObject : (null) +0x118 PhysicalDeviceObject : 0xffff990e`50fc2360 Void Поля структуры KINTERRUPT, которые относятся к обработке прерываний: Название Описание DispatchAddress Указатель на начальный программный обработчик прерываний в NTOSKRNL (KiChainedDispatch() ) для общих прерываний и KiInterruptDispatch() для других ServiceRoutine Указатель на программный обработчик прерываний, зарегистрированный драйвером с помощью API ядра IoConnectInterrupt() или IoConnectInterruptEx() MessageServiceRoutine Используется только для MSI (message signaled interrupts - прерывания, инициируемые сообщениями), т.е. прерывания, которые доставляются путём записи в зарезервированные участи памяти вместо переключения аппаратных линий. Эти прерывания показываются, как отрицательные числа в device manager’e. Для таких прерываний ServiceRoutine указывает на ядерную функцию KiInterruptMessageDispatch(), которая вызывает ISR, связанную с драйвером в MessageServiceRoutine MessageIndex Индекс MSI, передаваемый, как параметр в ISR у MessageServiceRoutine В старых версиях Windows KINTERRUPT аллоцировалась из исполняемого невыгружаемого пула памяти, так как содержала начальный код обработки, который был зарегистрирован прямо в IDT. Из-за перехода к механизму из KiIsrThunk() и KiIsrLinkage(), описанному выше, начальная заглушка для прерывания теперь находится в исполняемой памяти в NTOSKRNL и, соответственно, структуре KINTERRUPT больше не нужно быть аллоцированной из исполняемой памяти. Структуры KINTERRUPT теперь пре-аллоцируются и хранятся в списке в KPCR.Prcb.InterruptObjectPool. Функция KeAllocateInterrupt() забирает пре-аллоцированную структуру KINTERRUPT из списка, когда вызывается для аллокации новой структуры KINTERRUPT. Когда этот список заканчивается, алооцируется ещё одна страница со структурами с помощью MmAllocateIndependentPages(), и добалвяет их в список. Interrupt Dispatching Одним из важных шагов, предпринятых KiIsrLinkage, является вызов функции в KINTERRUPT.DispatchAddress, что приводит к вызову либо KiInterruptDispatch(), либо KiChainedDispatch(). Обе эти функции вызываются с указателем на структуру KINTERRUPT, как будто у них есть доступ ко всей информации, относящейся к обработке прерывания. Новые системы используют APIC (Advanced Programmable Interrupt Controller) для обработки прерываний с устройств. Устройства отправляют свои прерывания на процессор с помощью IRQ линий. Однако, устройств больше, чем IRQ линий. Общие прерывания убирают проблему позволяя использовать одни и те же IRQ линии множеству устройств. Когда IRQ шарится, множество драйверов регистрирует свои ISR’ы для одного и того же IRQ и вектора прерывания. Из этого вытекает множественная структура KINTERRUPT, соответствующая устройствам, которые делят прерывание, и на них ссылаются вместе с помощью их полей KINTERRUPT.InterruptListEntry. Увидеть это можно с помощью “!idt -a”, когда одному вектору прерывания соответствует множество структур KINTERRUPT, связанных с ним. KiChainedDispatch() обрабатывает прерывания, которые шарятся с множеством устройств, а KiInterruptDispatch() обрабатывает остальные прерывания. Функции KiInterruptDispatch() и KiChainedDispatch меняются в зависимости от стека прерывания процессора, указатель на который хранится в KPCR.Prb.IsrStack. Этот стек аллоцируется функцией MmAllocateIsrStack(). Размер ISR стека 0x7000 байт, как определено переменными ISR_STACK_SIZE и PAGE_SIZE в заголовочном файле ksamd64.inc WDK. Непосредственный переход на стек ISR происходит с помощью макроса SWITCH_TO_ISR_STACK и также доступен в ksamd64.inc. Как только выполнение перешло на стек ISR, функции KiInterruptDispatch() и KiChainedDispatch() передают выполнение следующей стадии, вызывая KiInterruptSubDispatch() или KiScanInterruptObjectList() соответственно. KiInterruptSubDispatch() вызывает KiCallInterruptServiceRoutine() для одиночной структуры KINTERRUPT. KiScanInterruptObjectList() итерируется по всем объектам KINTERRUPT, зарегистрированным для одного вектора прерывания, используя список KINTERRUPT.InterruptListEntry и вызывает KiCallInterruptServiceRoutine() для каждого KINTERRUPT в цепочке. KiCallInterruptServiceRoutine() выполняет следующие задачи: Помечает прерывание, как активное в KINTERRUPT.IsrDpcStats.IsrActive Записывает время начала ISR в KINTERRUPT.IsrDpcStats.IsrTimeStart Получает спин-блокировку прерывания в KINTERRUPT.ActualLock Вызывает драйвер, зарегистрированный ISR в KINTERRUPT.ServiceRoutine Записывает длительность ISR в KINTERRUPT.IsrDpcStats.IsrTime Если ISR была прервана другой ISR с большим уровнем IRQL, он подстраивает IsrTime для точного учёта времени Помечает прерывание как неактивное в KINTERRUPT.IsrDpcStats.IsrActive Инкрементирует счётчик экземпляров прерываний в IsrCount Драйвер, который регистрировал ISR, может сообщить вызывающей функции KiCallInterruptServiceRoutine(), забрал ли он на обработку прерывание, вернув TRUE. Это становится важным в случае пошареных прерываний, где решение вызвать ISR в следующем KINTERRUPT в цепочке или нет зависит от того, забрал ли текущий ISR прерывание на обработку. Следующая диаграмма показывает все структуры, описанные выше и отношения между ними. Как и в предыдущих версиях Windows 64, и IDTR, и содержимое IDT защищено PatchGuard (kernel patch protection). Делая структуру KINTERRUPT неисполняемой и удаляю код обработки из структуры, мы закрываем ещё один вектор subversion. Однако, даже с этими новыми изменениями в обработке исключений всё равно возможно для драйвера ядра хукнуть ISR в системе для реализации своего функционала, например для кейлоггера. ISR драйвера в поле KINTERRUPT.ServiceRoutine может быть заменено указателем на хук-функцию и PatchGuard этого не заметит. Так же не заметит, если KINTERRUPT, хранящийся в KPCR.Prcb.InterruptObject[] будет заменён клонированной структурой KINTERRUPT, который будет вести к выполнению кода. IDT - Interrupt Descriptor Table (таблица дескрипторов прерываний) Там хранятся элементы _KIDENTRY или _KIDENTRY64 соответственно В каждой из них есть ссылка на ISR (Interrupt Service Routine) - непостредственно функция, которая вызывается Вторая статья и практика-практика-практика Механизм прерываний - ещё один важный элемент уровня железа Прерывания можно рассматривать, как события уровня железа, использующиеся для сигнализирования процессору, что что-то требует немедленного внимания Прерывания устройств Устройства (сетевая карта, клавиатура и тд) вызовут прерывание, чтобы сигнализировать процессору, что у них есть новая информация для обработки (входящий сетевой пакет, нажатие на клавишу и тд) Ловушки / исключения Эти вещи обычно происходят, когда процессор сталкивается с ошибкой, такой как деление на ноль или ошибка страницы Программные прерывания Это такие прерывания, которые генерируются программами, например INT 2E (syscall) используется для перехода из user mode в kernel mode. INT 3 используется для генерации программного брейкпоинта и тд Значение, которое идёт за инструкцией INT называется вектором прерывания, это просто индекс в IDT (Interrupt Descriptor Table). IDT ассоциирует вектор прерывания с конкретной функцией, которая будет обрабатывать вызванное прерывание. В WDK (Windows Driver Kit) такая функция называется ISR (Interrupt Service Routine) С точки зрения железа прерывания обрабатываются конкретным куском железа, называемым PIC (Programmable Interrupt Controller - контроллер прерываний). Сейчас у нас обычно стоит новая версия PIC - APIC (Advanced Programmable Interrupt Controller), встроенная прямо в процессов Плюсы APIC: Поддержка многопроцессорности Больше линий прерываний (256 vs 15 для PIC) Для каждого CPU свой APIC, и каждый APIC может коммуницировать с другими APIC’ами через IPI (Inter-processor interrupt message) Одна большая задача в обработке прерываний, которую выполняет APIC - это управление приоритетами прерываний. Каждой линии прерываний выдан свой приоритет и APIC проверяет, что ни один входящий запрос на прерывание с приоритетом ниже или равным текущему обрабатываемому прерыванию не достигнет процессор, обычно это называют Interrupt Masking Заметьте, что некоторые особые прерывания не могут был замаскированы и всегда будут достигать процессор, они называются NMI (Non-maskable interrupt). Они обычно предназначены для неустранимого сбоя оборудования, что означает, что у вас серьёзные проблемы с железом. Прерывания, приходящие от устройств, сначала обрабатываются I/O APIC, специальным чипом, встроенным в чипсет, его роль - распределять прерывания по локальным APIC’ам всех CPU, таким образом включая SMP (Symmetric multiprocessing - Симметричная многопроцессорность) Когда прерывание достигает CPU, процессор и процедура прерывания ОС сохранят стостояние значения регистров в стеке ядра, чтобы можно было восстановить предыдущий поток выполнения и продолжить исполнение кода. Этот набор сохраняемых регистров и некотороая дополнителья информация (например код ошибки) обычно называются Trap Frame (.trap в windbg) Углубимся немного в механизм обработки прерываний. Откуда процессор знает, где расположения IDT? Ответ - в регистре IDTR. 48-битный регистр делится на две части: 16-бит - IDT limit и 32-бита - base address Максимальное количество записей в IDT - 256. Каждая запись - 8 бит, содержит флаги, сегментные селекторы, gate type и оффсет или адрес ISR. Оффсет тоже разделён на две части: биты 0..15 - для младших битив и 48..63 - для старших битов В винде IDT entry - это _KIDTENTRY kd&gt; dt nt!_KIDTENTRY +0x000 Offset : Uint2B +0x002 Selector : Uint2B +0x004 Access : Uint2B +0x006 ExtendedOffset : Uint2B Чтобы отобразить IDT в windbg есть !idt kd&gt; !idt Dumping IDT: 8003f400 30: 806f5d50 hal!HalpClockInterrupt 31: 89ec9044 i8042prt!I8042KeyboardInterruptService (KINTERRUPT 89ec9008) 38: 806efef0 hal!HalpProfileInterrupt 39: 89fed174 ACPI!ACPIInterruptServiceRoutine (KINTERRUPT 89fed138) NDIS!ndisMIsr (KINTERRUPT 89f228d8) 3a: 89f24044 VIDEOPRT!pVideoPortInterrupt (KINTERRUPT 89f24008) USBPORT!USBPORT_InterruptService (KINTERRUPT 89eae008) 3b: 8a01d6c4 VBoxGuest+0x27c0 (KINTERRUPT 8a01d688) portcls!CKsShellRequestor::`scalar deleting destructor&#39;+0x26 (KINTERRUPT 89f179c0) 3c: 89ead564 i8042prt!I8042MouseInterruptService (KINTERRUPT 89ead528) 3e: 89fea9d4 atapi!IdePortInterrupt (KINTERRUPT 89fea998) 3f: 8a03d044 atapi!IdePortInterrupt (KINTERRUPT 8a03d008) Например разберём поближе i8042prt!I8042KeyboardInterruptService Для проверки, что это такое вообще (ну вдруг мы по названию не догадались) поставим бряку на него kd&gt; u i8042prt!I8042KeyboardInterruptService i8042prt!I8042KeyboardInterruptService: f76a7495 6a18 push 18h f76a7497 68a8a76af7 push offset i8042prt!`string&#39;+0x154 (f76aa7a8) f76a749c e8fa000000 call i8042prt!_SEH_prolog (f76a759b) f76a74a1 8b7d0c mov edi,dword ptr [ebp+0Ch] f76a74a4 8b7728 mov esi,dword ptr [edi+28h] f76a74a7 837e3001 cmp dword ptr [esi+30h],1 f76a74ab 0f8582130000 jne i8042prt!I8042KeyboardInterruptService+0xa2 (f76a8833) f76a74b1 a100a96af7 mov eax,dword ptr [i8042prt!Globals (f76aa900)] kd&gt; bu i8042prt!I8042KeyboardInterruptService kd&gt; bl 0 e Disable Clear f76a7495 0001 (0001) i8042prt!I8042KeyboardInterruptService kd&gt; g Breakpoint 0 hit i8042prt!I8042KeyboardInterruptService: f76a7495 6a18 push 18h Мы нажали на любую кнопку –&gt; наш брейкпоинт сработал Но давайте доберёмся до кода в статике, ведь то, что написано в выводе команды !idt (31: 89ec9044 i8042prt! …) не совпадает с фактическим адресом ISR Каждый элемент IDT занимает 8 байт, мы решили, что нам нужен индекс 31 (такой индекс у нужной нам функции), что нам нужно сделать? idtr + 0x31 * 8 –&gt; kd&gt; r idtr idtr=8003f400 kd&gt; dd @idtr+8*0x31 8003f588 - 00089044 89ec8e00 0008dd14 804d8e00 --&gt; 0x89ec9044 8003f598 - 0008dd1e 804d8e00 0008dd28 804d8e00 8003f5a8 - 0008dd32 804d8e00 0008dd3c 804d8e00 8003f5b8 - 0008dd46 804d8e00 0008fef0 806e8e00 8003f5c8 - 0008d174 89fe8e00 00084044 89f28e00 8003f5d8 - 0008d6c4 8a018e00 0008d564 89ea8e00 8003f5e8 - 0008dd82 804d8e00 0008a9d4 89fe8e00 8003f5f8 - 0008d044 8a038e00 0008dda0 804d8e00 И так наш ISR адрес 0x89ec9044, но мы же вроде бы только что дампили I8042KeyboardInterruptService и его адрес был 0xf76a7495, непонятно Чтож, перед тем, как вызывать ISR’ры драйверов системе нужно выполнить некоторые задачи: маскирование прерываний с более низким приоритетом в APIC, поднятие уровня IRQL и тд Так что вместо того, чтобы заполнить IDT ISR’ами, система заполняет их glue кодом или же иначе функциями-темплейтами Каждая темплейт-функция взята (скопирована) из KiInterruptTemplate функции и динамически модифицирована, чтобы подходить соответствующему ISR’у Давайте посмотрим на темплейт нашей KeyboardInterruptService: Мы можем заметить, что почти весь код скопирован с оригинального KiInterruptTemplate. Однако есть одна интересная особенность: темплейт функции клавиатуры вызывает KiInterruptDispatch и кладёт в EDI адрес 0x89EC9008 Этот адрес указывает на interrupt object с типом _KINTERRUPT: kd&gt; dt nt!_KINTERRUPT 0x89EC9008 +0x000 Type : 0n22 +0x002 Size : 0n484 +0x004 InterruptListEntry : _LIST_ENTRY [ 0x89ec900c - 0x89ec900c ] +0x00c ServiceRoutine : 0xf76a7495 unsigned char i8042prt!I8042KeyboardInterruptService+0 +0x010 ServiceContext : 0x89f259d0 Void +0x014 SpinLock : 0 +0x018 TickCount : 0xffffffff +0x01c ActualLock : 0x89f25a90 -&gt; 0 +0x020 DispatchAddress : 0x804da8e8 void nt!KiInterruptDispatch+0 +0x024 Vector : 0x31 +0x028 Irql : 0x1a &#39;&#39; +0x029 SynchronizeIrql : 0x1a &#39;&#39; +0x02a FloatingSave : 0 &#39;&#39; +0x02b Connected : 0x1 &#39;&#39; +0x02c Number : 0 &#39;&#39; +0x02d ShareVector : 0 &#39;&#39; +0x030 Mode : 1 ( Latched ) +0x034 ServiceCount : 0 +0x038 DispatchCount : 0xffffffff +0x03c DispatchCode : [106] 0x56535554 Как видно выше, как раз в ServiceRoutine хранится адрес ISR Если мы теперь посмотрим на KiInterruptDispatch мы увидим, что он вызывает interrupt object ServiceRoutine kd&gt; u nt!KiInterruptDispatch L30 nt!KiInterruptDispatch: 804da8e8 ff05c4f5dfff inc dword ptr ds:[0FFDFF5C4h] 804da8ee 8bec mov ebp,esp 804da8f0 8b4724 mov eax,dword ptr [edi+24h] 804da8f3 8b4f29 mov ecx,dword ptr [edi+29h] 804da8f6 50 push eax 804da8f7 83ec04 sub esp,4 804da8fa 54 push esp 804da8fb 50 push eax 804da8fc 51 push ecx 804da8fd ff1504764d80 call dword ptr [nt!_imp__HalBeginSystemInterrupt (804d7604)] 804da903 0bc0 or eax,eax 804da905 7436 je nt!KiInterruptDispatch+0x55 (804da93d) 804da907 83ec0c sub esp,0Ch 804da90a 833d0c23568000 cmp dword ptr [nt!PPerfGlobalGroupMask (8056230c)],0 804da911 c745f400000000 mov dword ptr [ebp-0Ch],0 804da918 752b jne nt!KiInterruptDispatch+0x5d (804da945) 804da91a 8b771c mov esi,dword ptr [edi+1Ch] 804da91d 8b4710 mov eax,dword ptr [edi+10h] 804da920 50 push eax 804da921 57 push edi 804da922 ff570c call dword ptr [edi+0Ch] kd&gt; dt nt!_KINTERRUPT 0x89EC9008 ... +0x00c ServiceRoutine : 0xf76a7495 unsigned char i8042prt!I8042KeyboardInterruptService+0 ... Вся структура вызовов: И как создаётся interrupt object? Это роль драйвера заполнить структуру, вызвав IoConnectInterrupt Добавим ещё немного экспериментов: Давайте посмотрим на прерывание и исключение деления на ноль Оно у нас самое первое в таблице IDT kd&gt; !idt -a Dumping IDT: 8003f400 00: 804df370 nt!KiTrap00 01: 804df4eb nt!KiTrap01 02: Task Selector = 0x0000 03: 804df8bd nt!KiTrap03 04: 804dfa40 nt!KiTrap04 05: 804dfba1 nt!KiTrap05 06: 804dfd22 nt!KiTrap06 07: 804e038a nt!KiTrap07 Поставим бряку bu nt!KiTrap00 И на машине скомпилим какой-нибудь такой код: #include &lt;stdio.h&gt; #include &lt;Windows.h&gt; int main() { sleep(5); printf(&quot;Go!\n&quot;); int x = 10; int y; scanf(&quot;%f&quot;, &amp;y); printf(&quot;%f&quot;, x / y); return 0; } Вводим ноль и Viola! брякаемся kd&gt; !process 0 0 Failed to get VadRoot PROCESS 897cf578 SessionId: 0 Cid: 06ac Peb: 7ffdc000 ParentCid: 0e48 DirBase: 825e9000 ObjectTable: e2c24c78 HandleCount: 7. Image: Untitled1.exe kd&gt; .process /i 897cf578 You need to continue execution (press &#39;g&#39; &lt;enter&gt;) for the context to be switched. When the debugger breaks in again, you will be in the new process context. ReadVirtual: 8a01c688 not properly sign extended kd&gt; g Break instruction exception - code 80000003 (first chance) nt!RtlpBreakWithStatusInstruction: 804e351a cc int 3 ReadVirtual: 8a01c688 not properly sign extended 00401500 55 push ebp 00401501 89e5 mov ebp,esp 00401503 83e4f0 and esp,0FFFFFFF0h 00401506 83ec20 sub esp,20h 00401509 e8b2090000 call 00401ec0 0040150e c7042405000000 mov dword ptr [esp],5 00401515 e8b6100000 call 004025d0 0040151a c7042400404000 mov dword ptr [esp],404000h 00401521 e832110000 call 00402658 &lt;-- printf(&quot;Go!\n&quot;) 00401526 c744241c0a000000 mov dword ptr [esp+1Ch],0Ah 0040152e 8d442418 lea eax,[esp+18h] 00401532 89442404 mov dword ptr [esp+4],eax 00401536 c7042404404000 mov dword ptr [esp],404004h 0040153d e81e110000 call 00402660 &lt;-- scanf 00401542 8bd9 mov ebx,ecx 00401544 2418 and al,18h 00401546 8b44241c mov eax,dword ptr [esp+1Ch] 0040154a 99 cdq 0040154b f7f9 idiv eax,ecx 0040154d 89442404 mov dword ptr [esp+4],eax 00401551 c7042404404000 mov dword ptr [esp],404004h 00401558 e80b110000 call 00402668 0040155d b800000000 mov eax,0 00401562 c9 leave Падаем в обработку ... 804df3ea 55 push ebp 804df3eb e8b6431400 call nt!Ki386CheckDivideByZeroTrap (806237a6) ... Посмотрим на 64-битную 10-ку Тут всё выглядит поинтереснее, мб из-за отсутствия дебаг символом на XP’хе, а мб и нет kd&gt; !idt Dumping IDT: fffff80335462000 00: fffff80330a01c00 nt!KiDivideErrorFault 01: fffff80330a01f40 nt!KiDebugTrapOrFault Stack = 0xFFFFF803354A0000 02: fffff80330a02440 nt!KiNmiInterrupt Stack = 0xFFFFF80335492000 03: fffff80330a02900 nt!KiBreakpointTrap 04: fffff80330a02c40 nt!KiOverflowTrap 05: fffff80330a02f80 nt!KiBoundFault 06: fffff80330a034c0 nt!KiInvalidOpcodeFault 07: fffff80330a039c0 nt!KiNpxNotAvailableFault 08: fffff80330a03cc0 nt!KiDoubleFaultAbort Stack = 0xFFFFF8033548B000 09: fffff80330a03fc0 nt!KiNpxSegmentOverrunAbort 0a: fffff80330a042c0 nt!KiInvalidTssFault 0b: fffff80330a045c0 nt!KiSegmentNotPresentFault 0c: fffff80330a04980 nt!KiStackFault 0d: fffff80330a04cc0 nt!KiGeneralProtectionFault 0e: fffff80330a05000 nt!KiPageFault 10: fffff80330a05640 nt!KiFloatingErrorFault 11: fffff80330a05a00 nt!KiAlignmentFault 12: fffff80330a05d40 nt!KiMcheckAbort Stack = 0xFFFFF80335499000 13: fffff80330a06840 nt!KiXmmException 14: fffff80330a06c00 nt!KiVirtualizationException 15: fffff80330a07100 nt!KiControlProtectionFault 1f: fffff803309fb220 nt!KiApcInterrupt 20: fffff803309fce00 nt!KiSwInterrupt 29: fffff80330a07600 nt!KiRaiseSecurityCheckFailure 2c: fffff80330a07940 nt!KiRaiseAssertion 2d: fffff80330a07c80 nt!KiDebugServiceTrap 2f: fffff803309fd3c0 nt!KiDpcInterrupt 30: fffff803309fb7c0 nt!KiHvInterrupt 31: fffff803309fbaa0 nt!KiVmbusInterrupt0 32: fffff803309fbd80 nt!KiVmbusInterrupt1 33: fffff803309fc060 nt!KiVmbusInterrupt2 34: fffff803309fc340 nt!KiVmbusInterrupt3 35: fffff803309f9b18 nt!HalpInterruptCmciService (KINTERRUPT fffff803312f2f40) 36: fffff803309f9b20 nt!HalpInterruptCmciService (KINTERRUPT fffff803312f3180) 50: fffff803309f9bf0 dxgkrnl!DpiFdoLineInterruptRoutine (KINTERRUPT ffffa600bf1fb500) 60: fffff803309f9c70 USBPORT!USBPORT_InterruptService (KINTERRUPT ffffa600bf1fb780) 70: fffff803309f9cf0 VBoxGuest+0x22e0 (KINTERRUPT ffffa600bf1fbb40) 80: fffff803309f9d70 storport!RaidpAdapterInterruptRoutine (KINTERRUPT ffffa600bf1fbc80) HDAudBus!HdaController::Isr (KINTERRUPT ffffa600bf1fb640) 90: fffff803309f9df0 i8042prt!I8042MouseInterruptService (KINTERRUPT ffffa600bf1fb8c0) a0: fffff803309f9e70 i8042prt!I8042KeyboardInterruptService (KINTERRUPT ffffa600bf1fba00) b0: fffff803309f9ef0 ACPI!ACPIInterruptServiceRoutine (KINTERRUPT ffffa600bf1fbdc0) ce: fffff803309f9fe0 nt!HalpIommuInterruptRoutine (KINTERRUPT fffff803312f3ba0) d1: fffff803309f9ff8 nt!HalpTimerClockInterrupt (KINTERRUPT fffff803312f3960) d2: fffff803309fa000 nt!HalpTimerClockIpiRoutine (KINTERRUPT fffff803312f3840) d7: fffff803309fa028 nt!HalpInterruptRebootService (KINTERRUPT fffff803312f3600) d8: fffff803309fa030 nt!HalpInterruptStubService (KINTERRUPT fffff803312f33c0) df: fffff803309fa068 nt!HalpInterruptSpuriousService (KINTERRUPT fffff803312f32a0) e1: fffff803309fd8b0 nt!KiIpiInterrupt e2: fffff803309fa080 nt!HalpInterruptLocalErrorService (KINTERRUPT fffff803312f34e0) e3: fffff803309fa088 nt!HalpInterruptDeferredRecoveryService (KINTERRUPT fffff803312f3060) fd: fffff803309fa158 nt!HalpTimerProfileInterrupt (KINTERRUPT fffff803312f3a80) fe: fffff803309fa160 nt!HalpPerfInterrupt (KINTERRUPT fffff803312f3720) Возьмём снова наш обработчик клавиатуры по оффсету a0 kd&gt; dt _kidtentry64 (idtr + (0xa0*0x10)) ntdll!_KIDTENTRY64 +0x000 OffsetLow : 0x9e70 +0x002 Selector : 0x10 +0x004 IstIndex : 0y000 +0x004 Reserved0 : 0y00000 (0) +0x004 Type : 0y01110 (0xe) +0x004 Dpl : 0y00 +0x004 Present : 0y1 +0x006 OffsetMiddle : 0x309f +0x008 OffsetHigh : 0xfffff803 +0x00c Reserved1 : 0 +0x000 Alignment : 0x309f8e00`00109e70 Найдём ISR entry point для него, теперь для 64 бит схема немного другая: OffsetHigh + OffsetMiddle + OffsetLow 0xfffff803309f9e70 Offset: 0xfffff803309f9e70 fffff803`309f9e70 6aa0 push 0FFFFFFFFFFFFFFA0h fffff803`309f9e72 55 push rbp fffff803`309f9e73 e909030000 jmp nt!KiIsrLinkage (fffff803`309fa181) Если в табличке !idt искать KINTERRUPT не хочется, можно сделать так: kd&gt; dt @$pcr nt!_KPCR -a Prcb.InterruptObject[0xa0] +0x180 Prcb : +0x3140 InterruptObject : [160] 0xffffa600`bf1fba00 Void kd&gt; dt nt!_KINTERRUPT ffffa600bf1fba00 +0x000 Type : 0n22 +0x002 Size : 0n288 +0x008 InterruptListEntry : _LIST_ENTRY [ 0x00000000`00000000 - 0x00000000`00000000 ] +0x018 ServiceRoutine : 0xfffff803`36096790 unsigned char i8042prt!I8042KeyboardInterruptService+0 +0x020 MessageServiceRoutine : (null) +0x028 MessageIndex : 0 +0x030 ServiceContext : 0xffffcf8b`4e304040 Void +0x038 SpinLock : 0 +0x040 TickCount : 0 +0x048 ActualLock : 0xffffcf8b`4e3041a0 -&gt; 0 +0x050 DispatchAddress : 0xfffff803`309f8c70 void nt!KiInterruptDispatch+0 +0x058 Vector : 0xa0 +0x05c Irql : 0xa &#39;&#39; +0x05d SynchronizeIrql : 0xa &#39;&#39; +0x05e FloatingSave : 0 &#39;&#39; +0x05f Connected : 0x1 &#39;&#39; +0x060 Number : 0 +0x064 ShareVector : 0 &#39;&#39; +0x065 EmulateActiveBoth : 0 &#39;&#39; +0x066 ActiveCount : 0 +0x068 InternalState : 0n0 +0x06c Mode : 1 ( Latched ) +0x070 Polarity : 0 ( InterruptPolarityUnknown ) +0x074 ServiceCount : 0 +0x078 DispatchCount : 0 +0x080 PassiveEvent : (null) +0x088 TrapFrame : 0xfffffb82`3ab14a20 _KTRAP_FRAME +0x090 DisconnectData : (null) +0x098 ServiceThread : (null) +0x0a0 ConnectionData : 0xffffcf8b`4e467d00 _INTERRUPT_CONNECTION_DATA +0x0a8 IntTrackEntry : 0xffffcf8b`4ccac690 Void +0x0b0 IsrDpcStats : _ISRDPCSTATS +0x110 RedirectObject : (null) +0x118 PhysicalDeviceObject : (null) напочитать: Ориг статья с экспериментами https://www.ired.team/miscellaneous-reversing-forensics/windows-kernel-internals/interrupt-descriptor-table-idt https://vivek-arora.com/?p=801 https://www.ired.team/miscellaneous-reversing-forensics/windows-kernel-internals/glimpse-into-ssdt-in-windows-x64-kernel https://codemachine.com/articles/interrupt_dispatching.html" />
<meta property="og:site_name" content="Windows Internals Blog" />
<meta property="og:image" content="/assets/previews/4.jpg" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2022-05-20T00:00:00+00:00" />
<meta name="twitter:card" content="summary_large_image" />
<meta property="twitter:image" content="/assets/previews/4.jpg" />
<meta property="twitter:title" content="Немного о прерываниях, их обработке и есесна ядре [ru]" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"truebad0ur"},"dateModified":"2022-05-20T00:00:00+00:00","datePublished":"2022-05-20T00:00:00+00:00","description":"Тут будет перевод одной статейки для погружения в теорию: статейка Interrupt Dispatching Internals Microsoft изменили способ обработки прерываний в последних версиях Windows. Были опубликованы некоторые публичные ресёрчи по обработке прерываний на старых версиях Windows и на 32-битных системах, однако не так много информации можно найти о том, как это работает в современном мире. В этой статье я попытаюсь привести описание обработки исключений на 64-битной Windows 10, в особенности Windows 10 RS1 Anniversary Update Build 10.0.10586 Прерывания используются операционными системами, чтобы получать сообщения об ивентах, происходящих на оборудовании. Обработка исключений - это механизм, в котором процессор передаёт контроль исполнения программному обеспечению, чтобы обработать событие на оборудовании. Прерывания обрабатываются ядром Windows, которое сначала выполняет некоторые служебные действия перед передачей контроля исполнения драйверам железа, которые в свою очередь регистрируют ISR (функции обработчика прерывания). IDT (Interrupt Descriptor Table) - это основная структура, задействованная в обработке исключений и её формат устанавливает разработчик процессора. IDT должна быть заполнена на этапе загрузки и соответственно должна использоваться процессором для обработки прерываний, приходящих с устройств IDTR Register У процессоров есть встроенный регистр, называемый IDTR, который Windows заполняет виртуальным адресом IDT в ядре, который он устанавливает для каждого процессора на этапе загрузки. Значение регистра IDTR для каждого процессора. На мульти процессорной системе каждый процессор имеет свой IDTR регистр, который указывает на локальную приватную копию IDT 0: kd&gt; ~0 0: kd&gt; r @idtr idtr=fffff8051ae62000 0: kd&gt; ~1 1: kd&gt; r @idtr idtr=ffffb70107dad000 1: kd&gt; ~2 2: kd&gt; r @idtr idtr=ffffb701077ea000 Interrupt Descriptor Table IDT содержит всего 256 значений, некоторые из которых используются для исключений, некоторые для программных прерываний, а остальные для прерываний железа. Индекс в IDT, по которому выбирают конкретный элемент, называется вектором прерывания. Формат каждого элемента IDT описывается разработчиком процессора. Ядро Windows определяет структуру KIDTENTRY64, которая представляет собой один элемент IDT на 64-битном процессоре. Используя вывод предыдущей команды “r @idtr”, мы можем вывести нулевой элемент IDT, на который указывает IDTR 0: kd&gt; ~0 0: kd&gt; r @idtr idtr=fffff8051ae62000 0: kd&gt; dt nt!_KIDTENTRY64 fffff8051ae62000 +0x000 OffsetLow : 0x1c00 +0x002 Selector : 0x10 +0x004 IstIndex : 0y000 +0x004 Reserved0 : 0y00000 (0) +0x004 Type : 0y01110 (0xe) +0x004 Dpl : 0y00 +0x004 Present : 0y1 +0x006 OffsetMiddle : 0x1800 +0x008 OffsetHigh : 0xfffff805 +0x00c Reserved1 : 0 +0x000 Alignment : 0x18008e00`00101c00 Комбинация OffsetHigh, OffsetMiddle и OffsetLow даёт нам виртуальный адрес, куда процессор передаст поток выполнения, когда произойдёт прерывание. В выводе выше виртуальный адрес - 0xfffff80518001c00. Это совпадает с выводом “!idt 0” и указывает на фукнцию KiDivideErrorFault(). Значение поля Type в выводе выше (0xe) показывает, что поле в IDT представляет собой Interrupt Gate 0: kd&gt; !idt 0 Dumping IDT: fffff8051ae62000 00: fffff80518001c00 nt!KiDivideErrorFault Первые N элементов в IDT нужны для обработки исключений и определены разработчиком процессора. Остальные элементы или используются для программных прерываний, или для хардварных, или не используются вовсе. В выводе “!idt” хардварные прерывания очень просто определить: у них есть указатель на структуру KINTERRUPT. “!idt -a” показывает значения всей IDT 0: kd&gt; !idt -a Dumping IDT: fffff8051ae62000 00: fffff80518001c00 nt!KiDivideErrorFault 01: fffff80518001f40 nt!KiDebugTrapOrFault Stack = 0xFFFFF8051AEA0000 02: fffff80518002440 nt!KiNmiInterrupt Stack = 0xFFFFF8051AE92000 03: fffff80518002900 nt!KiBreakpointTrap 04: fffff80518002c40 nt!KiOverflowTrap 05: fffff80518002f80 nt!KiBoundFault 06: fffff805180034c0 nt!KiInvalidOpcodeFault 07: fffff805180039c0 nt!KiNpxNotAvailableFault 08: fffff80518003cc0 nt!KiDoubleFaultAbort Stack = 0xFFFFF8051AE8B000 09: fffff80518003fc0 nt!KiNpxSegmentOverrunAbort 0a: fffff805180042c0 nt!KiInvalidTssFault 0b: fffff805180045c0 nt!KiSegmentNotPresentFault 0c: fffff80518004980 nt!KiStackFault 0d: fffff80518004cc0 nt!KiGeneralProtectionFault 0e: fffff80518005000 nt!KiPageFault 0f: fffff80517ff99e8 nt!KiIsrThunk+0x78 10: fffff80518005640 nt!KiFloatingErrorFault 11: fffff80518005a00 nt!KiAlignmentFault 12: fffff80518005d40 nt!KiMcheckAbort Stack = 0xFFFFF8051AE99000 13: fffff80518006840 nt!KiXmmException 14: fffff80518006c00 nt!KiVirtualizationException 15: fffff80518007100 nt!KiControlProtectionFault 16: fffff80517ff9a20 nt!KiIsrThunk+0xB0 17: fffff80517ff9a28 nt!KiIsrThunk+0xB8 18: fffff80517ff9a30 nt!KiIsrThunk+0xC0 19: fffff80517ff9a38 nt!KiIsrThunk+0xC8 1a: fffff80517ff9a40 nt!KiIsrThunk+0xD0 1b: fffff80517ff9a48 nt!KiIsrThunk+0xD8 1c: fffff80517ff9a50 nt!KiIsrThunk+0xE0 1d: fffff80517ff9a58 nt!KiIsrThunk+0xE8 1e: fffff80517ff9a60 nt!KiIsrThunk+0xF0 1f: fffff80517ffb220 nt!KiApcInterrupt 20: fffff80517ffce00 nt!KiSwInterrupt В этой статье мы сфокусируемся на хардварных прерываниях, соответственно последние элементы IDT. hex значение в первой колонке - это вектор или индекс прерывания, по которому и находится конкретное прерывание в IDT. Как было сказано ранее, каждый элемент IDT указывает на набор инструкций, которые будут выполнены, как один из этапов обработки исключения. Давайте возьмём второй элемент в хардварной части IDR, вектор 0x50 0: kd&gt; !idt 50 Dumping IDT: fffff8051ae62000 50: fffff80517ff9bf0 dxgkrnl!DpiFdoLineInterruptRoutine (KINTERRUPT ffffb70107b9c500) Выведем IDT 0x50, используя IDTR 0: kd&gt; dt nt!_KIDTENTRY64 @idtr+0x50*0x10 +0x000 OffsetLow : 0x9bf0 +0x002 Selector : 0x10 +0x004 IstIndex : 0y000 +0x004 Reserved0 : 0y00000 (0) +0x004 Type : 0y01110 (0xe) +0x004 Dpl : 0y00 +0x004 Present : 0y1 +0x006 OffsetMiddle : 0x17ff +0x008 OffsetHigh : 0xfffff805 +0x00c Reserved1 : 0 +0x000 Alignment : 0x17ff8e00`00109bf0 0: kd&gt; dt @idtr + @@c++(0x50 * sizeof(nt!_KIDTENTRY64)) nt!_KIDTENTRY64 +0x000 OffsetLow : 0x9bf0 +0x002 Selector : 0x10 +0x004 IstIndex : 0y000 +0x004 Reserved0 : 0y00000 (0) +0x004 Type : 0y01110 (0xe) +0x004 Dpl : 0y00 +0x004 Present : 0y1 +0x006 OffsetMiddle : 0x17ff +0x008 OffsetHigh : 0xfffff805 +0x00c Reserved1 : 0 +0x000 Alignment : 0x17ff8e00`00109bf0 Когда появляется прерывание, исполнение кода передаётся в 0xfffff80517ff9bf0 Этот адрес указывает на исполняемую страницу памяти в NTOSKRNL и содержит следующие инструкции: 0: kd&gt; u 0xfffff80517ff9bf0 L3 nt!KiIsrThunk+0x280: fffff805`17ff9bf0 6a50 push 50h fffff805`17ff9bf2 55 push rbp fffff805`17ff9bf3 e989050000 jmp nt!KiIsrLinkage (fffff805`17ffa181) Переменная KiIsrThunk из NTOSKRNL указывает на ядреную страницу кода, которая содержит 256 темплейтов, похожих на инструкции выше. После push interrupt vector (0x50) в этом случае и содержимого RBP регистра на стек, KiIsrThunk заглушка передаёт управление KiIsrLinkage(). Это 2 элемента на стеке используются функцией KiIsrLinkage() через структуру KTRAP_FRAME. KiIsrLinkage() KiIsrLinkage() выполняет множество служебных задач: Сохраняет контекст изменяемого регистра в части KTRAP_FRAME, созданном в стеке Проверяет, выполнял ли во время прерывания процессор инструкции внтури конкретного региона функции ExpInterlockedPopEntrySList() и, если выполнял, он сбрасывает регистр RIP на допустимую инструкцию возобновления цикла в функции Проверяет, выключены ли прерывания и, если это так, багчекает систему на с кодом остановки TRAP_CAUSE_UNKNOWN Получает указатель на структуру прерывания, ассоциированную с прерыванием и обрабатывает прерывание Восстанавливает котекст изменяемого регистра из KTRAP_FRAME Возвращается из прерывания Интересно, что большинство частей функции KiIsrLinkage() созданы из макросов, многие из которых доступны в заголовочном файле WDK kxamd64.inc, например GENERATE_INTERRUPT_FRAME, ENTER_INTERRUPT, EXIT_INTERRUPT и RESTORE_TRAP_STATE KINTERRUPT Структура KINTERRUPT - основной ключ к обработке прерываний, она содержит всю информацию, необходимую для вызова ISR(interrupt service routine), зарегистрированной драйвером. KiIsrLinkage() определяет, где находится структура KINTERRUPT, связанная с вектором прерывания, используя его, как индекс в массиве указателей структур KINTERRUPT, находищихся в KPCR.CurrentPrcb.InterruptObject[]. Функция KiGetInterruptObjectAddress() из NTOSKRNL получает указатель на объект KINTERRUPT, показано ниже: 0: kd&gt; uf nt!KiGetInterruptObjectAddress nt!KiGetInterruptObjectAddress: fffff805`17f771d0 65488b142520000000 mov rdx,qword ptr gs:[20h] fffff805`17f771d9 4881c240310000 add rdx,3140h fffff805`17f771e0 8bc1 mov eax,ecx fffff805`17f771e2 488d04c2 lea rax,[rdx+rax*8] fffff805`17f771e6 c3 ret 0: kd&gt; !idt 50 Dumping IDT: fffff8051ae62000 50: fffff80517ff9bf0 dxgkrnl!DpiFdoLineInterruptRoutine (KINTERRUPT ffffb70107b9c500) 0: kd&gt; dt @$pcr nt!_KPCR -a Prcb.InterruptObject[50] +0x180 Prcb : +0x3140 InterruptObject : [80] 0xffffb701`07b9c500 Void 0: kd&gt; dt nt!_KINTERRUPT 0xffffb70107b9c500 +0x000 Type : 0n22 +0x002 Size : 0n288 +0x008 InterruptListEntry : _LIST_ENTRY [ 0x00000000`00000000 - 0x00000000`00000000 ] +0x018 ServiceRoutine : 0xfffff805`1b051e60 unsigned char dxgkrnl!DpiFdoLineInterruptRoutine+0 +0x020 MessageServiceRoutine : (null) +0x028 MessageIndex : 0 +0x030 ServiceContext : 0xffff990e`5377a030 Void +0x038 SpinLock : 0 +0x040 TickCount : 0 +0x048 ActualLock : 0xffff990e`530eea10 -&gt; 0 +0x050 DispatchAddress : 0xfffff805`17ff8c70 void nt!KiInterruptDispatch+0 +0x058 Vector : 0x50 +0x05c Irql : 0x5 &#39;&#39; +0x05d SynchronizeIrql : 0x5 &#39;&#39; +0x05e FloatingSave : 0 &#39;&#39; +0x05f Connected : 0x1 &#39;&#39; +0x060 Number : 0 +0x064 ShareVector : 0x1 &#39;&#39; +0x065 EmulateActiveBoth : 0 &#39;&#39; +0x066 ActiveCount : 0 +0x068 InternalState : 0n0 +0x06c Mode : 0 ( LevelSensitive ) +0x070 Polarity : 0 ( InterruptPolarityUnknown ) +0x074 ServiceCount : 0 +0x078 DispatchCount : 0 +0x080 PassiveEvent : (null) +0x088 TrapFrame : 0xfffff805`1ae6e520 _KTRAP_FRAME +0x090 DisconnectData : (null) +0x098 ServiceThread : (null) +0x0a0 ConnectionData : 0xffff990e`53931cc0 _INTERRUPT_CONNECTION_DATA +0x0a8 IntTrackEntry : 0xffff990e`532cc500 Void +0x0b0 IsrDpcStats : _ISRDPCSTATS +0x110 RedirectObject : (null) +0x118 PhysicalDeviceObject : 0xffff990e`50fc2360 Void Поля структуры KINTERRUPT, которые относятся к обработке прерываний: Название Описание DispatchAddress Указатель на начальный программный обработчик прерываний в NTOSKRNL (KiChainedDispatch() ) для общих прерываний и KiInterruptDispatch() для других ServiceRoutine Указатель на программный обработчик прерываний, зарегистрированный драйвером с помощью API ядра IoConnectInterrupt() или IoConnectInterruptEx() MessageServiceRoutine Используется только для MSI (message signaled interrupts - прерывания, инициируемые сообщениями), т.е. прерывания, которые доставляются путём записи в зарезервированные участи памяти вместо переключения аппаратных линий. Эти прерывания показываются, как отрицательные числа в device manager’e. Для таких прерываний ServiceRoutine указывает на ядерную функцию KiInterruptMessageDispatch(), которая вызывает ISR, связанную с драйвером в MessageServiceRoutine MessageIndex Индекс MSI, передаваемый, как параметр в ISR у MessageServiceRoutine В старых версиях Windows KINTERRUPT аллоцировалась из исполняемого невыгружаемого пула памяти, так как содержала начальный код обработки, который был зарегистрирован прямо в IDT. Из-за перехода к механизму из KiIsrThunk() и KiIsrLinkage(), описанному выше, начальная заглушка для прерывания теперь находится в исполняемой памяти в NTOSKRNL и, соответственно, структуре KINTERRUPT больше не нужно быть аллоцированной из исполняемой памяти. Структуры KINTERRUPT теперь пре-аллоцируются и хранятся в списке в KPCR.Prcb.InterruptObjectPool. Функция KeAllocateInterrupt() забирает пре-аллоцированную структуру KINTERRUPT из списка, когда вызывается для аллокации новой структуры KINTERRUPT. Когда этот список заканчивается, алооцируется ещё одна страница со структурами с помощью MmAllocateIndependentPages(), и добалвяет их в список. Interrupt Dispatching Одним из важных шагов, предпринятых KiIsrLinkage, является вызов функции в KINTERRUPT.DispatchAddress, что приводит к вызову либо KiInterruptDispatch(), либо KiChainedDispatch(). Обе эти функции вызываются с указателем на структуру KINTERRUPT, как будто у них есть доступ ко всей информации, относящейся к обработке прерывания. Новые системы используют APIC (Advanced Programmable Interrupt Controller) для обработки прерываний с устройств. Устройства отправляют свои прерывания на процессор с помощью IRQ линий. Однако, устройств больше, чем IRQ линий. Общие прерывания убирают проблему позволяя использовать одни и те же IRQ линии множеству устройств. Когда IRQ шарится, множество драйверов регистрирует свои ISR’ы для одного и того же IRQ и вектора прерывания. Из этого вытекает множественная структура KINTERRUPT, соответствующая устройствам, которые делят прерывание, и на них ссылаются вместе с помощью их полей KINTERRUPT.InterruptListEntry. Увидеть это можно с помощью “!idt -a”, когда одному вектору прерывания соответствует множество структур KINTERRUPT, связанных с ним. KiChainedDispatch() обрабатывает прерывания, которые шарятся с множеством устройств, а KiInterruptDispatch() обрабатывает остальные прерывания. Функции KiInterruptDispatch() и KiChainedDispatch меняются в зависимости от стека прерывания процессора, указатель на который хранится в KPCR.Prb.IsrStack. Этот стек аллоцируется функцией MmAllocateIsrStack(). Размер ISR стека 0x7000 байт, как определено переменными ISR_STACK_SIZE и PAGE_SIZE в заголовочном файле ksamd64.inc WDK. Непосредственный переход на стек ISR происходит с помощью макроса SWITCH_TO_ISR_STACK и также доступен в ksamd64.inc. Как только выполнение перешло на стек ISR, функции KiInterruptDispatch() и KiChainedDispatch() передают выполнение следующей стадии, вызывая KiInterruptSubDispatch() или KiScanInterruptObjectList() соответственно. KiInterruptSubDispatch() вызывает KiCallInterruptServiceRoutine() для одиночной структуры KINTERRUPT. KiScanInterruptObjectList() итерируется по всем объектам KINTERRUPT, зарегистрированным для одного вектора прерывания, используя список KINTERRUPT.InterruptListEntry и вызывает KiCallInterruptServiceRoutine() для каждого KINTERRUPT в цепочке. KiCallInterruptServiceRoutine() выполняет следующие задачи: Помечает прерывание, как активное в KINTERRUPT.IsrDpcStats.IsrActive Записывает время начала ISR в KINTERRUPT.IsrDpcStats.IsrTimeStart Получает спин-блокировку прерывания в KINTERRUPT.ActualLock Вызывает драйвер, зарегистрированный ISR в KINTERRUPT.ServiceRoutine Записывает длительность ISR в KINTERRUPT.IsrDpcStats.IsrTime Если ISR была прервана другой ISR с большим уровнем IRQL, он подстраивает IsrTime для точного учёта времени Помечает прерывание как неактивное в KINTERRUPT.IsrDpcStats.IsrActive Инкрементирует счётчик экземпляров прерываний в IsrCount Драйвер, который регистрировал ISR, может сообщить вызывающей функции KiCallInterruptServiceRoutine(), забрал ли он на обработку прерывание, вернув TRUE. Это становится важным в случае пошареных прерываний, где решение вызвать ISR в следующем KINTERRUPT в цепочке или нет зависит от того, забрал ли текущий ISR прерывание на обработку. Следующая диаграмма показывает все структуры, описанные выше и отношения между ними. Как и в предыдущих версиях Windows 64, и IDTR, и содержимое IDT защищено PatchGuard (kernel patch protection). Делая структуру KINTERRUPT неисполняемой и удаляю код обработки из структуры, мы закрываем ещё один вектор subversion. Однако, даже с этими новыми изменениями в обработке исключений всё равно возможно для драйвера ядра хукнуть ISR в системе для реализации своего функционала, например для кейлоггера. ISR драйвера в поле KINTERRUPT.ServiceRoutine может быть заменено указателем на хук-функцию и PatchGuard этого не заметит. Так же не заметит, если KINTERRUPT, хранящийся в KPCR.Prcb.InterruptObject[] будет заменён клонированной структурой KINTERRUPT, который будет вести к выполнению кода. IDT - Interrupt Descriptor Table (таблица дескрипторов прерываний) Там хранятся элементы _KIDENTRY или _KIDENTRY64 соответственно В каждой из них есть ссылка на ISR (Interrupt Service Routine) - непостредственно функция, которая вызывается Вторая статья и практика-практика-практика Механизм прерываний - ещё один важный элемент уровня железа Прерывания можно рассматривать, как события уровня железа, использующиеся для сигнализирования процессору, что что-то требует немедленного внимания Прерывания устройств Устройства (сетевая карта, клавиатура и тд) вызовут прерывание, чтобы сигнализировать процессору, что у них есть новая информация для обработки (входящий сетевой пакет, нажатие на клавишу и тд) Ловушки / исключения Эти вещи обычно происходят, когда процессор сталкивается с ошибкой, такой как деление на ноль или ошибка страницы Программные прерывания Это такие прерывания, которые генерируются программами, например INT 2E (syscall) используется для перехода из user mode в kernel mode. INT 3 используется для генерации программного брейкпоинта и тд Значение, которое идёт за инструкцией INT называется вектором прерывания, это просто индекс в IDT (Interrupt Descriptor Table). IDT ассоциирует вектор прерывания с конкретной функцией, которая будет обрабатывать вызванное прерывание. В WDK (Windows Driver Kit) такая функция называется ISR (Interrupt Service Routine) С точки зрения железа прерывания обрабатываются конкретным куском железа, называемым PIC (Programmable Interrupt Controller - контроллер прерываний). Сейчас у нас обычно стоит новая версия PIC - APIC (Advanced Programmable Interrupt Controller), встроенная прямо в процессов Плюсы APIC: Поддержка многопроцессорности Больше линий прерываний (256 vs 15 для PIC) Для каждого CPU свой APIC, и каждый APIC может коммуницировать с другими APIC’ами через IPI (Inter-processor interrupt message) Одна большая задача в обработке прерываний, которую выполняет APIC - это управление приоритетами прерываний. Каждой линии прерываний выдан свой приоритет и APIC проверяет, что ни один входящий запрос на прерывание с приоритетом ниже или равным текущему обрабатываемому прерыванию не достигнет процессор, обычно это называют Interrupt Masking Заметьте, что некоторые особые прерывания не могут был замаскированы и всегда будут достигать процессор, они называются NMI (Non-maskable interrupt). Они обычно предназначены для неустранимого сбоя оборудования, что означает, что у вас серьёзные проблемы с железом. Прерывания, приходящие от устройств, сначала обрабатываются I/O APIC, специальным чипом, встроенным в чипсет, его роль - распределять прерывания по локальным APIC’ам всех CPU, таким образом включая SMP (Symmetric multiprocessing - Симметричная многопроцессорность) Когда прерывание достигает CPU, процессор и процедура прерывания ОС сохранят стостояние значения регистров в стеке ядра, чтобы можно было восстановить предыдущий поток выполнения и продолжить исполнение кода. Этот набор сохраняемых регистров и некотороая дополнителья информация (например код ошибки) обычно называются Trap Frame (.trap в windbg) Углубимся немного в механизм обработки прерываний. Откуда процессор знает, где расположения IDT? Ответ - в регистре IDTR. 48-битный регистр делится на две части: 16-бит - IDT limit и 32-бита - base address Максимальное количество записей в IDT - 256. Каждая запись - 8 бит, содержит флаги, сегментные селекторы, gate type и оффсет или адрес ISR. Оффсет тоже разделён на две части: биты 0..15 - для младших битив и 48..63 - для старших битов В винде IDT entry - это _KIDTENTRY kd&gt; dt nt!_KIDTENTRY +0x000 Offset : Uint2B +0x002 Selector : Uint2B +0x004 Access : Uint2B +0x006 ExtendedOffset : Uint2B Чтобы отобразить IDT в windbg есть !idt kd&gt; !idt Dumping IDT: 8003f400 30: 806f5d50 hal!HalpClockInterrupt 31: 89ec9044 i8042prt!I8042KeyboardInterruptService (KINTERRUPT 89ec9008) 38: 806efef0 hal!HalpProfileInterrupt 39: 89fed174 ACPI!ACPIInterruptServiceRoutine (KINTERRUPT 89fed138) NDIS!ndisMIsr (KINTERRUPT 89f228d8) 3a: 89f24044 VIDEOPRT!pVideoPortInterrupt (KINTERRUPT 89f24008) USBPORT!USBPORT_InterruptService (KINTERRUPT 89eae008) 3b: 8a01d6c4 VBoxGuest+0x27c0 (KINTERRUPT 8a01d688) portcls!CKsShellRequestor::`scalar deleting destructor&#39;+0x26 (KINTERRUPT 89f179c0) 3c: 89ead564 i8042prt!I8042MouseInterruptService (KINTERRUPT 89ead528) 3e: 89fea9d4 atapi!IdePortInterrupt (KINTERRUPT 89fea998) 3f: 8a03d044 atapi!IdePortInterrupt (KINTERRUPT 8a03d008) Например разберём поближе i8042prt!I8042KeyboardInterruptService Для проверки, что это такое вообще (ну вдруг мы по названию не догадались) поставим бряку на него kd&gt; u i8042prt!I8042KeyboardInterruptService i8042prt!I8042KeyboardInterruptService: f76a7495 6a18 push 18h f76a7497 68a8a76af7 push offset i8042prt!`string&#39;+0x154 (f76aa7a8) f76a749c e8fa000000 call i8042prt!_SEH_prolog (f76a759b) f76a74a1 8b7d0c mov edi,dword ptr [ebp+0Ch] f76a74a4 8b7728 mov esi,dword ptr [edi+28h] f76a74a7 837e3001 cmp dword ptr [esi+30h],1 f76a74ab 0f8582130000 jne i8042prt!I8042KeyboardInterruptService+0xa2 (f76a8833) f76a74b1 a100a96af7 mov eax,dword ptr [i8042prt!Globals (f76aa900)] kd&gt; bu i8042prt!I8042KeyboardInterruptService kd&gt; bl 0 e Disable Clear f76a7495 0001 (0001) i8042prt!I8042KeyboardInterruptService kd&gt; g Breakpoint 0 hit i8042prt!I8042KeyboardInterruptService: f76a7495 6a18 push 18h Мы нажали на любую кнопку –&gt; наш брейкпоинт сработал Но давайте доберёмся до кода в статике, ведь то, что написано в выводе команды !idt (31: 89ec9044 i8042prt! …) не совпадает с фактическим адресом ISR Каждый элемент IDT занимает 8 байт, мы решили, что нам нужен индекс 31 (такой индекс у нужной нам функции), что нам нужно сделать? idtr + 0x31 * 8 –&gt; kd&gt; r idtr idtr=8003f400 kd&gt; dd @idtr+8*0x31 8003f588 - 00089044 89ec8e00 0008dd14 804d8e00 --&gt; 0x89ec9044 8003f598 - 0008dd1e 804d8e00 0008dd28 804d8e00 8003f5a8 - 0008dd32 804d8e00 0008dd3c 804d8e00 8003f5b8 - 0008dd46 804d8e00 0008fef0 806e8e00 8003f5c8 - 0008d174 89fe8e00 00084044 89f28e00 8003f5d8 - 0008d6c4 8a018e00 0008d564 89ea8e00 8003f5e8 - 0008dd82 804d8e00 0008a9d4 89fe8e00 8003f5f8 - 0008d044 8a038e00 0008dda0 804d8e00 И так наш ISR адрес 0x89ec9044, но мы же вроде бы только что дампили I8042KeyboardInterruptService и его адрес был 0xf76a7495, непонятно Чтож, перед тем, как вызывать ISR’ры драйверов системе нужно выполнить некоторые задачи: маскирование прерываний с более низким приоритетом в APIC, поднятие уровня IRQL и тд Так что вместо того, чтобы заполнить IDT ISR’ами, система заполняет их glue кодом или же иначе функциями-темплейтами Каждая темплейт-функция взята (скопирована) из KiInterruptTemplate функции и динамически модифицирована, чтобы подходить соответствующему ISR’у Давайте посмотрим на темплейт нашей KeyboardInterruptService: Мы можем заметить, что почти весь код скопирован с оригинального KiInterruptTemplate. Однако есть одна интересная особенность: темплейт функции клавиатуры вызывает KiInterruptDispatch и кладёт в EDI адрес 0x89EC9008 Этот адрес указывает на interrupt object с типом _KINTERRUPT: kd&gt; dt nt!_KINTERRUPT 0x89EC9008 +0x000 Type : 0n22 +0x002 Size : 0n484 +0x004 InterruptListEntry : _LIST_ENTRY [ 0x89ec900c - 0x89ec900c ] +0x00c ServiceRoutine : 0xf76a7495 unsigned char i8042prt!I8042KeyboardInterruptService+0 +0x010 ServiceContext : 0x89f259d0 Void +0x014 SpinLock : 0 +0x018 TickCount : 0xffffffff +0x01c ActualLock : 0x89f25a90 -&gt; 0 +0x020 DispatchAddress : 0x804da8e8 void nt!KiInterruptDispatch+0 +0x024 Vector : 0x31 +0x028 Irql : 0x1a &#39;&#39; +0x029 SynchronizeIrql : 0x1a &#39;&#39; +0x02a FloatingSave : 0 &#39;&#39; +0x02b Connected : 0x1 &#39;&#39; +0x02c Number : 0 &#39;&#39; +0x02d ShareVector : 0 &#39;&#39; +0x030 Mode : 1 ( Latched ) +0x034 ServiceCount : 0 +0x038 DispatchCount : 0xffffffff +0x03c DispatchCode : [106] 0x56535554 Как видно выше, как раз в ServiceRoutine хранится адрес ISR Если мы теперь посмотрим на KiInterruptDispatch мы увидим, что он вызывает interrupt object ServiceRoutine kd&gt; u nt!KiInterruptDispatch L30 nt!KiInterruptDispatch: 804da8e8 ff05c4f5dfff inc dword ptr ds:[0FFDFF5C4h] 804da8ee 8bec mov ebp,esp 804da8f0 8b4724 mov eax,dword ptr [edi+24h] 804da8f3 8b4f29 mov ecx,dword ptr [edi+29h] 804da8f6 50 push eax 804da8f7 83ec04 sub esp,4 804da8fa 54 push esp 804da8fb 50 push eax 804da8fc 51 push ecx 804da8fd ff1504764d80 call dword ptr [nt!_imp__HalBeginSystemInterrupt (804d7604)] 804da903 0bc0 or eax,eax 804da905 7436 je nt!KiInterruptDispatch+0x55 (804da93d) 804da907 83ec0c sub esp,0Ch 804da90a 833d0c23568000 cmp dword ptr [nt!PPerfGlobalGroupMask (8056230c)],0 804da911 c745f400000000 mov dword ptr [ebp-0Ch],0 804da918 752b jne nt!KiInterruptDispatch+0x5d (804da945) 804da91a 8b771c mov esi,dword ptr [edi+1Ch] 804da91d 8b4710 mov eax,dword ptr [edi+10h] 804da920 50 push eax 804da921 57 push edi 804da922 ff570c call dword ptr [edi+0Ch] kd&gt; dt nt!_KINTERRUPT 0x89EC9008 ... +0x00c ServiceRoutine : 0xf76a7495 unsigned char i8042prt!I8042KeyboardInterruptService+0 ... Вся структура вызовов: И как создаётся interrupt object? Это роль драйвера заполнить структуру, вызвав IoConnectInterrupt Добавим ещё немного экспериментов: Давайте посмотрим на прерывание и исключение деления на ноль Оно у нас самое первое в таблице IDT kd&gt; !idt -a Dumping IDT: 8003f400 00: 804df370 nt!KiTrap00 01: 804df4eb nt!KiTrap01 02: Task Selector = 0x0000 03: 804df8bd nt!KiTrap03 04: 804dfa40 nt!KiTrap04 05: 804dfba1 nt!KiTrap05 06: 804dfd22 nt!KiTrap06 07: 804e038a nt!KiTrap07 Поставим бряку bu nt!KiTrap00 И на машине скомпилим какой-нибудь такой код: #include &lt;stdio.h&gt; #include &lt;Windows.h&gt; int main() { sleep(5); printf(&quot;Go!\\n&quot;); int x = 10; int y; scanf(&quot;%f&quot;, &amp;y); printf(&quot;%f&quot;, x / y); return 0; } Вводим ноль и Viola! брякаемся kd&gt; !process 0 0 Failed to get VadRoot PROCESS 897cf578 SessionId: 0 Cid: 06ac Peb: 7ffdc000 ParentCid: 0e48 DirBase: 825e9000 ObjectTable: e2c24c78 HandleCount: 7. Image: Untitled1.exe kd&gt; .process /i 897cf578 You need to continue execution (press &#39;g&#39; &lt;enter&gt;) for the context to be switched. When the debugger breaks in again, you will be in the new process context. ReadVirtual: 8a01c688 not properly sign extended kd&gt; g Break instruction exception - code 80000003 (first chance) nt!RtlpBreakWithStatusInstruction: 804e351a cc int 3 ReadVirtual: 8a01c688 not properly sign extended 00401500 55 push ebp 00401501 89e5 mov ebp,esp 00401503 83e4f0 and esp,0FFFFFFF0h 00401506 83ec20 sub esp,20h 00401509 e8b2090000 call 00401ec0 0040150e c7042405000000 mov dword ptr [esp],5 00401515 e8b6100000 call 004025d0 0040151a c7042400404000 mov dword ptr [esp],404000h 00401521 e832110000 call 00402658 &lt;-- printf(&quot;Go!\\n&quot;) 00401526 c744241c0a000000 mov dword ptr [esp+1Ch],0Ah 0040152e 8d442418 lea eax,[esp+18h] 00401532 89442404 mov dword ptr [esp+4],eax 00401536 c7042404404000 mov dword ptr [esp],404004h 0040153d e81e110000 call 00402660 &lt;-- scanf 00401542 8bd9 mov ebx,ecx 00401544 2418 and al,18h 00401546 8b44241c mov eax,dword ptr [esp+1Ch] 0040154a 99 cdq 0040154b f7f9 idiv eax,ecx 0040154d 89442404 mov dword ptr [esp+4],eax 00401551 c7042404404000 mov dword ptr [esp],404004h 00401558 e80b110000 call 00402668 0040155d b800000000 mov eax,0 00401562 c9 leave Падаем в обработку ... 804df3ea 55 push ebp 804df3eb e8b6431400 call nt!Ki386CheckDivideByZeroTrap (806237a6) ... Посмотрим на 64-битную 10-ку Тут всё выглядит поинтереснее, мб из-за отсутствия дебаг символом на XP’хе, а мб и нет kd&gt; !idt Dumping IDT: fffff80335462000 00: fffff80330a01c00 nt!KiDivideErrorFault 01: fffff80330a01f40 nt!KiDebugTrapOrFault Stack = 0xFFFFF803354A0000 02: fffff80330a02440 nt!KiNmiInterrupt Stack = 0xFFFFF80335492000 03: fffff80330a02900 nt!KiBreakpointTrap 04: fffff80330a02c40 nt!KiOverflowTrap 05: fffff80330a02f80 nt!KiBoundFault 06: fffff80330a034c0 nt!KiInvalidOpcodeFault 07: fffff80330a039c0 nt!KiNpxNotAvailableFault 08: fffff80330a03cc0 nt!KiDoubleFaultAbort Stack = 0xFFFFF8033548B000 09: fffff80330a03fc0 nt!KiNpxSegmentOverrunAbort 0a: fffff80330a042c0 nt!KiInvalidTssFault 0b: fffff80330a045c0 nt!KiSegmentNotPresentFault 0c: fffff80330a04980 nt!KiStackFault 0d: fffff80330a04cc0 nt!KiGeneralProtectionFault 0e: fffff80330a05000 nt!KiPageFault 10: fffff80330a05640 nt!KiFloatingErrorFault 11: fffff80330a05a00 nt!KiAlignmentFault 12: fffff80330a05d40 nt!KiMcheckAbort Stack = 0xFFFFF80335499000 13: fffff80330a06840 nt!KiXmmException 14: fffff80330a06c00 nt!KiVirtualizationException 15: fffff80330a07100 nt!KiControlProtectionFault 1f: fffff803309fb220 nt!KiApcInterrupt 20: fffff803309fce00 nt!KiSwInterrupt 29: fffff80330a07600 nt!KiRaiseSecurityCheckFailure 2c: fffff80330a07940 nt!KiRaiseAssertion 2d: fffff80330a07c80 nt!KiDebugServiceTrap 2f: fffff803309fd3c0 nt!KiDpcInterrupt 30: fffff803309fb7c0 nt!KiHvInterrupt 31: fffff803309fbaa0 nt!KiVmbusInterrupt0 32: fffff803309fbd80 nt!KiVmbusInterrupt1 33: fffff803309fc060 nt!KiVmbusInterrupt2 34: fffff803309fc340 nt!KiVmbusInterrupt3 35: fffff803309f9b18 nt!HalpInterruptCmciService (KINTERRUPT fffff803312f2f40) 36: fffff803309f9b20 nt!HalpInterruptCmciService (KINTERRUPT fffff803312f3180) 50: fffff803309f9bf0 dxgkrnl!DpiFdoLineInterruptRoutine (KINTERRUPT ffffa600bf1fb500) 60: fffff803309f9c70 USBPORT!USBPORT_InterruptService (KINTERRUPT ffffa600bf1fb780) 70: fffff803309f9cf0 VBoxGuest+0x22e0 (KINTERRUPT ffffa600bf1fbb40) 80: fffff803309f9d70 storport!RaidpAdapterInterruptRoutine (KINTERRUPT ffffa600bf1fbc80) HDAudBus!HdaController::Isr (KINTERRUPT ffffa600bf1fb640) 90: fffff803309f9df0 i8042prt!I8042MouseInterruptService (KINTERRUPT ffffa600bf1fb8c0) a0: fffff803309f9e70 i8042prt!I8042KeyboardInterruptService (KINTERRUPT ffffa600bf1fba00) b0: fffff803309f9ef0 ACPI!ACPIInterruptServiceRoutine (KINTERRUPT ffffa600bf1fbdc0) ce: fffff803309f9fe0 nt!HalpIommuInterruptRoutine (KINTERRUPT fffff803312f3ba0) d1: fffff803309f9ff8 nt!HalpTimerClockInterrupt (KINTERRUPT fffff803312f3960) d2: fffff803309fa000 nt!HalpTimerClockIpiRoutine (KINTERRUPT fffff803312f3840) d7: fffff803309fa028 nt!HalpInterruptRebootService (KINTERRUPT fffff803312f3600) d8: fffff803309fa030 nt!HalpInterruptStubService (KINTERRUPT fffff803312f33c0) df: fffff803309fa068 nt!HalpInterruptSpuriousService (KINTERRUPT fffff803312f32a0) e1: fffff803309fd8b0 nt!KiIpiInterrupt e2: fffff803309fa080 nt!HalpInterruptLocalErrorService (KINTERRUPT fffff803312f34e0) e3: fffff803309fa088 nt!HalpInterruptDeferredRecoveryService (KINTERRUPT fffff803312f3060) fd: fffff803309fa158 nt!HalpTimerProfileInterrupt (KINTERRUPT fffff803312f3a80) fe: fffff803309fa160 nt!HalpPerfInterrupt (KINTERRUPT fffff803312f3720) Возьмём снова наш обработчик клавиатуры по оффсету a0 kd&gt; dt _kidtentry64 (idtr + (0xa0*0x10)) ntdll!_KIDTENTRY64 +0x000 OffsetLow : 0x9e70 +0x002 Selector : 0x10 +0x004 IstIndex : 0y000 +0x004 Reserved0 : 0y00000 (0) +0x004 Type : 0y01110 (0xe) +0x004 Dpl : 0y00 +0x004 Present : 0y1 +0x006 OffsetMiddle : 0x309f +0x008 OffsetHigh : 0xfffff803 +0x00c Reserved1 : 0 +0x000 Alignment : 0x309f8e00`00109e70 Найдём ISR entry point для него, теперь для 64 бит схема немного другая: OffsetHigh + OffsetMiddle + OffsetLow 0xfffff803309f9e70 Offset: 0xfffff803309f9e70 fffff803`309f9e70 6aa0 push 0FFFFFFFFFFFFFFA0h fffff803`309f9e72 55 push rbp fffff803`309f9e73 e909030000 jmp nt!KiIsrLinkage (fffff803`309fa181) Если в табличке !idt искать KINTERRUPT не хочется, можно сделать так: kd&gt; dt @$pcr nt!_KPCR -a Prcb.InterruptObject[0xa0] +0x180 Prcb : +0x3140 InterruptObject : [160] 0xffffa600`bf1fba00 Void kd&gt; dt nt!_KINTERRUPT ffffa600bf1fba00 +0x000 Type : 0n22 +0x002 Size : 0n288 +0x008 InterruptListEntry : _LIST_ENTRY [ 0x00000000`00000000 - 0x00000000`00000000 ] +0x018 ServiceRoutine : 0xfffff803`36096790 unsigned char i8042prt!I8042KeyboardInterruptService+0 +0x020 MessageServiceRoutine : (null) +0x028 MessageIndex : 0 +0x030 ServiceContext : 0xffffcf8b`4e304040 Void +0x038 SpinLock : 0 +0x040 TickCount : 0 +0x048 ActualLock : 0xffffcf8b`4e3041a0 -&gt; 0 +0x050 DispatchAddress : 0xfffff803`309f8c70 void nt!KiInterruptDispatch+0 +0x058 Vector : 0xa0 +0x05c Irql : 0xa &#39;&#39; +0x05d SynchronizeIrql : 0xa &#39;&#39; +0x05e FloatingSave : 0 &#39;&#39; +0x05f Connected : 0x1 &#39;&#39; +0x060 Number : 0 +0x064 ShareVector : 0 &#39;&#39; +0x065 EmulateActiveBoth : 0 &#39;&#39; +0x066 ActiveCount : 0 +0x068 InternalState : 0n0 +0x06c Mode : 1 ( Latched ) +0x070 Polarity : 0 ( InterruptPolarityUnknown ) +0x074 ServiceCount : 0 +0x078 DispatchCount : 0 +0x080 PassiveEvent : (null) +0x088 TrapFrame : 0xfffffb82`3ab14a20 _KTRAP_FRAME +0x090 DisconnectData : (null) +0x098 ServiceThread : (null) +0x0a0 ConnectionData : 0xffffcf8b`4e467d00 _INTERRUPT_CONNECTION_DATA +0x0a8 IntTrackEntry : 0xffffcf8b`4ccac690 Void +0x0b0 IsrDpcStats : _ISRDPCSTATS +0x110 RedirectObject : (null) +0x118 PhysicalDeviceObject : (null) напочитать: Ориг статья с экспериментами https://www.ired.team/miscellaneous-reversing-forensics/windows-kernel-internals/interrupt-descriptor-table-idt https://vivek-arora.com/?p=801 https://www.ired.team/miscellaneous-reversing-forensics/windows-kernel-internals/glimpse-into-ssdt-in-windows-x64-kernel https://codemachine.com/articles/interrupt_dispatching.html","headline":"Немного о прерываниях, их обработке и есесна ядре [ru]","image":"/assets/previews/4.jpg","mainEntityOfPage":{"@type":"WebPage","@id":"/2022/05/20/Interrupts_Kernel.html"},"url":"/2022/05/20/Interrupts_Kernel.html"}</script>
<!-- End Jekyll SEO tag -->

</head>

<link href="assets/favicon.ico" rel="icon" type="image/x-icon" />

<body>
  <div id="wrapper">
    <header>
  <div>
    <a href="/">
    <link rel="shortcut icon" href="/assets/favicon.ico">
    
    <h1>truebad0ur@home:~$</h1>
    </a>
    <div class="header-links">
      <a href="/archive.html"><h2 class="header-link">Archive</h2></a>
<a href="/about.html"><h2 class="header-link">About</h2></a>
<a href="/ToDo.html"><h2 class="header-link">ToDo</h2></a>
<a href="/Certificates.html"><h2 class="header-link">Certificates</h2></a>
<!--<a href="https://t.me/reverse_dungeon"><h2 class="header-link">Telegram</h2></a>-->

    </div>
  </div>
</header>

    <div class="container">
      <section id="main_content">
        <article>
  <p>Тут будет перевод одной статейки для погружения в теорию:</p>

<p><a href="https://codemachine.com/articles/interrupt_dispatching.html">статейка</a></p>

<h2 id="interrupt-dispatching-internals"><a href="#header-2"></a>Interrupt Dispatching Internals</h2>

<p>Microsoft изменили способ обработки прерываний в последних версиях Windows. Были опубликованы некоторые <a href="http://phrack.org/issues/65/4.html">публичные ресёрчи</a> по обработке прерываний на старых версиях Windows и на 32-битных системах, однако не так много информации можно найти о том, как это работает в современном мире. В этой статье я попытаюсь привести описание обработки исключений на 64-битной Windows 10, в особенности Windows 10 RS1 Anniversary Update Build 10.0.10586</p>

<p>Прерывания используются операционными системами, чтобы получать сообщения об ивентах, происходящих на оборудовании. Обработка исключений - это механизм, в котором процессор передаёт контроль исполнения программному обеспечению, чтобы обработать событие на оборудовании. Прерывания обрабатываются ядром Windows, которое сначала выполняет некоторые служебные действия перед передачей контроля исполнения драйверам железа, которые в свою очередь регистрируют ISR (функции обработчика прерывания). IDT (Interrupt Descriptor Table) - это основная структура, задействованная в обработке исключений и её формат <a href="https://www.intel.com/content/dam/www/public/us/en/documents/manuals/64-ia-32-architectures-software-developer-vol-3c-part-3-manual.pdf">устанавливает разработчик процессора</a>. IDT должна быть заполнена на этапе загрузки и соответственно должна использоваться процессором для обработки прерываний, приходящих с устройств</p>

<h3 id="idtr-register"><a href="#header-3"></a>IDTR Register</h3>

<p>У процессоров есть встроенный регистр, называемый IDTR, который Windows заполняет виртуальным адресом IDT в ядре, который он устанавливает для каждого процессора на этапе загрузки.</p>

<p><img src="/assets/idtr_structure.png" alt="IDTR Structure" /></p>

<p>Значение регистра IDTR для каждого процессора. На мульти процессорной системе каждый процессор имеет свой IDTR регистр, который указывает на локальную приватную копию IDT</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">0</span><span class="p">:</span> <span class="nx">kd</span><span class="o">&gt;</span> <span class="o">~</span><span class="mi">0</span>
<span class="mi">0</span><span class="p">:</span> <span class="nx">kd</span><span class="o">&gt;</span> <span class="nx">r</span> <span class="p">@</span><span class="nd">idtr</span>
<span class="nx">idtr</span><span class="o">=</span><span class="nx">fffff8051ae62000</span>

<span class="mi">0</span><span class="p">:</span> <span class="nx">kd</span><span class="o">&gt;</span> <span class="o">~</span><span class="mi">1</span>
<span class="mi">1</span><span class="p">:</span> <span class="nx">kd</span><span class="o">&gt;</span> <span class="nx">r</span> <span class="p">@</span><span class="nd">idtr</span>
<span class="nx">idtr</span><span class="o">=</span><span class="nx">ffffb70107dad000</span>

<span class="mi">1</span><span class="p">:</span> <span class="nx">kd</span><span class="o">&gt;</span> <span class="o">~</span><span class="mi">2</span>
<span class="mi">2</span><span class="p">:</span> <span class="nx">kd</span><span class="o">&gt;</span> <span class="nx">r</span> <span class="p">@</span><span class="nd">idtr</span>
<span class="nx">idtr</span><span class="o">=</span><span class="nx">ffffb701077ea000</span>
</code></pre></div></div>

<h3 id="interrupt-descriptor-table"><a href="#header-3"></a>Interrupt Descriptor Table</h3>

<p>IDT содержит всего 256 значений, некоторые из которых используются для исключений, некоторые для программных прерываний, а остальные для прерываний железа. Индекс в IDT, по которому выбирают конкретный элемент, называется вектором прерывания. Формат каждого элемента IDT описывается разработчиком процессора.</p>

<p><img src="/assets/trapgate.png" alt="TrapGate Structure" /></p>

<p>Ядро Windows определяет структуру KIDTENTRY64, которая представляет собой один элемент IDT на 64-битном процессоре. Используя вывод предыдущей команды “r @idtr”, мы можем вывести нулевой элемент IDT, на который указывает IDTR</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">0</span><span class="p">:</span> <span class="nx">kd</span><span class="o">&gt;</span> <span class="o">~</span><span class="mi">0</span>
<span class="mi">0</span><span class="p">:</span> <span class="nx">kd</span><span class="o">&gt;</span> <span class="nx">r</span> <span class="p">@</span><span class="nd">idtr</span>
<span class="nx">idtr</span><span class="o">=</span><span class="nx">fffff8051ae62000</span>
<span class="mi">0</span><span class="p">:</span> <span class="nx">kd</span><span class="o">&gt;</span> <span class="nx">dt</span> <span class="nx">nt</span><span class="o">!</span><span class="nx">_KIDTENTRY64</span> <span class="nx">fffff8051ae62000</span>
   <span class="o">+</span><span class="mh">0x000</span> <span class="nx">OffsetLow</span>        <span class="p">:</span> <span class="mh">0x1c00</span>
   <span class="o">+</span><span class="mh">0x002</span> <span class="nx">Selector</span>         <span class="p">:</span> <span class="mh">0x10</span>
   <span class="o">+</span><span class="mh">0x004</span> <span class="nx">IstIndex</span>         <span class="p">:</span> <span class="mi">0</span><span class="nx">y000</span>
   <span class="o">+</span><span class="mh">0x004</span> <span class="nx">Reserved0</span>        <span class="p">:</span> <span class="mi">0</span><span class="nf">y00000 </span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
   <span class="o">+</span><span class="mh">0x004</span> <span class="nx">Type</span>             <span class="p">:</span> <span class="mi">0</span><span class="nf">y01110 </span><span class="p">(</span><span class="mh">0xe</span><span class="p">)</span>
   <span class="o">+</span><span class="mh">0x004</span> <span class="nx">Dpl</span>              <span class="p">:</span> <span class="mi">0</span><span class="nx">y00</span>
   <span class="o">+</span><span class="mh">0x004</span> <span class="nx">Present</span>          <span class="p">:</span> <span class="mi">0</span><span class="nx">y1</span>
   <span class="o">+</span><span class="mh">0x006</span> <span class="nx">OffsetMiddle</span>     <span class="p">:</span> <span class="mh">0x1800</span>
   <span class="o">+</span><span class="mh">0x008</span> <span class="nx">OffsetHigh</span>       <span class="p">:</span> <span class="mh">0xfffff805</span>
   <span class="o">+</span><span class="mh">0x00c</span> <span class="nx">Reserved1</span>        <span class="p">:</span> <span class="mi">0</span>
   <span class="o">+</span><span class="mh">0x000</span> <span class="nx">Alignment</span>        <span class="p">:</span> <span class="mh">0x18008e00</span><span class="s2">`00101c00
</span></code></pre></div></div>

<p>Комбинация OffsetHigh, OffsetMiddle и OffsetLow даёт нам виртуальный адрес, куда процессор передаст поток выполнения, когда произойдёт прерывание. В выводе выше виртуальный адрес - 0xfffff80518001c00. Это совпадает с выводом “!idt 0” и указывает на фукнцию KiDivideErrorFault(). Значение поля Type в выводе выше (0xe) показывает, что поле в IDT представляет собой Interrupt Gate</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">0</span><span class="p">:</span> <span class="nx">kd</span><span class="o">&gt;</span> <span class="o">!</span><span class="nx">idt</span> <span class="mi">0</span>

<span class="nx">Dumping</span> <span class="nx">IDT</span><span class="p">:</span> <span class="nx">fffff8051ae62000</span>

<span class="mi">00</span><span class="p">:</span>	<span class="nx">fffff80518001c00</span> <span class="nx">nt</span><span class="o">!</span><span class="nx">KiDivideErrorFault</span>
</code></pre></div></div>

<p>Первые N элементов в IDT нужны для обработки исключений и определены разработчиком процессора. Остальные элементы или используются для программных прерываний, или для хардварных, или не используются вовсе. В выводе “!idt” хардварные прерывания очень просто определить: у них есть указатель на структуру KINTERRUPT. “!idt -a” показывает значения всей IDT</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">0</span><span class="p">:</span> <span class="nx">kd</span><span class="o">&gt;</span> <span class="o">!</span><span class="nx">idt</span> <span class="o">-</span><span class="nx">a</span>

<span class="nx">Dumping</span> <span class="nx">IDT</span><span class="p">:</span> <span class="nx">fffff8051ae62000</span>

<span class="mi">00</span><span class="p">:</span>	<span class="nx">fffff80518001c00</span> <span class="nx">nt</span><span class="o">!</span><span class="nx">KiDivideErrorFault</span>
<span class="mi">01</span><span class="p">:</span>	<span class="nx">fffff80518001f40</span> <span class="nx">nt</span><span class="o">!</span><span class="nx">KiDebugTrapOrFault</span>	<span class="nx">Stack</span> <span class="o">=</span> <span class="mh">0xFFFFF8051AEA0000</span>
<span class="mi">02</span><span class="p">:</span>	<span class="nx">fffff80518002440</span> <span class="nx">nt</span><span class="o">!</span><span class="nx">KiNmiInterrupt</span>	<span class="nx">Stack</span> <span class="o">=</span> <span class="mh">0xFFFFF8051AE92000</span>
<span class="mi">03</span><span class="p">:</span>	<span class="nx">fffff80518002900</span> <span class="nx">nt</span><span class="o">!</span><span class="nx">KiBreakpointTrap</span>
<span class="mi">04</span><span class="p">:</span>	<span class="nx">fffff80518002c40</span> <span class="nx">nt</span><span class="o">!</span><span class="nx">KiOverflowTrap</span>
<span class="mi">05</span><span class="p">:</span>	<span class="nx">fffff80518002f80</span> <span class="nx">nt</span><span class="o">!</span><span class="nx">KiBoundFault</span>
<span class="mi">06</span><span class="p">:</span>	<span class="nx">fffff805180034c0</span> <span class="nx">nt</span><span class="o">!</span><span class="nx">KiInvalidOpcodeFault</span>
<span class="mi">07</span><span class="p">:</span>	<span class="nx">fffff805180039c0</span> <span class="nx">nt</span><span class="o">!</span><span class="nx">KiNpxNotAvailableFault</span>
<span class="mi">08</span><span class="p">:</span>	<span class="nx">fffff80518003cc0</span> <span class="nx">nt</span><span class="o">!</span><span class="nx">KiDoubleFaultAbort</span>	<span class="nx">Stack</span> <span class="o">=</span> <span class="mh">0xFFFFF8051AE8B000</span>
<span class="mi">09</span><span class="p">:</span>	<span class="nx">fffff80518003fc0</span> <span class="nx">nt</span><span class="o">!</span><span class="nx">KiNpxSegmentOverrunAbort</span>
<span class="mi">0</span><span class="nx">a</span><span class="p">:</span>	<span class="nx">fffff805180042c0</span> <span class="nx">nt</span><span class="o">!</span><span class="nx">KiInvalidTssFault</span>
<span class="mi">0</span><span class="nx">b</span><span class="p">:</span>	<span class="nx">fffff805180045c0</span> <span class="nx">nt</span><span class="o">!</span><span class="nx">KiSegmentNotPresentFault</span>
<span class="mi">0</span><span class="nx">c</span><span class="p">:</span>	<span class="nx">fffff80518004980</span> <span class="nx">nt</span><span class="o">!</span><span class="nx">KiStackFault</span>
<span class="mi">0</span><span class="nx">d</span><span class="p">:</span>	<span class="nx">fffff80518004cc0</span> <span class="nx">nt</span><span class="o">!</span><span class="nx">KiGeneralProtectionFault</span>
<span class="mi">0</span><span class="nx">e</span><span class="p">:</span>	<span class="nx">fffff80518005000</span> <span class="nx">nt</span><span class="o">!</span><span class="nx">KiPageFault</span>
<span class="mi">0</span><span class="nx">f</span><span class="p">:</span>	<span class="nx">fffff80517ff99e8</span> <span class="nx">nt</span><span class="o">!</span><span class="nx">KiIsrThunk</span><span class="o">+</span><span class="mh">0x78</span>
<span class="mi">10</span><span class="p">:</span>	<span class="nx">fffff80518005640</span> <span class="nx">nt</span><span class="o">!</span><span class="nx">KiFloatingErrorFault</span>
<span class="mi">11</span><span class="p">:</span>	<span class="nx">fffff80518005a00</span> <span class="nx">nt</span><span class="o">!</span><span class="nx">KiAlignmentFault</span>
<span class="mi">12</span><span class="p">:</span>	<span class="nx">fffff80518005d40</span> <span class="nx">nt</span><span class="o">!</span><span class="nx">KiMcheckAbort</span>	<span class="nx">Stack</span> <span class="o">=</span> <span class="mh">0xFFFFF8051AE99000</span>
<span class="mi">13</span><span class="p">:</span>	<span class="nx">fffff80518006840</span> <span class="nx">nt</span><span class="o">!</span><span class="nx">KiXmmException</span>
<span class="mi">14</span><span class="p">:</span>	<span class="nx">fffff80518006c00</span> <span class="nx">nt</span><span class="o">!</span><span class="nx">KiVirtualizationException</span>
<span class="mi">15</span><span class="p">:</span>	<span class="nx">fffff80518007100</span> <span class="nx">nt</span><span class="o">!</span><span class="nx">KiControlProtectionFault</span>
<span class="mi">16</span><span class="p">:</span>	<span class="nx">fffff80517ff9a20</span> <span class="nx">nt</span><span class="o">!</span><span class="nx">KiIsrThunk</span><span class="o">+</span><span class="mh">0xB0</span>
<span class="mi">17</span><span class="p">:</span>	<span class="nx">fffff80517ff9a28</span> <span class="nx">nt</span><span class="o">!</span><span class="nx">KiIsrThunk</span><span class="o">+</span><span class="mh">0xB8</span>
<span class="mi">18</span><span class="p">:</span>	<span class="nx">fffff80517ff9a30</span> <span class="nx">nt</span><span class="o">!</span><span class="nx">KiIsrThunk</span><span class="o">+</span><span class="mh">0xC0</span>
<span class="mi">19</span><span class="p">:</span>	<span class="nx">fffff80517ff9a38</span> <span class="nx">nt</span><span class="o">!</span><span class="nx">KiIsrThunk</span><span class="o">+</span><span class="mh">0xC8</span>
<span class="mi">1</span><span class="nx">a</span><span class="p">:</span>	<span class="nx">fffff80517ff9a40</span> <span class="nx">nt</span><span class="o">!</span><span class="nx">KiIsrThunk</span><span class="o">+</span><span class="mh">0xD0</span>
<span class="mi">1</span><span class="nx">b</span><span class="p">:</span>	<span class="nx">fffff80517ff9a48</span> <span class="nx">nt</span><span class="o">!</span><span class="nx">KiIsrThunk</span><span class="o">+</span><span class="mh">0xD8</span>
<span class="mi">1</span><span class="nx">c</span><span class="p">:</span>	<span class="nx">fffff80517ff9a50</span> <span class="nx">nt</span><span class="o">!</span><span class="nx">KiIsrThunk</span><span class="o">+</span><span class="mh">0xE0</span>
<span class="mi">1</span><span class="nx">d</span><span class="p">:</span>	<span class="nx">fffff80517ff9a58</span> <span class="nx">nt</span><span class="o">!</span><span class="nx">KiIsrThunk</span><span class="o">+</span><span class="mh">0xE8</span>
<span class="mi">1</span><span class="nx">e</span><span class="p">:</span>	<span class="nx">fffff80517ff9a60</span> <span class="nx">nt</span><span class="o">!</span><span class="nx">KiIsrThunk</span><span class="o">+</span><span class="mh">0xF0</span>
<span class="mi">1</span><span class="nx">f</span><span class="p">:</span>	<span class="nx">fffff80517ffb220</span> <span class="nx">nt</span><span class="o">!</span><span class="nx">KiApcInterrupt</span>
<span class="mi">20</span><span class="p">:</span>	<span class="nx">fffff80517ffce00</span> <span class="nx">nt</span><span class="o">!</span><span class="nx">KiSwInterrupt</span>
</code></pre></div></div>

<p>В этой статье мы сфокусируемся на хардварных прерываниях, соответственно последние элементы IDT. hex значение в первой колонке - это вектор или индекс прерывания, по которому и находится конкретное прерывание в IDT. Как было сказано ранее, каждый элемент IDT указывает на набор инструкций, которые будут выполнены, как один из этапов обработки исключения.</p>

<p>Давайте возьмём второй элемент в хардварной части IDR, вектор 0x50</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">0</span><span class="p">:</span> <span class="nx">kd</span><span class="o">&gt;</span> <span class="o">!</span><span class="nx">idt</span> <span class="mi">50</span>

<span class="nx">Dumping</span> <span class="nx">IDT</span><span class="p">:</span> <span class="nx">fffff8051ae62000</span>

<span class="mi">50</span><span class="p">:</span>	<span class="nx">fffff80517ff9bf0</span> <span class="nx">dxgkrnl</span><span class="o">!</span><span class="nc">DpiFdoLineInterruptRoutine </span><span class="p">(</span><span class="nx">KINTERRUPT</span> <span class="nx">ffffb70107b9c500</span><span class="p">)</span>
</code></pre></div></div>

<p>Выведем IDT 0x50, используя IDTR</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">0</span><span class="p">:</span> <span class="nx">kd</span><span class="o">&gt;</span> <span class="nx">dt</span> <span class="nx">nt</span><span class="o">!</span><span class="nx">_KIDTENTRY64</span> <span class="p">@</span><span class="nd">idtr</span><span class="o">+</span><span class="mh">0x50</span><span class="o">*</span><span class="mh">0x10</span>
   <span class="o">+</span><span class="mh">0x000</span> <span class="nx">OffsetLow</span>        <span class="p">:</span> <span class="mh">0x9bf0</span>
   <span class="o">+</span><span class="mh">0x002</span> <span class="nx">Selector</span>         <span class="p">:</span> <span class="mh">0x10</span>
   <span class="o">+</span><span class="mh">0x004</span> <span class="nx">IstIndex</span>         <span class="p">:</span> <span class="mi">0</span><span class="nx">y000</span>
   <span class="o">+</span><span class="mh">0x004</span> <span class="nx">Reserved0</span>        <span class="p">:</span> <span class="mi">0</span><span class="nf">y00000 </span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
   <span class="o">+</span><span class="mh">0x004</span> <span class="nx">Type</span>             <span class="p">:</span> <span class="mi">0</span><span class="nf">y01110 </span><span class="p">(</span><span class="mh">0xe</span><span class="p">)</span>
   <span class="o">+</span><span class="mh">0x004</span> <span class="nx">Dpl</span>              <span class="p">:</span> <span class="mi">0</span><span class="nx">y00</span>
   <span class="o">+</span><span class="mh">0x004</span> <span class="nx">Present</span>          <span class="p">:</span> <span class="mi">0</span><span class="nx">y1</span>
   <span class="o">+</span><span class="mh">0x006</span> <span class="nx">OffsetMiddle</span>     <span class="p">:</span> <span class="mh">0x17ff</span>
   <span class="o">+</span><span class="mh">0x008</span> <span class="nx">OffsetHigh</span>       <span class="p">:</span> <span class="mh">0xfffff805</span>
   <span class="o">+</span><span class="mh">0x00c</span> <span class="nx">Reserved1</span>        <span class="p">:</span> <span class="mi">0</span>
   <span class="o">+</span><span class="mh">0x000</span> <span class="nx">Alignment</span>        <span class="p">:</span> <span class="mh">0x17ff8e00</span><span class="s2">`00109bf0
   
0: kd&gt; dt @idtr + @@c++(0x50 * sizeof(nt!_KIDTENTRY64)) nt!_KIDTENTRY64 
   +0x000 OffsetLow        : 0x9bf0
   +0x002 Selector         : 0x10
   +0x004 IstIndex         : 0y000
   +0x004 Reserved0        : 0y00000 (0)
   +0x004 Type             : 0y01110 (0xe)
   +0x004 Dpl              : 0y00
   +0x004 Present          : 0y1
   +0x006 OffsetMiddle     : 0x17ff
   +0x008 OffsetHigh       : 0xfffff805
   +0x00c Reserved1        : 0
   +0x000 Alignment        : 0x17ff8e00`</span><span class="mi">00109</span><span class="nx">bf0</span>
</code></pre></div></div>

<p>Когда появляется прерывание, исполнение кода передаётся в 0xfffff80517ff9bf0
Этот адрес указывает на исполняемую страницу памяти в NTOSKRNL и содержит следующие инструкции:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">0</span><span class="p">:</span> <span class="nx">kd</span><span class="o">&gt;</span> <span class="nx">u</span> <span class="mh">0xfffff80517ff9bf0</span> <span class="nx">L3</span>
	<span class="nx">nt</span><span class="o">!</span><span class="nx">KiIsrThunk</span><span class="o">+</span><span class="mh">0x280</span><span class="p">:</span>
	<span class="nx">fffff805</span><span class="s2">`17ff9bf0 6a50            push    50h
	fffff805`</span><span class="mi">17</span><span class="nx">ff9bf2</span> <span class="mi">55</span>              <span class="nx">push</span>    <span class="nx">rbp</span>
	<span class="nx">fffff805</span><span class="s2">`17ff9bf3 e989050000      jmp     nt!KiIsrLinkage (fffff805`</span><span class="mi">17</span><span class="nx">ffa181</span><span class="p">)</span>
</code></pre></div></div>

<p>Переменная KiIsrThunk из NTOSKRNL указывает на ядреную страницу кода, которая содержит 256 темплейтов, похожих на инструкции выше. После push interrupt vector (0x50) в этом случае и содержимого RBP регистра на стек, KiIsrThunk заглушка передаёт управление KiIsrLinkage(). Это 2 элемента на стеке используются функцией KiIsrLinkage() через структуру KTRAP_FRAME.</p>

<h4 id="kiisrlinkage"><a href="#header-4"></a>KiIsrLinkage()</h4>

<p>KiIsrLinkage() выполняет множество служебных задач:</p>

<ul>
  <li>Сохраняет контекст изменяемого регистра в части KTRAP_FRAME, созданном в стеке</li>
  <li>Проверяет, выполнял ли во время прерывания процессор инструкции внтури конкретного региона функции ExpInterlockedPopEntrySList() и, если выполнял, он сбрасывает регистр RIP на допустимую инструкцию возобновления цикла в функции</li>
  <li>Проверяет, выключены ли прерывания и, если это так, багчекает систему на с кодом остановки TRAP_CAUSE_UNKNOWN</li>
  <li>Получает указатель на структуру прерывания, ассоциированную с прерыванием и обрабатывает прерывание</li>
  <li>Восстанавливает котекст изменяемого регистра из KTRAP_FRAME</li>
  <li>Возвращается из прерывания</li>
</ul>

<p>Интересно, что большинство частей функции KiIsrLinkage() созданы из макросов, многие из которых доступны в заголовочном файле WDK kxamd64.inc, например GENERATE_INTERRUPT_FRAME, ENTER_INTERRUPT, EXIT_INTERRUPT и RESTORE_TRAP_STATE</p>

<h4 id="kinterrupt"><a href="#header-4"></a>KINTERRUPT</h4>

<p>Структура KINTERRUPT - основной ключ к обработке прерываний, она содержит всю информацию, необходимую для вызова ISR(interrupt service routine), зарегистрированной драйвером. KiIsrLinkage() определяет, где находится структура KINTERRUPT, связанная с вектором прерывания, используя его, как индекс в массиве указателей структур KINTERRUPT, находищихся в KPCR.CurrentPrcb.InterruptObject[]. Функция KiGetInterruptObjectAddress() из NTOSKRNL получает указатель на объект KINTERRUPT, показано ниже:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">0</span><span class="p">:</span> <span class="nx">kd</span><span class="o">&gt;</span> <span class="nx">uf</span> <span class="nx">nt</span><span class="o">!</span><span class="nx">KiGetInterruptObjectAddress</span>
	<span class="nx">nt</span><span class="o">!</span><span class="nx">KiGetInterruptObjectAddress</span><span class="p">:</span>
	<span class="nx">fffff805</span><span class="s2">`17f771d0 65488b142520000000 mov   rdx,qword ptr gs:[20h]
	fffff805`</span><span class="mi">17</span><span class="nx">f771d9</span> <span class="mi">4881</span><span class="nx">c240310000</span>  <span class="nx">add</span>     <span class="nx">rdx</span><span class="p">,</span><span class="mi">3140</span><span class="nx">h</span>
	<span class="nx">fffff805</span><span class="s2">`17f771e0 8bc1            mov     eax,ecx
	fffff805`</span><span class="mi">17</span><span class="nx">f771e2</span> <span class="mi">488</span><span class="nx">d04c2</span>        <span class="nx">lea</span>     <span class="nx">rax</span><span class="p">,[</span><span class="nx">rdx</span><span class="o">+</span><span class="nx">rax</span><span class="o">*</span><span class="mi">8</span><span class="p">]</span>
	<span class="nx">fffff805</span><span class="s2">`17f771e6 c3              ret
</span></code></pre></div></div>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">0</span><span class="p">:</span> <span class="nx">kd</span><span class="o">&gt;</span> <span class="o">!</span><span class="nx">idt</span> <span class="mi">50</span>
<span class="nx">Dumping</span> <span class="nx">IDT</span><span class="p">:</span> <span class="nx">fffff8051ae62000</span>
<span class="mi">50</span><span class="p">:</span>	<span class="nx">fffff80517ff9bf0</span> <span class="nx">dxgkrnl</span><span class="o">!</span><span class="nc">DpiFdoLineInterruptRoutine </span><span class="p">(</span><span class="nx">KINTERRUPT</span> <span class="nx">ffffb70107b9c500</span><span class="p">)</span>

<span class="mi">0</span><span class="p">:</span> <span class="nx">kd</span><span class="o">&gt;</span> <span class="nx">dt</span> <span class="p">@</span><span class="nx">$pcr</span> <span class="nx">nt</span><span class="o">!</span><span class="nx">_KPCR</span> <span class="o">-</span><span class="nx">a</span> <span class="nx">Prcb</span><span class="p">.</span><span class="nx">InterruptObject</span><span class="p">[</span><span class="mi">50</span><span class="p">]</span>
   <span class="o">+</span><span class="mh">0x180</span> <span class="nx">Prcb</span>                     <span class="p">:</span> 
      <span class="o">+</span><span class="mh">0x3140</span> <span class="nx">InterruptObject</span>          <span class="p">:</span> <span class="p">[</span><span class="mi">80</span><span class="p">]</span> <span class="mh">0xffffb701</span><span class="s2">`07b9c500 Void

0: kd&gt; dt nt!_KINTERRUPT 0xffffb70107b9c500
   +0x000 Type             : 0n22
   +0x002 Size             : 0n288
   +0x008 InterruptListEntry : _LIST_ENTRY [ 0x00000000`</span><span class="mi">00000000</span> <span class="o">-</span> <span class="mh">0x00000000</span><span class="s2">`00000000 ]
   +0x018 ServiceRoutine   : 0xfffff805`</span><span class="mi">1</span><span class="nx">b051e60</span>     <span class="nx">unsigned</span> <span class="nx">char</span>  <span class="nx">dxgkrnl</span><span class="o">!</span><span class="nx">DpiFdoLineInterruptRoutine</span><span class="o">+</span><span class="mi">0</span>
   <span class="o">+</span><span class="mh">0x020</span> <span class="nx">MessageServiceRoutine</span> <span class="p">:</span> <span class="p">(</span><span class="kc">null</span><span class="p">)</span> 
   <span class="o">+</span><span class="mh">0x028</span> <span class="nx">MessageIndex</span>     <span class="p">:</span> <span class="mi">0</span>
   <span class="o">+</span><span class="mh">0x030</span> <span class="nx">ServiceContext</span>   <span class="p">:</span> <span class="mh">0xffff990e</span><span class="s2">`5377a030 Void
   +0x038 SpinLock         : 0
   +0x040 TickCount        : 0
   +0x048 ActualLock       : 0xffff990e`</span><span class="mi">530</span><span class="nx">eea10</span>  <span class="o">-&gt;</span> <span class="mi">0</span>
   <span class="o">+</span><span class="mh">0x050</span> <span class="nx">DispatchAddress</span>  <span class="p">:</span> <span class="mh">0xfffff805</span><span class="s2">`17ff8c70     void  nt!KiInterruptDispatch+0
   +0x058 Vector           : 0x50
   +0x05c Irql             : 0x5 ''
   +0x05d SynchronizeIrql  : 0x5 ''
   +0x05e FloatingSave     : 0 ''
   +0x05f Connected        : 0x1 ''
   +0x060 Number           : 0
   +0x064 ShareVector      : 0x1 ''
   +0x065 EmulateActiveBoth : 0 ''
   +0x066 ActiveCount      : 0
   +0x068 InternalState    : 0n0
   +0x06c Mode             : 0 ( LevelSensitive )
   +0x070 Polarity         : 0 ( InterruptPolarityUnknown )
   +0x074 ServiceCount     : 0
   +0x078 DispatchCount    : 0
   +0x080 PassiveEvent     : (null) 
   +0x088 TrapFrame        : 0xfffff805`</span><span class="mi">1</span><span class="nx">ae6e520</span> <span class="nx">_KTRAP_FRAME</span>
   <span class="o">+</span><span class="mh">0x090</span> <span class="nx">DisconnectData</span>   <span class="p">:</span> <span class="p">(</span><span class="kc">null</span><span class="p">)</span> 
   <span class="o">+</span><span class="mh">0x098</span> <span class="nx">ServiceThread</span>    <span class="p">:</span> <span class="p">(</span><span class="kc">null</span><span class="p">)</span> 
   <span class="o">+</span><span class="mh">0x0a0</span> <span class="nx">ConnectionData</span>   <span class="p">:</span> <span class="mh">0xffff990e</span><span class="s2">`53931cc0 _INTERRUPT_CONNECTION_DATA
   +0x0a8 IntTrackEntry    : 0xffff990e`</span><span class="mi">532</span><span class="nx">cc500</span> <span class="nx">Void</span>
   <span class="o">+</span><span class="mh">0x0b0</span> <span class="nx">IsrDpcStats</span>      <span class="p">:</span> <span class="nx">_ISRDPCSTATS</span>
   <span class="o">+</span><span class="mh">0x110</span> <span class="nx">RedirectObject</span>   <span class="p">:</span> <span class="p">(</span><span class="kc">null</span><span class="p">)</span> 
   <span class="o">+</span><span class="mh">0x118</span> <span class="nx">PhysicalDeviceObject</span> <span class="p">:</span> <span class="mh">0xffff990e</span><span class="s2">`50fc2360 Void
</span></code></pre></div></div>

<p>Поля структуры KINTERRUPT, которые относятся к обработке прерываний:</p>

<table>
  <thead>
    <tr>
      <th style="text-align: left">Название</th>
      <th style="text-align: left">Описание</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left">DispatchAddress</td>
      <td style="text-align: left">Указатель на начальный программный обработчик прерываний в NTOSKRNL (KiChainedDispatch() ) для общих прерываний и KiInterruptDispatch() для других</td>
    </tr>
    <tr>
      <td style="text-align: left">ServiceRoutine</td>
      <td style="text-align: left">Указатель на программный обработчик прерываний, зарегистрированный драйвером с помощью API ядра IoConnectInterrupt() или IoConnectInterruptEx()</td>
    </tr>
    <tr>
      <td style="text-align: left">MessageServiceRoutine</td>
      <td style="text-align: left">Используется только для MSI (message signaled interrupts - прерывания, инициируемые сообщениями), т.е. прерывания, которые доставляются путём записи в зарезервированные участи памяти вместо переключения аппаратных линий. Эти прерывания показываются, как отрицательные числа в device manager’e. Для таких прерываний ServiceRoutine указывает на ядерную функцию KiInterruptMessageDispatch(), которая вызывает ISR, связанную с драйвером в MessageServiceRoutine</td>
    </tr>
    <tr>
      <td style="text-align: left">MessageIndex</td>
      <td style="text-align: left">Индекс MSI, передаваемый, как параметр в ISR у MessageServiceRoutine</td>
    </tr>
  </tbody>
</table>

<p>В старых версиях Windows KINTERRUPT аллоцировалась из исполняемого невыгружаемого пула памяти, так как содержала начальный код обработки, который был зарегистрирован прямо в IDT. Из-за перехода к механизму из KiIsrThunk() и KiIsrLinkage(), описанному выше, начальная заглушка для прерывания теперь находится в исполняемой памяти в NTOSKRNL и, соответственно, структуре KINTERRUPT больше не нужно быть аллоцированной из исполняемой памяти. Структуры KINTERRUPT теперь пре-аллоцируются и хранятся в списке в KPCR.Prcb.InterruptObjectPool. Функция KeAllocateInterrupt() забирает пре-аллоцированную структуру KINTERRUPT из списка, когда вызывается для аллокации новой структуры KINTERRUPT. Когда этот список заканчивается, алооцируется ещё одна страница со структурами с помощью MmAllocateIndependentPages(), и добалвяет их в список.</p>

<h4 id="interrupt-dispatching"><a href="#header-4"></a>Interrupt Dispatching</h4>

<p>Одним из важных шагов, предпринятых KiIsrLinkage, является вызов функции в KINTERRUPT.DispatchAddress, что приводит к вызову либо KiInterruptDispatch(), либо KiChainedDispatch(). Обе эти функции вызываются с указателем на структуру KINTERRUPT, как будто у них есть доступ ко всей информации, относящейся к обработке прерывания.</p>

<p>Новые системы используют APIC (Advanced Programmable Interrupt Controller) для обработки прерываний с устройств. Устройства отправляют свои прерывания на процессор с помощью IRQ линий. Однако, устройств больше, чем IRQ линий. Общие прерывания убирают проблему позволяя использовать одни и те же IRQ линии множеству устройств. Когда IRQ шарится, множество драйверов регистрирует свои ISR’ы для одного и того же IRQ и вектора прерывания. Из этого вытекает множественная структура KINTERRUPT, соответствующая устройствам, которые делят прерывание, и на них ссылаются вместе с помощью их полей KINTERRUPT.InterruptListEntry. Увидеть это можно с помощью “!idt -a”, когда одному вектору прерывания соответствует множество структур KINTERRUPT, связанных с ним. KiChainedDispatch() обрабатывает прерывания, которые шарятся с множеством устройств, а KiInterruptDispatch() обрабатывает остальные прерывания.</p>

<p>Функции KiInterruptDispatch() и KiChainedDispatch меняются в зависимости от стека прерывания процессора, указатель на который хранится в KPCR.Prb.IsrStack. Этот стек аллоцируется функцией MmAllocateIsrStack(). Размер ISR стека 0x7000 байт, как определено переменными ISR_STACK_SIZE и PAGE_SIZE в заголовочном файле ksamd64.inc WDK. Непосредственный переход на стек ISR происходит с помощью макроса SWITCH_TO_ISR_STACK и также доступен в ksamd64.inc.</p>

<p>Как только выполнение перешло на стек ISR, функции KiInterruptDispatch() и KiChainedDispatch() передают выполнение следующей стадии, вызывая KiInterruptSubDispatch() или KiScanInterruptObjectList() соответственно.</p>

<p>KiInterruptSubDispatch() вызывает KiCallInterruptServiceRoutine() для одиночной структуры KINTERRUPT.</p>

<p>KiScanInterruptObjectList() итерируется по всем объектам KINTERRUPT, зарегистрированным для одного вектора прерывания, используя список KINTERRUPT.InterruptListEntry и вызывает KiCallInterruptServiceRoutine() для каждого KINTERRUPT в цепочке.</p>

<p>KiCallInterruptServiceRoutine() выполняет следующие задачи:</p>
<ul>
  <li>Помечает прерывание, как активное в KINTERRUPT.IsrDpcStats.IsrActive</li>
  <li>Записывает время начала ISR в KINTERRUPT.IsrDpcStats.IsrTimeStart</li>
  <li>Получает спин-блокировку прерывания в KINTERRUPT.ActualLock</li>
  <li>Вызывает драйвер, зарегистрированный ISR в KINTERRUPT.ServiceRoutine</li>
  <li>Записывает длительность ISR в KINTERRUPT.IsrDpcStats.IsrTime</li>
  <li>Если ISR была прервана другой ISR с большим уровнем IRQL, он подстраивает IsrTime для точного учёта времени</li>
  <li>Помечает прерывание как неактивное в KINTERRUPT.IsrDpcStats.IsrActive</li>
  <li>Инкрементирует счётчик экземпляров прерываний в IsrCount</li>
</ul>

<p>Драйвер, который регистрировал ISR, может сообщить вызывающей функции KiCallInterruptServiceRoutine(), забрал ли он на обработку прерывание, вернув TRUE. Это становится важным в случае пошареных прерываний, где решение вызвать ISR в следующем KINTERRUPT в цепочке или нет зависит от того, забрал ли текущий ISR прерывание на обработку.
Следующая диаграмма показывает все структуры, описанные выше и отношения между ними.</p>

<p><img src="/assets/Kiinterstr.png" alt="KiInterrupt Structure" /></p>

<p>Как и в предыдущих версиях Windows 64, и IDTR, и содержимое IDT защищено PatchGuard (kernel patch protection). Делая структуру KINTERRUPT неисполняемой и удаляю код обработки из структуры, мы закрываем ещё один вектор subversion. Однако, даже с этими новыми изменениями в обработке исключений всё равно возможно для драйвера ядра хукнуть ISR в системе для реализации своего функционала, например для кейлоггера. ISR драйвера в поле KINTERRUPT.ServiceRoutine может быть заменено указателем на хук-функцию и PatchGuard этого не заметит. Так же не заметит, если KINTERRUPT, хранящийся в KPCR.Prcb.InterruptObject[] будет заменён клонированной структурой KINTERRUPT, который будет вести к выполнению кода.</p>

<p>IDT - Interrupt Descriptor Table (таблица дескрипторов прерываний)
Там хранятся элементы _KIDENTRY или _KIDENTRY64 соответственно
В каждой из них есть ссылка на ISR (Interrupt Service Routine) - непостредственно функция, которая вызывается</p>

<h3 id="вторая-статья-и-практика-практика-практика"><a href="#header-3"></a>Вторая статья и практика-практика-практика</h3>

<p>Механизм прерываний - ещё один важный элемент уровня железа</p>

<p>Прерывания можно рассматривать, как события уровня железа, использующиеся для сигнализирования процессору, что что-то требует немедленного внимания</p>
<ul>
  <li>Прерывания устройств
Устройства (сетевая карта, клавиатура и тд) вызовут прерывание, чтобы
сигнализировать процессору, что у них есть новая информация для обработки
(входящий сетевой пакет, нажатие на клавишу и тд)</li>
  <li>Ловушки / исключения
Эти вещи обычно происходят, когда процессор сталкивается с ошибкой,
такой как деление на ноль или ошибка страницы</li>
  <li>Программные прерывания
Это такие прерывания, которые генерируются программами, например INT 2E (syscall)
используется для перехода из user mode в kernel mode. INT 3 используется
для генерации программного брейкпоинта и тд Значение, которое идёт за инструкцией INT называется вектором прерывания, это просто индекс в IDT (Interrupt Descriptor Table). IDT ассоциирует вектор прерывания с конкретной функцией, которая будет обрабатывать вызванное прерывание. В WDK (Windows Driver Kit) такая функция называется ISR (Interrupt Service Routine)</li>
</ul>

<p>С точки зрения железа прерывания обрабатываются конкретным куском железа, называемым PIC (Programmable Interrupt Controller - контроллер прерываний). Сейчас у нас обычно стоит новая версия PIC - APIC (Advanced Programmable Interrupt Controller), встроенная прямо в процессов</p>

<p>Плюсы APIC:</p>
<ul>
  <li>Поддержка многопроцессорности</li>
  <li>Больше линий прерываний (256 vs 15 для PIC)</li>
</ul>

<p>Для каждого CPU свой APIC, и каждый APIC может коммуницировать с другими APIC’ами через IPI (Inter-processor interrupt message)</p>

<p>Одна большая задача в обработке прерываний, которую выполняет APIC - это управление приоритетами прерываний. Каждой линии прерываний выдан свой приоритет и APIC проверяет, что ни один входящий запрос на прерывание с приоритетом ниже или равным текущему обрабатываемому прерыванию не достигнет процессор, обычно это называют Interrupt Masking</p>

<p>Заметьте, что некоторые особые прерывания не могут был замаскированы и всегда будут достигать процессор, они называются NMI (Non-maskable interrupt). Они обычно предназначены для неустранимого сбоя оборудования, что означает, что у вас серьёзные проблемы с железом.</p>

<p>Прерывания, приходящие от устройств, сначала обрабатываются I/O APIC, специальным чипом, встроенным в чипсет, его роль - распределять прерывания по локальным APIC’ам всех CPU, таким образом включая SMP (Symmetric multiprocessing - Симметричная многопроцессорность)</p>

<p><img src="/assets/APIC.png" alt="APIC Structure" /></p>

<p>Когда прерывание достигает CPU, процессор и процедура прерывания ОС сохранят стостояние значения регистров в стеке ядра, чтобы можно было восстановить предыдущий поток выполнения и продолжить исполнение кода. Этот набор сохраняемых регистров и некотороая дополнителья информация (например код ошибки) обычно называются Trap Frame (.trap в windbg)</p>

<p>Углубимся немного в механизм обработки прерываний. Откуда процессор знает, где расположения IDT? Ответ - в регистре IDTR. 48-битный регистр делится на две части: 16-бит - IDT limit и 32-бита - base address</p>

<p>Максимальное количество записей в IDT - 256. Каждая запись - 8 бит, содержит флаги, сегментные селекторы, gate type и оффсет или адрес ISR.</p>

<p>Оффсет тоже разделён на две части: биты 0..15 - для младших битив и 48..63 - для старших битов</p>

<p>В винде IDT entry - это _KIDTENTRY</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">kd</span><span class="o">&gt;</span> <span class="nx">dt</span> <span class="nx">nt</span><span class="o">!</span><span class="nx">_KIDTENTRY</span>
   <span class="o">+</span><span class="mh">0x000</span> <span class="nx">Offset</span>           <span class="p">:</span> <span class="nx">Uint2B</span>
   <span class="o">+</span><span class="mh">0x002</span> <span class="nx">Selector</span>         <span class="p">:</span> <span class="nx">Uint2B</span>
   <span class="o">+</span><span class="mh">0x004</span> <span class="nx">Access</span>           <span class="p">:</span> <span class="nx">Uint2B</span>
   <span class="o">+</span><span class="mh">0x006</span> <span class="nx">ExtendedOffset</span>   <span class="p">:</span> <span class="nx">Uint2B</span>
</code></pre></div></div>

<p>Чтобы отобразить IDT в windbg есть !idt</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">kd</span><span class="o">&gt;</span> <span class="o">!</span><span class="nx">idt</span>

<span class="nx">Dumping</span> <span class="nx">IDT</span><span class="p">:</span> <span class="mi">8003</span><span class="nx">f400</span>

<span class="mi">30</span><span class="p">:</span>	<span class="mi">806</span><span class="nx">f5d50</span> <span class="nx">hal</span><span class="o">!</span><span class="nx">HalpClockInterrupt</span>
<span class="mi">31</span><span class="p">:</span>	<span class="mi">89</span><span class="nx">ec9044</span> <span class="nx">i8042prt</span><span class="o">!</span><span class="nc">I8042KeyboardInterruptService </span><span class="p">(</span><span class="nx">KINTERRUPT</span> <span class="mi">89</span><span class="nx">ec9008</span><span class="p">)</span>

<span class="mi">38</span><span class="p">:</span>	<span class="mi">806</span><span class="nx">efef0</span> <span class="nx">hal</span><span class="o">!</span><span class="nx">HalpProfileInterrupt</span>
<span class="mi">39</span><span class="p">:</span>	<span class="mi">89</span><span class="nx">fed174</span> <span class="nx">ACPI</span><span class="o">!</span><span class="nc">ACPIInterruptServiceRoutine </span><span class="p">(</span><span class="nx">KINTERRUPT</span> <span class="mi">89</span><span class="nx">fed138</span><span class="p">)</span>

	         <span class="nx">NDIS</span><span class="o">!</span><span class="nf">ndisMIsr </span><span class="p">(</span><span class="nx">KINTERRUPT</span> <span class="mi">89</span><span class="nx">f228d8</span><span class="p">)</span>

<span class="mi">3</span><span class="nx">a</span><span class="p">:</span>	<span class="mi">89</span><span class="nx">f24044</span> <span class="nx">VIDEOPRT</span><span class="o">!</span><span class="nf">pVideoPortInterrupt </span><span class="p">(</span><span class="nx">KINTERRUPT</span> <span class="mi">89</span><span class="nx">f24008</span><span class="p">)</span>

	         <span class="nx">USBPORT</span><span class="o">!</span><span class="nc">USBPORT_InterruptService </span><span class="p">(</span><span class="nx">KINTERRUPT</span> <span class="mi">89</span><span class="nx">eae008</span><span class="p">)</span>

<span class="mi">3</span><span class="nx">b</span><span class="p">:</span>	<span class="mi">8</span><span class="nx">a01d6c4</span> <span class="nx">VBoxGuest</span><span class="o">+</span><span class="mh">0x27c0</span> <span class="p">(</span><span class="nx">KINTERRUPT</span> <span class="mi">8</span><span class="nx">a01d688</span><span class="p">)</span>

<span class="nx">portcls</span><span class="o">!</span><span class="nx">CKsShellRequestor</span><span class="p">::</span><span class="s2">`scalar deleting destructor'+0x26 (KINTERRUPT 89f179c0)

3c:	89ead564 i8042prt!I8042MouseInterruptService (KINTERRUPT 89ead528)

3e:	89fea9d4 atapi!IdePortInterrupt (KINTERRUPT 89fea998)

3f:	8a03d044 atapi!IdePortInterrupt (KINTERRUPT 8a03d008)
</span></code></pre></div></div>

<p>Например разберём поближе i8042prt!I8042KeyboardInterruptService
Для проверки, что это такое вообще (ну вдруг мы по названию не догадались) поставим бряку на него</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">kd</span><span class="o">&gt;</span> <span class="nx">u</span> <span class="nx">i8042prt</span><span class="o">!</span><span class="nx">I8042KeyboardInterruptService</span>
<span class="nx">i8042prt</span><span class="o">!</span><span class="nx">I8042KeyboardInterruptService</span><span class="p">:</span>
<span class="nx">f76a7495</span> <span class="mi">6</span><span class="nx">a18</span>            <span class="nx">push</span>    <span class="mi">18</span><span class="nx">h</span>
<span class="nx">f76a7497</span> <span class="mi">68</span><span class="nx">a8a76af7</span>      <span class="nx">push</span>    <span class="nx">offset</span> <span class="nx">i8042prt</span><span class="o">!</span><span class="s2">`string'+0x154 (f76aa7a8)
f76a749c e8fa000000      call    i8042prt!_SEH_prolog (f76a759b)
f76a74a1 8b7d0c          mov     edi,dword ptr [ebp+0Ch]
f76a74a4 8b7728          mov     esi,dword ptr [edi+28h]
f76a74a7 837e3001        cmp     dword ptr [esi+30h],1
f76a74ab 0f8582130000    jne     i8042prt!I8042KeyboardInterruptService+0xa2 (f76a8833)
f76a74b1 a100a96af7      mov     eax,dword ptr [i8042prt!Globals (f76aa900)]

kd&gt; bu i8042prt!I8042KeyboardInterruptService

kd&gt; bl
     0 e Disable Clear  f76a7495     0001 (0001) i8042prt!I8042KeyboardInterruptService
kd&gt; g

Breakpoint 0 hit
i8042prt!I8042KeyboardInterruptService:
f76a7495 6a18            push    18h
</span></code></pre></div></div>

<p><img src="/assets/kisbreak.png" alt="KIS Structure" /></p>

<p>Мы нажали на любую кнопку –&gt; наш брейкпоинт сработал</p>

<p>Но давайте доберёмся до кода в статике, ведь то, что написано в выводе команды !idt (31: 89ec9044 i8042prt! …) не совпадает с фактическим адресом ISR
Каждый элемент IDT занимает 8 байт, мы решили, что нам нужен индекс 31 (такой индекс у нужной нам функции), что нам нужно сделать?</p>

<p>idtr + 0x31 * 8 –&gt;</p>
<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">kd</span><span class="o">&gt;</span> <span class="nx">r</span> <span class="nx">idtr</span>
<span class="nx">idtr</span><span class="o">=</span><span class="mi">8003</span><span class="nx">f400</span>

<span class="nx">kd</span><span class="o">&gt;</span> <span class="nx">dd</span> <span class="p">@</span><span class="nd">idtr</span><span class="o">+</span><span class="mi">8</span><span class="o">*</span><span class="mh">0x31</span>
<span class="mi">8003</span><span class="nx">f588</span> <span class="o">-</span> <span class="mi">00089044</span> <span class="mi">89</span><span class="nx">ec8e00</span> <span class="mi">0008</span><span class="nx">dd14</span> <span class="mi">804</span><span class="nx">d8e00</span> <span class="o">--&gt;</span> <span class="mh">0x89ec9044</span>
<span class="mi">8003</span><span class="nx">f598</span> <span class="o">-</span> <span class="mi">0008</span><span class="nx">dd1e</span> <span class="mi">804</span><span class="nx">d8e00</span> <span class="mi">0008</span><span class="nx">dd28</span> <span class="mi">804</span><span class="nx">d8e00</span>
<span class="mi">8003</span><span class="nx">f5a8</span> <span class="o">-</span> <span class="mi">0008</span><span class="nx">dd32</span> <span class="mi">804</span><span class="nx">d8e00</span> <span class="mi">0008</span><span class="nx">dd3c</span> <span class="mi">804</span><span class="nx">d8e00</span>
<span class="mi">8003</span><span class="nx">f5b8</span> <span class="o">-</span> <span class="mi">0008</span><span class="nx">dd46</span> <span class="mi">804</span><span class="nx">d8e00</span> <span class="mi">0008</span><span class="nx">fef0</span> <span class="mi">806</span><span class="nx">e8e00</span>
<span class="mi">8003</span><span class="nx">f5c8</span> <span class="o">-</span> <span class="mi">0008</span><span class="nx">d174</span> <span class="mi">89</span><span class="nx">fe8e00</span> <span class="mi">00084044</span> <span class="mi">89</span><span class="nx">f28e00</span>
<span class="mi">8003</span><span class="nx">f5d8</span> <span class="o">-</span> <span class="mi">0008</span><span class="nx">d6c4</span> <span class="mi">8</span><span class="nx">a018e00</span> <span class="mi">0008</span><span class="nx">d564</span> <span class="mi">89</span><span class="nx">ea8e00</span>
<span class="mi">8003</span><span class="nx">f5e8</span> <span class="o">-</span> <span class="mi">0008</span><span class="nx">dd82</span> <span class="mi">804</span><span class="nx">d8e00</span> <span class="mi">0008</span><span class="nx">a9d4</span> <span class="mi">89</span><span class="nx">fe8e00</span>
<span class="mi">8003</span><span class="nx">f5f8</span> <span class="o">-</span> <span class="mi">0008</span><span class="nx">d044</span> <span class="mi">8</span><span class="nx">a038e00</span> <span class="mi">0008</span><span class="nx">dda0</span> <span class="mi">804</span><span class="nx">d8e00</span>

</code></pre></div></div>

<p>И так наш ISR адрес 0x89ec9044, но мы же вроде бы только что дампили I8042KeyboardInterruptService и его адрес был 0xf76a7495, непонятно</p>

<p>Чтож, перед тем, как вызывать ISR’ры драйверов системе нужно выполнить некоторые задачи: маскирование прерываний с более низким приоритетом в APIC, поднятие уровня IRQL и тд</p>

<p>Так что вместо того, чтобы заполнить IDT ISR’ами, система заполняет их glue кодом или же иначе функциями-темплейтами</p>

<p>Каждая темплейт-функция взята (скопирована) из KiInterruptTemplate функции и динамически модифицирована, чтобы подходить соответствующему ISR’у</p>

<p>Давайте посмотрим на темплейт нашей KeyboardInterruptService:
<img src="/assets/KiInterruptTemplate.png" alt="KiInterruptTemplate Structure" /></p>

<p>Мы можем заметить, что почти весь код скопирован с оригинального KiInterruptTemplate. Однако есть одна интересная особенность:
темплейт функции клавиатуры вызывает KiInterruptDispatch и кладёт в EDI адрес 0x89EC9008</p>

<p>Этот адрес указывает на interrupt object с типом _KINTERRUPT:</p>
<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">kd</span><span class="o">&gt;</span> <span class="nx">dt</span> <span class="nx">nt</span><span class="o">!</span><span class="nx">_KINTERRUPT</span> <span class="mh">0x89EC9008</span>
   <span class="o">+</span><span class="mh">0x000</span> <span class="nx">Type</span>             <span class="p">:</span> <span class="mi">0</span><span class="nx">n22</span>
   <span class="o">+</span><span class="mh">0x002</span> <span class="nx">Size</span>             <span class="p">:</span> <span class="mi">0</span><span class="nx">n484</span>
   <span class="o">+</span><span class="mh">0x004</span> <span class="nx">InterruptListEntry</span> <span class="p">:</span> <span class="nx">_LIST_ENTRY</span> <span class="p">[</span> <span class="mh">0x89ec900c</span> <span class="o">-</span> <span class="mh">0x89ec900c</span> <span class="p">]</span>
   <span class="o">+</span><span class="mh">0x00c</span> <span class="nx">ServiceRoutine</span>   <span class="p">:</span> <span class="mh">0xf76a7495</span>     <span class="nx">unsigned</span> <span class="nx">char</span>  <span class="nx">i8042prt</span><span class="o">!</span><span class="nx">I8042KeyboardInterruptService</span><span class="o">+</span><span class="mi">0</span>
   <span class="o">+</span><span class="mh">0x010</span> <span class="nx">ServiceContext</span>   <span class="p">:</span> <span class="mh">0x89f259d0</span> <span class="nx">Void</span>
   <span class="o">+</span><span class="mh">0x014</span> <span class="nx">SpinLock</span>         <span class="p">:</span> <span class="mi">0</span>
   <span class="o">+</span><span class="mh">0x018</span> <span class="nx">TickCount</span>        <span class="p">:</span> <span class="mh">0xffffffff</span>
   <span class="o">+</span><span class="mh">0x01c</span> <span class="nx">ActualLock</span>       <span class="p">:</span> <span class="mh">0x89f25a90</span>  <span class="o">-&gt;</span> <span class="mi">0</span>
   <span class="o">+</span><span class="mh">0x020</span> <span class="nx">DispatchAddress</span>  <span class="p">:</span> <span class="mh">0x804da8e8</span>     <span class="k">void</span>  <span class="nx">nt</span><span class="o">!</span><span class="nx">KiInterruptDispatch</span><span class="o">+</span><span class="mi">0</span>
   <span class="o">+</span><span class="mh">0x024</span> <span class="nx">Vector</span>           <span class="p">:</span> <span class="mh">0x31</span>
   <span class="o">+</span><span class="mh">0x028</span> <span class="nx">Irql</span>             <span class="p">:</span> <span class="mh">0x1a</span> <span class="dl">''</span>
   <span class="o">+</span><span class="mh">0x029</span> <span class="nx">SynchronizeIrql</span>  <span class="p">:</span> <span class="mh">0x1a</span> <span class="dl">''</span>
   <span class="o">+</span><span class="mh">0x02a</span> <span class="nx">FloatingSave</span>     <span class="p">:</span> <span class="mi">0</span> <span class="dl">''</span>
   <span class="o">+</span><span class="mh">0x02b</span> <span class="nx">Connected</span>        <span class="p">:</span> <span class="mh">0x1</span> <span class="dl">''</span>
   <span class="o">+</span><span class="mh">0x02c</span> <span class="nb">Number</span>           <span class="p">:</span> <span class="mi">0</span> <span class="dl">''</span>
   <span class="o">+</span><span class="mh">0x02d</span> <span class="nx">ShareVector</span>      <span class="p">:</span> <span class="mi">0</span> <span class="dl">''</span>
   <span class="o">+</span><span class="mh">0x030</span> <span class="nx">Mode</span>             <span class="p">:</span> <span class="mi">1</span> <span class="p">(</span> <span class="nx">Latched</span> <span class="p">)</span>
   <span class="o">+</span><span class="mh">0x034</span> <span class="nx">ServiceCount</span>     <span class="p">:</span> <span class="mi">0</span>
   <span class="o">+</span><span class="mh">0x038</span> <span class="nx">DispatchCount</span>    <span class="p">:</span> <span class="mh">0xffffffff</span>
   <span class="o">+</span><span class="mh">0x03c</span> <span class="nx">DispatchCode</span>     <span class="p">:</span> <span class="p">[</span><span class="mi">106</span><span class="p">]</span> <span class="mh">0x56535554</span>
</code></pre></div></div>

<p>Как видно выше, как раз в ServiceRoutine хранится адрес ISR
Если мы теперь посмотрим на KiInterruptDispatch мы увидим, что он вызывает interrupt object ServiceRoutine</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">kd</span><span class="o">&gt;</span> <span class="nx">u</span> <span class="nx">nt</span><span class="o">!</span><span class="nx">KiInterruptDispatch</span> <span class="nx">L30</span>
<span class="nx">nt</span><span class="o">!</span><span class="nx">KiInterruptDispatch</span><span class="p">:</span>
<span class="mi">804</span><span class="nx">da8e8</span> <span class="nx">ff05c4f5dfff</span>    <span class="nx">inc</span>     <span class="nx">dword</span> <span class="nx">ptr</span> <span class="nx">ds</span><span class="p">:[</span><span class="mi">0</span><span class="nx">FFDFF5C4h</span><span class="p">]</span>
<span class="mi">804</span><span class="nx">da8ee</span> <span class="mi">8</span><span class="nx">bec</span>            <span class="nx">mov</span>     <span class="nx">ebp</span><span class="p">,</span><span class="nx">esp</span>
<span class="mi">804</span><span class="nx">da8f0</span> <span class="mi">8</span><span class="nx">b4724</span>          <span class="nx">mov</span>     <span class="nx">eax</span><span class="p">,</span><span class="nx">dword</span> <span class="nx">ptr</span> <span class="p">[</span><span class="nx">edi</span><span class="o">+</span><span class="mi">24</span><span class="nx">h</span><span class="p">]</span>
<span class="mi">804</span><span class="nx">da8f3</span> <span class="mi">8</span><span class="nx">b4f29</span>          <span class="nx">mov</span>     <span class="nx">ecx</span><span class="p">,</span><span class="nx">dword</span> <span class="nx">ptr</span> <span class="p">[</span><span class="nx">edi</span><span class="o">+</span><span class="mi">29</span><span class="nx">h</span><span class="p">]</span>
<span class="mi">804</span><span class="nx">da8f6</span> <span class="mi">50</span>              <span class="nx">push</span>    <span class="nx">eax</span>
<span class="mi">804</span><span class="nx">da8f7</span> <span class="mi">83</span><span class="nx">ec04</span>          <span class="nx">sub</span>     <span class="nx">esp</span><span class="p">,</span><span class="mi">4</span>
<span class="mi">804</span><span class="nx">da8fa</span> <span class="mi">54</span>              <span class="nx">push</span>    <span class="nx">esp</span>
<span class="mi">804</span><span class="nx">da8fb</span> <span class="mi">50</span>              <span class="nx">push</span>    <span class="nx">eax</span>
<span class="mi">804</span><span class="nx">da8fc</span> <span class="mi">51</span>              <span class="nx">push</span>    <span class="nx">ecx</span>
<span class="mi">804</span><span class="nx">da8fd</span> <span class="nx">ff1504764d80</span>    <span class="nx">call</span>    <span class="nx">dword</span> <span class="nx">ptr</span> <span class="p">[</span><span class="nx">nt</span><span class="o">!</span><span class="nf">_imp__HalBeginSystemInterrupt </span><span class="p">(</span><span class="mi">804</span><span class="nx">d7604</span><span class="p">)]</span>
<span class="mi">804</span><span class="nx">da903</span> <span class="mi">0</span><span class="nx">bc0</span>            <span class="nx">or</span>      <span class="nx">eax</span><span class="p">,</span><span class="nx">eax</span>
<span class="mi">804</span><span class="nx">da905</span> <span class="mi">7436</span>            <span class="nx">je</span>      <span class="nx">nt</span><span class="o">!</span><span class="nx">KiInterruptDispatch</span><span class="o">+</span><span class="mh">0x55</span> <span class="p">(</span><span class="mi">804</span><span class="nx">da93d</span><span class="p">)</span>
<span class="mi">804</span><span class="nx">da907</span> <span class="mi">83</span><span class="nx">ec0c</span>          <span class="nx">sub</span>     <span class="nx">esp</span><span class="p">,</span><span class="mi">0</span><span class="nx">Ch</span>
<span class="mi">804</span><span class="nx">da90a</span> <span class="mi">833</span><span class="nx">d0c23568000</span>  <span class="nx">cmp</span>     <span class="nx">dword</span> <span class="nx">ptr</span> <span class="p">[</span><span class="nx">nt</span><span class="o">!</span><span class="nc">PPerfGlobalGroupMask </span><span class="p">(</span><span class="mi">8056230</span><span class="nx">c</span><span class="p">)],</span><span class="mi">0</span>
<span class="mi">804</span><span class="nx">da911</span> <span class="nx">c745f400000000</span>  <span class="nx">mov</span>     <span class="nx">dword</span> <span class="nx">ptr</span> <span class="p">[</span><span class="nx">ebp</span><span class="o">-</span><span class="mi">0</span><span class="nx">Ch</span><span class="p">],</span><span class="mi">0</span>
<span class="mi">804</span><span class="nx">da918</span> <span class="mi">752</span><span class="nx">b</span>            <span class="nx">jne</span>     <span class="nx">nt</span><span class="o">!</span><span class="nx">KiInterruptDispatch</span><span class="o">+</span><span class="mh">0x5d</span> <span class="p">(</span><span class="mi">804</span><span class="nx">da945</span><span class="p">)</span>
<span class="mi">804</span><span class="nx">da91a</span> <span class="mi">8</span><span class="nx">b771c</span>          <span class="nx">mov</span>     <span class="nx">esi</span><span class="p">,</span><span class="nx">dword</span> <span class="nx">ptr</span> <span class="p">[</span><span class="nx">edi</span><span class="o">+</span><span class="mi">1</span><span class="nx">Ch</span><span class="p">]</span>
<span class="mi">804</span><span class="nx">da91d</span> <span class="mi">8</span><span class="nx">b4710</span>          <span class="nx">mov</span>     <span class="nx">eax</span><span class="p">,</span><span class="nx">dword</span> <span class="nx">ptr</span> <span class="p">[</span><span class="nx">edi</span><span class="o">+</span><span class="mi">10</span><span class="nx">h</span><span class="p">]</span>
<span class="mi">804</span><span class="nx">da920</span> <span class="mi">50</span>              <span class="nx">push</span>    <span class="nx">eax</span>
<span class="mi">804</span><span class="nx">da921</span> <span class="mi">57</span>              <span class="nx">push</span>    <span class="nx">edi</span>
<span class="mi">804</span><span class="nx">da922</span> <span class="nx">ff570c</span>          <span class="nx">call</span>    <span class="nx">dword</span> <span class="nx">ptr</span> <span class="p">[</span><span class="nx">edi</span><span class="o">+</span><span class="mi">0</span><span class="nx">Ch</span><span class="p">]</span>

<span class="nx">kd</span><span class="o">&gt;</span> <span class="nx">dt</span> <span class="nx">nt</span><span class="o">!</span><span class="nx">_KINTERRUPT</span> <span class="mh">0x89EC9008</span>
<span class="p">...</span>
   <span class="o">+</span><span class="mh">0x00c</span> <span class="nx">ServiceRoutine</span>   <span class="p">:</span> <span class="mh">0xf76a7495</span>     <span class="nx">unsigned</span> <span class="nx">char</span>  <span class="nx">i8042prt</span><span class="o">!</span><span class="nx">I8042KeyboardInterruptService</span><span class="o">+</span><span class="mi">0</span>
<span class="p">...</span>
</code></pre></div></div>

<p>Вся структура вызовов:
<img src="/assets/interruptcallstr.png" alt="Interrupt Call Structure" /></p>

<p>И как создаётся interrupt object?</p>

<p>Это роль драйвера заполнить структуру, вызвав IoConnectInterrupt</p>

<h4 id="добавим-ещё-немного-экспериментов"><a href="#header-4"></a>Добавим ещё немного экспериментов:</h4>

<p>Давайте посмотрим на прерывание и исключение деления на ноль</p>

<p>Оно у нас самое первое в таблице IDT</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">kd</span><span class="o">&gt;</span> <span class="o">!</span><span class="nx">idt</span> <span class="o">-</span><span class="nx">a</span>

<span class="nx">Dumping</span> <span class="nx">IDT</span><span class="p">:</span> <span class="mi">8003</span><span class="nx">f400</span>

<span class="mi">00</span><span class="p">:</span>	<span class="mi">804</span><span class="nx">df370</span> <span class="nx">nt</span><span class="o">!</span><span class="nx">KiTrap00</span>
<span class="mi">01</span><span class="p">:</span>	<span class="mi">804</span><span class="nx">df4eb</span> <span class="nx">nt</span><span class="o">!</span><span class="nx">KiTrap01</span>
<span class="mi">02</span><span class="p">:</span>	<span class="nx">Task</span> <span class="nx">Selector</span> <span class="o">=</span> <span class="mh">0x0000</span>
<span class="mi">03</span><span class="p">:</span>	<span class="mi">804</span><span class="nx">df8bd</span> <span class="nx">nt</span><span class="o">!</span><span class="nx">KiTrap03</span>
<span class="mi">04</span><span class="p">:</span>	<span class="mi">804</span><span class="nx">dfa40</span> <span class="nx">nt</span><span class="o">!</span><span class="nx">KiTrap04</span>
<span class="mi">05</span><span class="p">:</span>	<span class="mi">804</span><span class="nx">dfba1</span> <span class="nx">nt</span><span class="o">!</span><span class="nx">KiTrap05</span>
<span class="mi">06</span><span class="p">:</span>	<span class="mi">804</span><span class="nx">dfd22</span> <span class="nx">nt</span><span class="o">!</span><span class="nx">KiTrap06</span>
<span class="mi">07</span><span class="p">:</span>	<span class="mi">804</span><span class="nx">e038a</span> <span class="nx">nt</span><span class="o">!</span><span class="nx">KiTrap07</span>
</code></pre></div></div>

<p>Поставим бряку <code class="language-plaintext highlighter-rouge">bu nt!KiTrap00</code></p>

<p>И на машине скомпилим какой-нибудь такой код:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;Windows.h&gt;</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">sleep</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
	<span class="n">printf</span><span class="p">(</span><span class="s">"Go!</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">y</span><span class="p">;</span>
	<span class="n">scanf</span><span class="p">(</span><span class="s">"%f"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">y</span><span class="p">);</span>
	<span class="n">printf</span><span class="p">(</span><span class="s">"%f"</span><span class="p">,</span>  <span class="n">x</span> <span class="o">/</span> <span class="n">y</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Вводим ноль и Viola! брякаемся</p>
<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">kd</span><span class="o">&gt;</span> <span class="o">!</span><span class="nx">process</span> <span class="mi">0</span> <span class="mi">0</span>
<span class="nx">Failed</span> <span class="nx">to</span> <span class="kd">get</span> <span class="nx">VadRoot</span>
<span class="nx">PROCESS</span> <span class="mi">897</span><span class="nx">cf578</span>  <span class="nx">SessionId</span><span class="p">:</span> <span class="mi">0</span>  <span class="nx">Cid</span><span class="p">:</span> <span class="mi">06</span><span class="nx">ac</span>    <span class="nx">Peb</span><span class="p">:</span> <span class="mi">7</span><span class="nx">ffdc000</span>  <span class="nx">ParentCid</span><span class="p">:</span> <span class="mi">0</span><span class="nx">e48</span>
    <span class="nx">DirBase</span><span class="p">:</span> <span class="mi">825</span><span class="nx">e9000</span>  <span class="nx">ObjectTable</span><span class="p">:</span> <span class="nx">e2c24c78</span>  <span class="nx">HandleCount</span><span class="p">:</span>   <span class="mi">7</span><span class="p">.</span>
    <span class="nx">Image</span><span class="p">:</span> <span class="nx">Untitled1</span><span class="p">.</span><span class="nx">exe</span>
    
<span class="nx">kd</span><span class="o">&gt;</span> <span class="p">.</span><span class="nx">process</span> <span class="o">/</span><span class="nx">i</span> <span class="mi">897</span><span class="nx">cf578</span> 
<span class="nx">You</span> <span class="nx">need</span> <span class="nx">to</span> <span class="k">continue</span> <span class="nf">execution </span><span class="p">(</span><span class="nx">press</span> <span class="dl">'</span><span class="s1">g</span><span class="dl">'</span> <span class="o">&lt;</span><span class="nx">enter</span><span class="o">&gt;</span><span class="p">)</span> <span class="k">for</span> <span class="nx">the</span> <span class="nx">context</span>
<span class="nx">to</span> <span class="nx">be</span> <span class="nx">switched</span><span class="p">.</span> <span class="nx">When</span> <span class="nx">the</span> <span class="k">debugger</span> <span class="nx">breaks</span> <span class="k">in</span> <span class="nx">again</span><span class="p">,</span> <span class="nx">you</span> <span class="nx">will</span> <span class="nx">be</span> <span class="k">in</span>
<span class="nx">the</span> <span class="k">new</span> <span class="nx">process</span> <span class="nx">context</span><span class="p">.</span>
<span class="nx">ReadVirtual</span><span class="p">:</span> <span class="mi">8</span><span class="nx">a01c688</span> <span class="nx">not</span> <span class="nx">properly</span> <span class="nx">sign</span> <span class="nx">extended</span>

<span class="nx">kd</span><span class="o">&gt;</span> <span class="nx">g</span>
<span class="nx">Break</span> <span class="nx">instruction</span> <span class="nx">exception</span> <span class="o">-</span> <span class="nx">code</span> <span class="mi">80000003</span> <span class="p">(</span><span class="nx">first</span> <span class="nx">chance</span><span class="p">)</span>
<span class="nx">nt</span><span class="o">!</span><span class="nx">RtlpBreakWithStatusInstruction</span><span class="p">:</span>
<span class="mi">804</span><span class="nx">e351a</span> <span class="nx">cc</span>              <span class="nx">int</span>     <span class="mi">3</span>
<span class="nx">ReadVirtual</span><span class="p">:</span> <span class="mi">8</span><span class="nx">a01c688</span> <span class="nx">not</span> <span class="nx">properly</span> <span class="nx">sign</span> <span class="nx">extended</span>

<span class="mi">00401500</span> <span class="mi">55</span>              <span class="nx">push</span>    <span class="nx">ebp</span>
<span class="mi">00401501</span> <span class="mi">89</span><span class="nx">e5</span>            <span class="nx">mov</span>     <span class="nx">ebp</span><span class="p">,</span><span class="nx">esp</span>
<span class="mi">00401503</span> <span class="mi">83</span><span class="nx">e4f0</span>          <span class="nx">and</span>     <span class="nx">esp</span><span class="p">,</span><span class="mi">0</span><span class="nx">FFFFFFF0h</span>
<span class="mi">00401506</span> <span class="mi">83</span><span class="nx">ec20</span>          <span class="nx">sub</span>     <span class="nx">esp</span><span class="p">,</span><span class="mi">20</span><span class="nx">h</span>
<span class="mi">00401509</span> <span class="nx">e8b2090000</span>      <span class="nx">call</span>    <span class="mi">00401</span><span class="nx">ec0</span>
<span class="mi">0040150</span><span class="nx">e</span> <span class="nx">c7042405000000</span>  <span class="nx">mov</span>     <span class="nx">dword</span> <span class="nx">ptr</span> <span class="p">[</span><span class="nx">esp</span><span class="p">],</span><span class="mi">5</span>
<span class="mi">00401515</span> <span class="nx">e8b6100000</span>      <span class="nx">call</span>    <span class="mi">004025</span><span class="nx">d0</span>
<span class="mi">0040151</span><span class="nx">a</span> <span class="nx">c7042400404000</span>  <span class="nx">mov</span>     <span class="nx">dword</span> <span class="nx">ptr</span> <span class="p">[</span><span class="nx">esp</span><span class="p">],</span><span class="mi">404000</span><span class="nx">h</span>
<span class="mi">00401521</span> <span class="nx">e832110000</span>      <span class="nx">call</span>    <span class="mi">00402658</span>                    <span class="o">&lt;--</span> <span class="nf">printf</span><span class="p">(</span><span class="dl">"</span><span class="s2">Go!</span><span class="se">\n</span><span class="dl">"</span><span class="p">)</span>
<span class="mi">00401526</span> <span class="nx">c744241c0a000000</span> <span class="nx">mov</span>     <span class="nx">dword</span> <span class="nx">ptr</span> <span class="p">[</span><span class="nx">esp</span><span class="o">+</span><span class="mi">1</span><span class="nx">Ch</span><span class="p">],</span><span class="mi">0</span><span class="nx">Ah</span>
<span class="mi">0040152</span><span class="nx">e</span> <span class="mi">8</span><span class="nx">d442418</span>        <span class="nx">lea</span>     <span class="nx">eax</span><span class="p">,[</span><span class="nx">esp</span><span class="o">+</span><span class="mi">18</span><span class="nx">h</span><span class="p">]</span>
<span class="mi">00401532</span> <span class="mi">89442404</span>        <span class="nx">mov</span>     <span class="nx">dword</span> <span class="nx">ptr</span> <span class="p">[</span><span class="nx">esp</span><span class="o">+</span><span class="mi">4</span><span class="p">],</span><span class="nx">eax</span>
<span class="mi">00401536</span> <span class="nx">c7042404404000</span>  <span class="nx">mov</span>     <span class="nx">dword</span> <span class="nx">ptr</span> <span class="p">[</span><span class="nx">esp</span><span class="p">],</span><span class="mi">404004</span><span class="nx">h</span>
<span class="mi">0040153</span><span class="nx">d</span> <span class="nx">e81e110000</span>      <span class="nx">call</span>    <span class="mi">00402660</span>                    <span class="o">&lt;--</span> <span class="nx">scanf</span>
<span class="mi">00401542</span> <span class="mi">8</span><span class="nx">bd9</span>            <span class="nx">mov</span>     <span class="nx">ebx</span><span class="p">,</span><span class="nx">ecx</span>
<span class="mi">00401544</span> <span class="mi">2418</span>            <span class="nx">and</span>     <span class="nx">al</span><span class="p">,</span><span class="mi">18</span><span class="nx">h</span>
<span class="mi">00401546</span> <span class="mi">8</span><span class="nx">b44241c</span>        <span class="nx">mov</span>     <span class="nx">eax</span><span class="p">,</span><span class="nx">dword</span> <span class="nx">ptr</span> <span class="p">[</span><span class="nx">esp</span><span class="o">+</span><span class="mi">1</span><span class="nx">Ch</span><span class="p">]</span>
<span class="mi">0040154</span><span class="nx">a</span> <span class="mi">99</span>              <span class="nx">cdq</span>
<span class="mi">0040154</span><span class="nx">b</span> <span class="nx">f7f9</span>            <span class="nx">idiv</span>    <span class="nx">eax</span><span class="p">,</span><span class="nx">ecx</span>
<span class="mi">0040154</span><span class="nx">d</span> <span class="mi">89442404</span>        <span class="nx">mov</span>     <span class="nx">dword</span> <span class="nx">ptr</span> <span class="p">[</span><span class="nx">esp</span><span class="o">+</span><span class="mi">4</span><span class="p">],</span><span class="nx">eax</span>
<span class="mi">00401551</span> <span class="nx">c7042404404000</span>  <span class="nx">mov</span>     <span class="nx">dword</span> <span class="nx">ptr</span> <span class="p">[</span><span class="nx">esp</span><span class="p">],</span><span class="mi">404004</span><span class="nx">h</span>
<span class="mi">00401558</span> <span class="nx">e80b110000</span>      <span class="nx">call</span>    <span class="mi">00402668</span>
<span class="mi">0040155</span><span class="nx">d</span> <span class="nx">b800000000</span>      <span class="nx">mov</span>     <span class="nx">eax</span><span class="p">,</span><span class="mi">0</span>
<span class="mi">00401562</span> <span class="nx">c9</span>              <span class="nx">leave</span>
</code></pre></div></div>

<p>Падаем в обработку
<img src="/assets/KiTrap.png" alt="KiTrap Structure" /></p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">...</span>
<span class="mi">804</span><span class="nx">df3ea</span> <span class="mi">55</span>              <span class="nx">push</span>    <span class="nx">ebp</span>
<span class="mi">804</span><span class="nx">df3eb</span> <span class="nx">e8b6431400</span>      <span class="nx">call</span>    <span class="nx">nt</span><span class="o">!</span><span class="nc">Ki386CheckDivideByZeroTrap </span><span class="p">(</span><span class="mi">806237</span><span class="nx">a6</span><span class="p">)</span>
<span class="p">...</span>
</code></pre></div></div>

<h3 id="посмотрим-на-64-битную-10-ку"><a href="#header-3"></a>Посмотрим на 64-битную 10-ку</h3>

<p>Тут всё выглядит поинтереснее, мб из-за отсутствия дебаг символом на XP’хе, а мб и нет</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">kd</span><span class="o">&gt;</span> <span class="o">!</span><span class="nx">idt</span>

<span class="nx">Dumping</span> <span class="nx">IDT</span><span class="p">:</span> <span class="nx">fffff80335462000</span>

<span class="mi">00</span><span class="p">:</span>	<span class="nx">fffff80330a01c00</span> <span class="nx">nt</span><span class="o">!</span><span class="nx">KiDivideErrorFault</span>
<span class="mi">01</span><span class="p">:</span>	<span class="nx">fffff80330a01f40</span> <span class="nx">nt</span><span class="o">!</span><span class="nx">KiDebugTrapOrFault</span>	<span class="nx">Stack</span> <span class="o">=</span> <span class="mh">0xFFFFF803354A0000</span>
<span class="mi">02</span><span class="p">:</span>	<span class="nx">fffff80330a02440</span> <span class="nx">nt</span><span class="o">!</span><span class="nx">KiNmiInterrupt</span>	<span class="nx">Stack</span> <span class="o">=</span> <span class="mh">0xFFFFF80335492000</span>
<span class="mi">03</span><span class="p">:</span>	<span class="nx">fffff80330a02900</span> <span class="nx">nt</span><span class="o">!</span><span class="nx">KiBreakpointTrap</span>
<span class="mi">04</span><span class="p">:</span>	<span class="nx">fffff80330a02c40</span> <span class="nx">nt</span><span class="o">!</span><span class="nx">KiOverflowTrap</span>
<span class="mi">05</span><span class="p">:</span>	<span class="nx">fffff80330a02f80</span> <span class="nx">nt</span><span class="o">!</span><span class="nx">KiBoundFault</span>
<span class="mi">06</span><span class="p">:</span>	<span class="nx">fffff80330a034c0</span> <span class="nx">nt</span><span class="o">!</span><span class="nx">KiInvalidOpcodeFault</span>
<span class="mi">07</span><span class="p">:</span>	<span class="nx">fffff80330a039c0</span> <span class="nx">nt</span><span class="o">!</span><span class="nx">KiNpxNotAvailableFault</span>
<span class="mi">08</span><span class="p">:</span>	<span class="nx">fffff80330a03cc0</span> <span class="nx">nt</span><span class="o">!</span><span class="nx">KiDoubleFaultAbort</span>	<span class="nx">Stack</span> <span class="o">=</span> <span class="mh">0xFFFFF8033548B000</span>
<span class="mi">09</span><span class="p">:</span>	<span class="nx">fffff80330a03fc0</span> <span class="nx">nt</span><span class="o">!</span><span class="nx">KiNpxSegmentOverrunAbort</span>
<span class="mi">0</span><span class="nx">a</span><span class="p">:</span>	<span class="nx">fffff80330a042c0</span> <span class="nx">nt</span><span class="o">!</span><span class="nx">KiInvalidTssFault</span>
<span class="mi">0</span><span class="nx">b</span><span class="p">:</span>	<span class="nx">fffff80330a045c0</span> <span class="nx">nt</span><span class="o">!</span><span class="nx">KiSegmentNotPresentFault</span>
<span class="mi">0</span><span class="nx">c</span><span class="p">:</span>	<span class="nx">fffff80330a04980</span> <span class="nx">nt</span><span class="o">!</span><span class="nx">KiStackFault</span>
<span class="mi">0</span><span class="nx">d</span><span class="p">:</span>	<span class="nx">fffff80330a04cc0</span> <span class="nx">nt</span><span class="o">!</span><span class="nx">KiGeneralProtectionFault</span>
<span class="mi">0</span><span class="nx">e</span><span class="p">:</span>	<span class="nx">fffff80330a05000</span> <span class="nx">nt</span><span class="o">!</span><span class="nx">KiPageFault</span>
<span class="mi">10</span><span class="p">:</span>	<span class="nx">fffff80330a05640</span> <span class="nx">nt</span><span class="o">!</span><span class="nx">KiFloatingErrorFault</span>
<span class="mi">11</span><span class="p">:</span>	<span class="nx">fffff80330a05a00</span> <span class="nx">nt</span><span class="o">!</span><span class="nx">KiAlignmentFault</span>
<span class="mi">12</span><span class="p">:</span>	<span class="nx">fffff80330a05d40</span> <span class="nx">nt</span><span class="o">!</span><span class="nx">KiMcheckAbort</span>	<span class="nx">Stack</span> <span class="o">=</span> <span class="mh">0xFFFFF80335499000</span>
<span class="mi">13</span><span class="p">:</span>	<span class="nx">fffff80330a06840</span> <span class="nx">nt</span><span class="o">!</span><span class="nx">KiXmmException</span>
<span class="mi">14</span><span class="p">:</span>	<span class="nx">fffff80330a06c00</span> <span class="nx">nt</span><span class="o">!</span><span class="nx">KiVirtualizationException</span>
<span class="mi">15</span><span class="p">:</span>	<span class="nx">fffff80330a07100</span> <span class="nx">nt</span><span class="o">!</span><span class="nx">KiControlProtectionFault</span>
<span class="mi">1</span><span class="nx">f</span><span class="p">:</span>	<span class="nx">fffff803309fb220</span> <span class="nx">nt</span><span class="o">!</span><span class="nx">KiApcInterrupt</span>
<span class="mi">20</span><span class="p">:</span>	<span class="nx">fffff803309fce00</span> <span class="nx">nt</span><span class="o">!</span><span class="nx">KiSwInterrupt</span>
<span class="mi">29</span><span class="p">:</span>	<span class="nx">fffff80330a07600</span> <span class="nx">nt</span><span class="o">!</span><span class="nx">KiRaiseSecurityCheckFailure</span>
<span class="mi">2</span><span class="nx">c</span><span class="p">:</span>	<span class="nx">fffff80330a07940</span> <span class="nx">nt</span><span class="o">!</span><span class="nx">KiRaiseAssertion</span>
<span class="mi">2</span><span class="nx">d</span><span class="p">:</span>	<span class="nx">fffff80330a07c80</span> <span class="nx">nt</span><span class="o">!</span><span class="nx">KiDebugServiceTrap</span>
<span class="mi">2</span><span class="nx">f</span><span class="p">:</span>	<span class="nx">fffff803309fd3c0</span> <span class="nx">nt</span><span class="o">!</span><span class="nx">KiDpcInterrupt</span>
<span class="mi">30</span><span class="p">:</span>	<span class="nx">fffff803309fb7c0</span> <span class="nx">nt</span><span class="o">!</span><span class="nx">KiHvInterrupt</span>
<span class="mi">31</span><span class="p">:</span>	<span class="nx">fffff803309fbaa0</span> <span class="nx">nt</span><span class="o">!</span><span class="nx">KiVmbusInterrupt0</span>
<span class="mi">32</span><span class="p">:</span>	<span class="nx">fffff803309fbd80</span> <span class="nx">nt</span><span class="o">!</span><span class="nx">KiVmbusInterrupt1</span>
<span class="mi">33</span><span class="p">:</span>	<span class="nx">fffff803309fc060</span> <span class="nx">nt</span><span class="o">!</span><span class="nx">KiVmbusInterrupt2</span>
<span class="mi">34</span><span class="p">:</span>	<span class="nx">fffff803309fc340</span> <span class="nx">nt</span><span class="o">!</span><span class="nx">KiVmbusInterrupt3</span>
<span class="mi">35</span><span class="p">:</span>	<span class="nx">fffff803309f9b18</span> <span class="nx">nt</span><span class="o">!</span><span class="nc">HalpInterruptCmciService </span><span class="p">(</span><span class="nx">KINTERRUPT</span> <span class="nx">fffff803312f2f40</span><span class="p">)</span>
<span class="mi">36</span><span class="p">:</span>	<span class="nx">fffff803309f9b20</span> <span class="nx">nt</span><span class="o">!</span><span class="nc">HalpInterruptCmciService </span><span class="p">(</span><span class="nx">KINTERRUPT</span> <span class="nx">fffff803312f3180</span><span class="p">)</span>
<span class="mi">50</span><span class="p">:</span>	<span class="nx">fffff803309f9bf0</span> <span class="nx">dxgkrnl</span><span class="o">!</span><span class="nc">DpiFdoLineInterruptRoutine </span><span class="p">(</span><span class="nx">KINTERRUPT</span> <span class="nx">ffffa600bf1fb500</span><span class="p">)</span>
<span class="mi">60</span><span class="p">:</span>	<span class="nx">fffff803309f9c70</span> <span class="nx">USBPORT</span><span class="o">!</span><span class="nc">USBPORT_InterruptService </span><span class="p">(</span><span class="nx">KINTERRUPT</span> <span class="nx">ffffa600bf1fb780</span><span class="p">)</span>
<span class="mi">70</span><span class="p">:</span>	<span class="nx">fffff803309f9cf0</span> <span class="nx">VBoxGuest</span><span class="o">+</span><span class="mh">0x22e0</span> <span class="p">(</span><span class="nx">KINTERRUPT</span> <span class="nx">ffffa600bf1fbb40</span><span class="p">)</span>
<span class="mi">80</span><span class="p">:</span>	<span class="nx">fffff803309f9d70</span> <span class="nx">storport</span><span class="o">!</span><span class="nc">RaidpAdapterInterruptRoutine </span><span class="p">(</span><span class="nx">KINTERRUPT</span> <span class="nx">ffffa600bf1fbc80</span><span class="p">)</span>
	                 <span class="nx">HDAudBus</span><span class="o">!</span><span class="nx">HdaController</span><span class="p">::</span><span class="nc">Isr </span><span class="p">(</span><span class="nx">KINTERRUPT</span> <span class="nx">ffffa600bf1fb640</span><span class="p">)</span>
<span class="mi">90</span><span class="p">:</span>	<span class="nx">fffff803309f9df0</span> <span class="nx">i8042prt</span><span class="o">!</span><span class="nc">I8042MouseInterruptService </span><span class="p">(</span><span class="nx">KINTERRUPT</span> <span class="nx">ffffa600bf1fb8c0</span><span class="p">)</span>
<span class="nx">a0</span><span class="p">:</span>	<span class="nx">fffff803309f9e70</span> <span class="nx">i8042prt</span><span class="o">!</span><span class="nc">I8042KeyboardInterruptService </span><span class="p">(</span><span class="nx">KINTERRUPT</span> <span class="nx">ffffa600bf1fba00</span><span class="p">)</span>
<span class="nx">b0</span><span class="p">:</span>	<span class="nx">fffff803309f9ef0</span> <span class="nx">ACPI</span><span class="o">!</span><span class="nc">ACPIInterruptServiceRoutine </span><span class="p">(</span><span class="nx">KINTERRUPT</span> <span class="nx">ffffa600bf1fbdc0</span><span class="p">)</span>
<span class="nx">ce</span><span class="p">:</span>	<span class="nx">fffff803309f9fe0</span> <span class="nx">nt</span><span class="o">!</span><span class="nc">HalpIommuInterruptRoutine </span><span class="p">(</span><span class="nx">KINTERRUPT</span> <span class="nx">fffff803312f3ba0</span><span class="p">)</span>
<span class="nx">d1</span><span class="p">:</span>	<span class="nx">fffff803309f9ff8</span> <span class="nx">nt</span><span class="o">!</span><span class="nc">HalpTimerClockInterrupt </span><span class="p">(</span><span class="nx">KINTERRUPT</span> <span class="nx">fffff803312f3960</span><span class="p">)</span>
<span class="nx">d2</span><span class="p">:</span>	<span class="nx">fffff803309fa000</span> <span class="nx">nt</span><span class="o">!</span><span class="nc">HalpTimerClockIpiRoutine </span><span class="p">(</span><span class="nx">KINTERRUPT</span> <span class="nx">fffff803312f3840</span><span class="p">)</span>
<span class="nx">d7</span><span class="p">:</span>	<span class="nx">fffff803309fa028</span> <span class="nx">nt</span><span class="o">!</span><span class="nc">HalpInterruptRebootService </span><span class="p">(</span><span class="nx">KINTERRUPT</span> <span class="nx">fffff803312f3600</span><span class="p">)</span>
<span class="nx">d8</span><span class="p">:</span>	<span class="nx">fffff803309fa030</span> <span class="nx">nt</span><span class="o">!</span><span class="nc">HalpInterruptStubService </span><span class="p">(</span><span class="nx">KINTERRUPT</span> <span class="nx">fffff803312f33c0</span><span class="p">)</span>
<span class="nx">df</span><span class="p">:</span>	<span class="nx">fffff803309fa068</span> <span class="nx">nt</span><span class="o">!</span><span class="nc">HalpInterruptSpuriousService </span><span class="p">(</span><span class="nx">KINTERRUPT</span> <span class="nx">fffff803312f32a0</span><span class="p">)</span>
<span class="nx">e1</span><span class="p">:</span>	<span class="nx">fffff803309fd8b0</span> <span class="nx">nt</span><span class="o">!</span><span class="nx">KiIpiInterrupt</span>
<span class="nx">e2</span><span class="p">:</span>	<span class="nx">fffff803309fa080</span> <span class="nx">nt</span><span class="o">!</span><span class="nc">HalpInterruptLocalErrorService </span><span class="p">(</span><span class="nx">KINTERRUPT</span> <span class="nx">fffff803312f34e0</span><span class="p">)</span>
<span class="nx">e3</span><span class="p">:</span>	<span class="nx">fffff803309fa088</span> <span class="nx">nt</span><span class="o">!</span><span class="nc">HalpInterruptDeferredRecoveryService </span><span class="p">(</span><span class="nx">KINTERRUPT</span> <span class="nx">fffff803312f3060</span><span class="p">)</span>
<span class="nx">fd</span><span class="p">:</span>	<span class="nx">fffff803309fa158</span> <span class="nx">nt</span><span class="o">!</span><span class="nc">HalpTimerProfileInterrupt </span><span class="p">(</span><span class="nx">KINTERRUPT</span> <span class="nx">fffff803312f3a80</span><span class="p">)</span>
<span class="nx">fe</span><span class="p">:</span>	<span class="nx">fffff803309fa160</span> <span class="nx">nt</span><span class="o">!</span><span class="nc">HalpPerfInterrupt </span><span class="p">(</span><span class="nx">KINTERRUPT</span> <span class="nx">fffff803312f3720</span><span class="p">)</span>
</code></pre></div></div>

<p>Возьмём снова наш обработчик клавиатуры по оффсету a0</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">kd</span><span class="o">&gt;</span> <span class="nx">dt</span> <span class="nf">_kidtentry64 </span><span class="p">(</span><span class="nx">idtr</span> <span class="o">+</span> <span class="p">(</span><span class="mh">0xa0</span><span class="o">*</span><span class="mh">0x10</span><span class="p">))</span>
<span class="nx">ntdll</span><span class="o">!</span><span class="nx">_KIDTENTRY64</span>
   <span class="o">+</span><span class="mh">0x000</span> <span class="nx">OffsetLow</span>        <span class="p">:</span> <span class="mh">0x9e70</span>
   <span class="o">+</span><span class="mh">0x002</span> <span class="nx">Selector</span>         <span class="p">:</span> <span class="mh">0x10</span>
   <span class="o">+</span><span class="mh">0x004</span> <span class="nx">IstIndex</span>         <span class="p">:</span> <span class="mi">0</span><span class="nx">y000</span>
   <span class="o">+</span><span class="mh">0x004</span> <span class="nx">Reserved0</span>        <span class="p">:</span> <span class="mi">0</span><span class="nf">y00000 </span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
   <span class="o">+</span><span class="mh">0x004</span> <span class="nx">Type</span>             <span class="p">:</span> <span class="mi">0</span><span class="nf">y01110 </span><span class="p">(</span><span class="mh">0xe</span><span class="p">)</span>
   <span class="o">+</span><span class="mh">0x004</span> <span class="nx">Dpl</span>              <span class="p">:</span> <span class="mi">0</span><span class="nx">y00</span>
   <span class="o">+</span><span class="mh">0x004</span> <span class="nx">Present</span>          <span class="p">:</span> <span class="mi">0</span><span class="nx">y1</span>
   <span class="o">+</span><span class="mh">0x006</span> <span class="nx">OffsetMiddle</span>     <span class="p">:</span> <span class="mh">0x309f</span>
   <span class="o">+</span><span class="mh">0x008</span> <span class="nx">OffsetHigh</span>       <span class="p">:</span> <span class="mh">0xfffff803</span>
   <span class="o">+</span><span class="mh">0x00c</span> <span class="nx">Reserved1</span>        <span class="p">:</span> <span class="mi">0</span>
   <span class="o">+</span><span class="mh">0x000</span> <span class="nx">Alignment</span>        <span class="p">:</span> <span class="mh">0x309f8e00</span><span class="s2">`00109e70
</span></code></pre></div></div>

<p>Найдём ISR entry point для него, теперь для 64 бит схема немного другая:</p>

<p>OffsetHigh + OffsetMiddle + OffsetLow</p>

<p>0xfffff803309f9e70</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">Offset</span><span class="p">:</span> <span class="mh">0xfffff803309f9e70</span>
<span class="nx">fffff803</span><span class="s2">`309f9e70 6aa0            push    0FFFFFFFFFFFFFFA0h
fffff803`</span><span class="mi">309</span><span class="nx">f9e72</span> <span class="mi">55</span>              <span class="nx">push</span>    <span class="nx">rbp</span>
<span class="nx">fffff803</span><span class="s2">`309f9e73 e909030000      jmp     nt!KiIsrLinkage (fffff803`</span><span class="mi">309</span><span class="nx">fa181</span><span class="p">)</span>
</code></pre></div></div>

<p>Если в табличке !idt искать KINTERRUPT не хочется, можно сделать так:</p>
<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">kd</span><span class="o">&gt;</span> <span class="nx">dt</span> <span class="p">@</span><span class="nx">$pcr</span> <span class="nx">nt</span><span class="o">!</span><span class="nx">_KPCR</span> <span class="o">-</span><span class="nx">a</span> <span class="nx">Prcb</span><span class="p">.</span><span class="nx">InterruptObject</span><span class="p">[</span><span class="mh">0xa0</span><span class="p">]</span>
   <span class="o">+</span><span class="mh">0x180</span> <span class="nx">Prcb</span>                       <span class="p">:</span> 
      <span class="o">+</span><span class="mh">0x3140</span> <span class="nx">InterruptObject</span>            <span class="p">:</span> <span class="p">[</span><span class="mi">160</span><span class="p">]</span> <span class="mh">0xffffa600</span><span class="s2">`bf1fba00 Void
      
      
kd&gt; dt nt!_KINTERRUPT ffffa600bf1fba00
   +0x000 Type             : 0n22
   +0x002 Size             : 0n288
   +0x008 InterruptListEntry : _LIST_ENTRY [ 0x00000000`</span><span class="mi">00000000</span> <span class="o">-</span> <span class="mh">0x00000000</span><span class="s2">`00000000 ]
   +0x018 ServiceRoutine   : 0xfffff803`</span><span class="mi">36096790</span>     <span class="nx">unsigned</span> <span class="nx">char</span>  <span class="nx">i8042prt</span><span class="o">!</span><span class="nx">I8042KeyboardInterruptService</span><span class="o">+</span><span class="mi">0</span>
   <span class="o">+</span><span class="mh">0x020</span> <span class="nx">MessageServiceRoutine</span> <span class="p">:</span> <span class="p">(</span><span class="kc">null</span><span class="p">)</span> 
   <span class="o">+</span><span class="mh">0x028</span> <span class="nx">MessageIndex</span>     <span class="p">:</span> <span class="mi">0</span>
   <span class="o">+</span><span class="mh">0x030</span> <span class="nx">ServiceContext</span>   <span class="p">:</span> <span class="mh">0xffffcf8b</span><span class="s2">`4e304040 Void
   +0x038 SpinLock         : 0
   +0x040 TickCount        : 0
   +0x048 ActualLock       : 0xffffcf8b`</span><span class="mi">4</span><span class="nx">e3041a0</span>  <span class="o">-&gt;</span> <span class="mi">0</span>
   <span class="o">+</span><span class="mh">0x050</span> <span class="nx">DispatchAddress</span>  <span class="p">:</span> <span class="mh">0xfffff803</span><span class="s2">`309f8c70     void  nt!KiInterruptDispatch+0
   +0x058 Vector           : 0xa0
   +0x05c Irql             : 0xa ''
   +0x05d SynchronizeIrql  : 0xa ''
   +0x05e FloatingSave     : 0 ''
   +0x05f Connected        : 0x1 ''
   +0x060 Number           : 0
   +0x064 ShareVector      : 0 ''
   +0x065 EmulateActiveBoth : 0 ''
   +0x066 ActiveCount      : 0
   +0x068 InternalState    : 0n0
   +0x06c Mode             : 1 ( Latched )
   +0x070 Polarity         : 0 ( InterruptPolarityUnknown )
   +0x074 ServiceCount     : 0
   +0x078 DispatchCount    : 0
   +0x080 PassiveEvent     : (null) 
   +0x088 TrapFrame        : 0xfffffb82`</span><span class="mi">3</span><span class="nx">ab14a20</span> <span class="nx">_KTRAP_FRAME</span>
   <span class="o">+</span><span class="mh">0x090</span> <span class="nx">DisconnectData</span>   <span class="p">:</span> <span class="p">(</span><span class="kc">null</span><span class="p">)</span> 
   <span class="o">+</span><span class="mh">0x098</span> <span class="nx">ServiceThread</span>    <span class="p">:</span> <span class="p">(</span><span class="kc">null</span><span class="p">)</span> 
   <span class="o">+</span><span class="mh">0x0a0</span> <span class="nx">ConnectionData</span>   <span class="p">:</span> <span class="mh">0xffffcf8b</span><span class="s2">`4e467d00 _INTERRUPT_CONNECTION_DATA
   +0x0a8 IntTrackEntry    : 0xffffcf8b`</span><span class="mi">4</span><span class="nx">ccac690</span> <span class="nx">Void</span>
   <span class="o">+</span><span class="mh">0x0b0</span> <span class="nx">IsrDpcStats</span>      <span class="p">:</span> <span class="nx">_ISRDPCSTATS</span>
   <span class="o">+</span><span class="mh">0x110</span> <span class="nx">RedirectObject</span>   <span class="p">:</span> <span class="p">(</span><span class="kc">null</span><span class="p">)</span> 
   <span class="o">+</span><span class="mh">0x118</span> <span class="nx">PhysicalDeviceObject</span> <span class="p">:</span> <span class="p">(</span><span class="kc">null</span><span class="p">)</span> 
</code></pre></div></div>

<h4 id="напочитать"><a href="#header-4"></a>напочитать:</h4>

<p><a href="http://trapframe.github.io/just-enough-kernel-to-get-by">Ориг статья с экспериментами</a></p>

<p><a href="https://www.ired.team/miscellaneous-reversing-forensics/windows-kernel-internals/interrupt-descriptor-table-idt">https://www.ired.team/miscellaneous-reversing-forensics/windows-kernel-internals/interrupt-descriptor-table-idt</a></p>

<p><a href="https://vivek-arora.com/?p=801">https://vivek-arora.com/?p=801</a></p>

<p><a href="https://www.ired.team/miscellaneous-reversing-forensics/windows-kernel-internals/glimpse-into-ssdt-in-windows-x64-kernel">https://www.ired.team/miscellaneous-reversing-forensics/windows-kernel-internals/glimpse-into-ssdt-in-windows-x64-kernel</a></p>

<p><a href="https://codemachine.com/articles/interrupt_dispatching.html">https://codemachine.com/articles/interrupt_dispatching.html</a></p>

</article>
      </section>
    </div>
  </div>
</body>

</html>
